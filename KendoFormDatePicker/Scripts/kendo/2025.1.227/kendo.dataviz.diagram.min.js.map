{"version":3,"sources":["raw-js/kendo.dataviz.diagram.js"],"names":["global","factory","exports","module","require","define","amd","globalThis","self","kendo","_globals","DatavizDiagram","this","$","window","diagram","dataviz","deepExtend","isArray","Array","Utils","isNearZero","num","Math","abs","isDefined","obj","isUndefined","isObject","Object","has","key","hasOwnProperty","call","isString","prototype","toString","isBoolean","isType","type","isNumber","isNaN","parseFloat","isFinite","isEmpty","length","simpleExtend","destination","source","name","initArray","size","value","array","i","serializePoints","points","res","p","push","x","y","join","deserializePoints","s","v","split","Point","parseInt","randomInteger","lower","upper","floor","random","DFT","el","func","childNodes","item","getMatrixAngle","m","d","atan2","b","PI","getMatrixScaling","sqrt","a","c","sign","number","findAngle","center","end","start","sngXComp","sngYComp","atan","findRadian","forEach","arr","iterator","thisRef","any","predicate","remove","what","ax","indexOf","splice","contains","inArray","fold","list","acc","context","initial","arguments","find","result","index","first","constraint","insert","element","position","all","clear","bisort","sortfunc","sort","n","addRange","range","apply","Easing","pos","cos","Ticker","Class","extend","init","adapters","target","tick","interval","duration","lastTime","handlers","_this","transition","timerDelegate","onTimerEvent","addAdapter","onComplete","handler","removeHandler","grep","h","trigger","caller","onStep","seekTo","to","seekFromTo","from","max","min","Date","getTime","intervalId","setInterval","stop","clearInterval","play","origin","initState","reverse","propagate","update","now","timePassed","movement","ui","Range","step","Infinity","j","k","rangeIntegerScale","jQuery","geometry","isFunction","map","ExtendedPoint","constructor","super","clone","plus","minus","offset","times","normalize","lengthSquared","middleOf","q","toPolar","useDegrees","factor","halfpi","len","Polar","isOnLine","temp","o1","u1","r1","Rect","inflate","r2","union","height","width","parse","str","xy","slice","PathDefiner","left","right","point","dx","dy","r","x1","y1","x2","y2","top","bottom","topLeft","topRight","bottomLeft","bottomRight","equals","rect","rotatedBounds","angle","rotatedPoints","tl","tr","br","bl","rotate","delimiter","scale","scaleX","scaleY","staicPoint","adornerCenter","thisCenter","delta","scaled","zoom","overlaps","rectBottomRight","Size","intersectLine","start1","end1","start2","end2","isSegment","tangensdiff","Empty","toRect","empty","fromPoints","Intersect","lines","segments","rectWithLine","rects","rect1","rect2","intersect","reverseAngle","RectAlign","container","align","content","alignment","alignValues","toLowerCase","_singleAlign","_align","_left","_center","_right","stretch","_stretch","_top","middle","_middle","_bottom","alignCalc","Matrix","e","f","applyRect","fromSVGMatrix","vm","fromMatrixVector","fromList","translation","unit","rotation","sin","scaling","parts","nums","trim","substr","MatrixVector","fromMatrix","randomId","chars","charAt","round","Geometry","_distanceToLineSquared","d2","pt1","pt2","vx","vy","dot","distanceToLine","distanceToPolyline","minimum","Number","MAX_VALUE","p1","p2","HashTable","_buckets","add","_createGetBucket","get","_bucketExists","set","containsKey","hashId","_hash","hashes","_hashes","hash","bucket","ht","_hashString","_objectHashId","charCodeAt","id","_hashId","Dictionary","Observable","dictionary","fn","_hashTable","entry","Error","forEachValue","forEachKey","keys","Queue","_tail","_head","enqueue","next","dequeue","current","Set","resource","kv","toArray","Node","shape","links","outgoing","incoming","weight","associatedShape","bounds","data","shortForm","isVirtual","isIsolated","isLinkedTo","node","that","link","getComplement","getChildren","children","getParents","parents","copy","balance","owner","adjacentTo","removeLink","hasLinkTo","degree","incidentWith","getLinksWith","getNeighbors","neighbors","Link","connection","sourceFound","targetFound","associatedConnection","getCommonNode","isBridging","v1","v2","getNodes","changeSource","changeTarget","changesNodes","w","oldSource","oldTarget","directTo","createReverseEdge","reversed","Graph","idOrDiagram","nodes","_nodeMap","_root","_hasCachedRelationships","cacheRelationships","forceRebuild","assignLevels","startNode","visited","level","child","root","found","getConnectedComponents","componentIndex","setItemIndices","componentId","_collectConnectedNodes","components","addNodeAndOutgoings","setIds","nodeIndex","nextId","calcBounds","getSpanningTree","tree","remaining","_addNode","levelCount","pop","ni","cn","newLink","addLink","treeLevels","takeRandomNode","excludedNodes","incidenceLessThan","pool","isHealthy","hasNode","sourceOrLink","addExistingLink","foundSource","getNode","addNode","foundTarget","removeAllLinks","hasLink","t","linkOrId","nodeOrId","_removeNode","removeNode","areConnected","n1","n2","layoutRect","newNode","newLinks","saveMapping","save","nodeMap","linkMap","nOriginal","nCopy","linkOriginal","linkCopy","linearize","addIds","depthFirstTraversal","action","foundNode","_dftIterator","breadthFirstTraversal","queue","_stronglyConnectedComponents","excludeSingleItems","indices","lowLinks","connected","stack","component","findCycles","isAcyclic","isSubGraph","other","otherArray","thisArray","makeAcyclic","oneNode","rev","N","intensityCatalog","flowIntensity","catalogEqualIntensity","intensity","sourceStack","targetStack","targets","li","targetLink","unshift","sources","si","sourceLink","ri","ril","u","concat","vertexOrder","kk","reversedEdges","Predefined","EightGraph","Mindmap","ThreeGraph","BinaryTree","levels","createBalancedTree","Linear","Tree","siblingsCount","Forest","trees","createBalancedForest","Workflow","Grid","g","previous","graphString","previousLink","graph","part","lin","_addShape","kendoDiagram","shapeDefaults","radius","fill","undoable","addShape","_addConnection","options","connect","createDiagramFromGraph","doLayout","randomSize","clientWidth","clientHeight","opt","color","gli","sourceShape","targetShape","SpringLayout","layoutGraph","limitToView","shi","news","counter","lastAdded","parent","treeCount","createRandomConnectedGraph","nodeCount","maxIncidence","isTree","poolNode","randomAdditions","randomDiagram","shapeCount","normalVariable","mean","deviation","log","undefined$1","drawing","defined","util","TRANSPARENT","Markers","none","arrowStart","filledCircle","arrowEnd","START","END","WIDTH","HEIGHT","diffNumericOptions","fields","field","elementOptions","hasChanges","Scale","toMatrix","format","invert","Translation","toMatrixVector","Length","Rotation","ZERO","create","values","CompositeTransform","translate","transform","render","visual","_transform","_renderTransform","rotateMatrix","scaleMatrix","translatePoint","AutoSizeableMixin","_setScale","originWidth","_originWidth","originHeight","_originHeight","_setTranslate","_initSize","autoSize","_measure","_updateSize","_diffNumericOptions","Element","_originSize","visible","drawingContainer","redraw","drawingElement","matrix","_hover","force","_measured","box","_boundingBox","startPoint","rawBBox","VisualBase","normalizeDrawingOptions","stroke","opacity","_fill","getColor","_stroke","show","hover","strokeOptions","dashType","fillOptions","gradient","GradientClass","RadialGradient","LinearGradient","TextBlock","_textColor","_font","_initText","fontSize","fontFamily","Text","text","font","fontOptions","fontStyle","fontWeight","sizeChanged","textOptions","Rectangle","_initPath","_setPosition","_drawPath","Path","closed","sizeOptions","sizeOptionsOrDefault","elements","createSegment","MarkerBase","anchor","createElement","_transformToPath","path","transformCopy","CircleMarker","Circle","positionMarker","targetSegment","ArrowMarker","xDiff","yDiff","_linePoints","deg","endPoint","controlOut","nextSegment","controlIn","prevSegment","MarkerPathMixin","_getPath","MultiPath","paths","_normalizeMarkerOptions","startCap","endCap","_removeMarker","marker","_markers","_createMarkers","_createMarker","markerType","append","_positionMarker","_capMap","_redrawMarker","pathChange","pathOptions","cap","pathCapType","optionsCap","created","_redrawMarkers","Group","_createElements","_setData","multipath","Line","Polyline","_updatePath","_pointsDiffer","currentPoints","differ","Image","_initImage","src","_rect","_childrenChange","_remove","removeAt","toFront","visuals","toBack","_reorderChildren","toIndex","group","drawingChildren","fixedPosition","boundingBox","childBoundingBox","_includeInBBox","clippedBBox","Layout","toDrawingRect","drawingRect","reflow","_initCircle","circleOptions","move","_circle","setRadius","Canvas","surface","Surface","_translate","_viewBox","viewBox","setSize","draw","insertBefore","destroy","clearHtml","drawingOptions","Color","toHex","Segment","Movable","Cursors","arrow","grip","cross","select","south","east","west","north","rowresize","colresize","HIT_TEST_DISTANCE","AUTO","TOP","RIGHT","LEFT","BOTTOM","DRAG_START","DRAG","DRAG_END","ITEMBOUNDSCHANGE","ROTATED","TARGET","HANDLE_NAMES","PositionAdapter","layoutState","froms","tos","subjects","getShapeById","LayoutUndoUnit","initialState","finalState","animate","_initialState","_finalState","title","undo","setState","redo","state","conn","ticker","CompositeUnit","units","undoUnit","ConnectionEditUnit","redoSource","redoTarget","_redoSource","_redoTarget","_undoSource","_undoTarget","_updateConnector","updateModel","ConnectionEditUndoUnit","undoSource","undoTarget","DeleteConnectionUnit","targetConnector","DeleteShapeUnit","TransformUnit","shapes","undoStates","adorner","redoStates","layout","refreshBounds","refresh","AddConnectionUnit","AddShapeUnit","deselect","PanUndoUnit","initialPosition","finalPosition","finalPos","pan","RotateUnit","undoRotates","redoRotates","redoAngle","_angle","_innerBounds","_initialize","ToFrontUnit","items","initialIndices","_toIndex","ToBackUnit","UndoRedoService","bind","events","capacity","begin","composite","cancel","commit","execute","_restart","addCompositeItem","count","EmptyTool","toolService","tryActivate","getCursor","ScrollerTool","tool","friction","support","mobileOS","canvas","scroller","scrollable","kendoMobileScroller","velocityMultiplier","mousewheelScrolling","scroll","_move","movableCanvas","virtualScroll","dimension","makeVirtual","virtualSize","dimensions","disable","meta","pannable","enabled","ctrlKey","noMeta","hoveredItem","hoveredAdorner","_hoveredConnector","enable","args","scrollPos","scrollLeft","scrollTop","_storePan","moveTo","_pan","PointerTool","selectSingle","handle","_hitTest","_resizingAdorner","isDragHandle","connections","undoRedoService","_getCursor","SelectionTool","selectable","multiple","selector","isSelected","selectArea","ConnectionTool","connector","_createConnection","_c","canDrag","connectionHandle","_connectionManipulation","_removeHover","activeConnection","_cachedTouchTarget","cachedTouchTarget","sourceConnector","Shape","getConnector","_syncConnectionChanges","_connectorsAdorner","ConnectionEditTool","isActive","handleName","testKey","toUpperCase","ToolService","tools","activeTool","_updateHoveredItem","_activateTool","_updateCursor","focus","suspendTracking","updateHovered","resumeTracking","keyDown","metaKey","altKey","toRemove","_triggerRemove","_syncChanges","_destroyToolBar","_discardNewConnection","selectAll","cut","paste","wheel","z","zoomRate","zoomOptions","zoomMin","zoomMax","setTool","addToSelection","newConnection","cursor","css","disabledShape","isNew","hit","_visible","selectedConnections","_selectedItems","Connection","_hitTestItems","_hitTestElements","shapeHit","connectionHit","idx","connectors","hitTestShapeConnectors","mainLayer","ConnectionRouterBase","LinearConnectionRouter","hitTest","getBounds","allPoints","PolylineRouter","route","CascadingRouter","SAME_SIDE_DISTANCE_RATIO","routePoints","_connectorPoints","_floatingPoints","_resolvedSourceConnector","_resolvedTargetConnector","sourcePoint","targetPoint","_connectorSides","axis","boundsPoint","secondarySign","_connectorSide","sideDistance","minSide","side","shapeBounds","sides","MAX_NUM","_sameSideDistance","pointX","pointY","sourceConnectorSide","targetConnectorSide","deltaX","deltaY","sameSideDistance","shiftX","shiftY","cascadeStartHorizontal","_startHorizontal","sourceSide","AdornerBase","_adorners","ConnectionEditAdorner","_ts","sp","tp","spVisual","handles","epVisual","_initialSource","_initialTarget","ts","radiusX","radiusY","sourcePointDistance","distanceTo","targetPointDistance","sourceHandle","targetHandle","modelToLayer","ConnectorsAdorner","_refreshHandler","ctr","_clearVisual","ConnectorVisual","_keepCachedTouchTarget","visualChildren","childrenCount","unbind","each","ResizingAdorner","_manipulating","_initSelection","_createHandles","selected","_internalChange","_rotatedHandler","_resizable","editable","resize","_handleOptions","_bounds","handleBounds","handlesCount","_getHandleBounds","_rotationOffset","_startAngle","_rotates","_positions","initialRotates","initialStates","handleOptions","_sp","_cp","_lp","shapeStates","visibleHandles","currentAngle","dragging","newBounds","staticPoint","dtl","dbr","changed","_truncateAngle","_rotating","shouldSnap","thr","_truncateDistance","hitToOppositeSide","_displaceBounds","newCenter","minWidth","minHeight","oldBounds","states","_truncatePositionToGuides","ruler","truncatePositionToGuides","_truncateSizeToGuides","truncateSizeToGuides","snap","snapOptions","snapAngle","snapSize","drag","_diffStates","_syncShapeChanges","rotationThumb","thumb","_rotationThumbBounds","Selector","_ep","_adorn","visualBounds","modelToView","relative","_visualBounds","shiftKey","HyperTree","EPSILON","DEG_TO_RAD","LayoutBase","defaultOptions","subtype","roots","nodeDistance","iterations","horizontalSeparation","verticalSeparation","underneathVerticalTopOffset","underneathHorizontalOffset","underneathVerticalSeparation","grid","offsetX","offsetY","componentSpacingX","componentSpacingY","layerSeparation","layeredIterations","startRadialAngle","endRadialAngle","radialSeparation","radialFirstLevelSeparation","keepComponentsInOneRadialLayout","ignoreContainers","layoutContainerChildren","ignoreInvisible","animateTransitions","gridLayoutComponents","maxWidth","startX","resultLinkSet","resultNodeSet","moveToOffset","boundingRect","currentHeight","currentWidth","deltax","deltay","nodeBounds","newpoints","pt","currentHorizontalOffset","transferOptions","DiagramToHyperTreeAdapter","shapeMap","edges","edgeMap","finalNodes","finalLinks","ignoredConnections","ignoredShapes","hyperMap","hyperTree","finalGraph","convert","_renormalizeShapes","_renormalizeConnections","l","mapConnection","mapShape","getEdge","listToRoot","containerGraph","parentContainer","firstNonIgnorableContainer","isContainer","_isIgnorableItem","isContainerConnection","isDescendantOf","scope","containers","isIgnorableItem","isCollapsed","_isVisible","_isTop","isShapeMapped","leastCommonAncestor","al","xa","xb","_isCollapsed","sink","sourceNode","sinkNode","areConnectedAlready","newEdge","finalNodeSet","LayoutState","initialTemperature","temperature","guessBounds","_expectedBounds","refineStage","_repulsion","_attraction","_shake","rho","alpha","_InverseSquareForce","wn","hn","wm","hm","pow","_SquareForce","distance","squareSize","area","ceil","TreeLayoutProcessor","treeGraph","layoutSwitch","layoutLeft","setChildrenDirection","setChildrenLayout","TreeDirection","measure","Width","arrange","layoutRight","layoutUp","up","layoutDown","down","treeDirection","layoutRadialTree","previousRoot","startAngle","endAngle","maxDepth","calculateAngularWidth","radialLayout","Angle","tipOverTree","startFromLevel","aw","diameter","sectorAngle","sortChildren","basevalue","pl","nl","normalizeAngle","col","deltaTheta","deltaThetaHalf","parentSector","fraction","sorted","childNode","cp","childAngleFraction","setPolarLocation","BoundingRectangle","direction","includeStart","rootDirection","rootLayout","childrenLayout","givenSize","shapeWidth","shapeHeight","AngleToParent","SectorAngle","pp","childrenwidth","selfLocation","single","male","female","leftcount","tipOverTreeStartLevel","TreeLayout","adapter","layoutComponents","getTree","getTreeForRoot","LayeredLayout","_initRuntimeProperties","layer","downstreamLinkCount","upstreamLinkCount","uBaryCenter","dBaryCenter","upstreamPriority","downstreamPriority","gridPosition","_prepare","targetLayer","layerMap","layerCount","shift","sortedNodes","o2","o1layer","o2layer","minLayer","layers","linksTo","_dummify","_optimizeCrossings","_swapPairs","arrangeNodes","_moveThingsAround","_dedummify","setMinDist","minDist","layerIndex","minDistances","getMinDist","dist","i1","i2","placeLeftToRight","leftClasses","leftPos","classNodes","placeLeft","POSITIVE_INFINITY","rightSibling","nodeLeftClass","D","upNodes","downNodes","neighbor","intDiv","placeRightToLeft","rightClasses","rightPos","placeRight","NEGATIVE_INFINITY","leftSibling","nodeRightClass","_getLeftWing","leftWing","computeClasses","_getRightWing","rightWing","wingPair","currentWing","wing","ndsinl","_nodesInLink","vnode","wings","classIndex","_isVerticalLayout","_isHorizontalLayout","_isIncreasingLayout","_gridPositionComparer","dest","currentNode","currDown","downNode","order","placed","sequenceStart","virtualStartIndex","_firstVirtualNode","virtualStart","sequence","_sequencer","virtualEnd","nextVirtualNode","virtualEndIndex","adjustDirections","ctx","fromLayerIndex","layerIncrement","maximumHeight","MIN_VALUE","prevBridge","prevBridgeTarget","nextBridge","nextBridgeTarget","getNeighborOnLayer","clayer","j1","j2","dir","_sequenceSingle","combineSequences","pair","leftHeap","_positionDescendingComparer","rightHeap","_positionAscendingComparer","leftRes","rightRes","leftClass","_getComposite","rightClass","it","layoutLayer","gridPos","iconsidered","considered","n1Priority","n2Priority","nodeGridPos","nodeBaryCenter","calcBaryCenter","nodePriority","moveRight","moveLeft","calcDownData","calcUpData","priority","rightNode","rightNodePriority","leftNode","leftNodePriority","mapVirtualNode","nodeToLinkMap","linkToNodeMap","addLinkBetweenLayers","upLayer","downLayer","o","oLayer","dLayer","oPos","dPos","depthOfDumminess","dedum","prevLink","moves","iter","optimizeLayerCrossings","sum","total","presorted","n1BaryCenter","n2BaryCenter","compareByIndex","compareValue","inode","maxIterations","downwards","secondPass","hasSwapped","calcCrossings","memCrossings","crossBefore","countLinksCrossingBetweenTwoLayers","node1","node2","node1GridPos","node2GridPos","crossAfter","ulayer","dlayer","link1","link2","n11","n12","n21","n22","l1","l2","crossings","n11gp","n12gp","numerator","denominator","graphOrNodes","capture","diagramOrGraphOrNodes","GraphAdapter","elementStyles","ownerDocument","defaultView","getComputedStyle","cache","getProp","prop","getPropertyValue","test","colorMix","curColor","style","toColor","diagramTheme","primaryBg","primaryContrast","normalTextColor","connectorDefaults","connectionDefaults","selection","geom","Widget","outerWidth","_outerWidth","outerHeight","_outerHeight","HierarchicalDataSource","isPlainObject","math","NS","CASCADING","CHANGE","CLICK","ERROR","MAXINT","SELECT","ITEMROTATE","PAN","ZOOM_START","ZOOM_END","NONE","TRANSFORMED","MOUSEWHEEL_NS","BUTTON_TEMPLATE","className","icon","themeColor","html","renderButton","DefaultConnectors","getPosition","defaultButtons","imageClass","isAutoConnector","closestConnector","resCtr","minimumDistance","indicesOfItems","extra","defaults","DiagramElement","dataItem","_template","serializable","serialize","json","_content","contentOptions","_contentVisual","_updateContentVisual","_createContentVisual","template","elementTemplate","paramName","_canSelect","toJSON","Connector","shapeId","tempStr","updateOptionsFromModel","createShapeVisual","updateBounds","_createConnectors","_setOptionsFromModel","model","modelOptions","filterShapeDataItem","redrawVisual","_isEditable","_redrawVisual","syncChanges","_suspendModelRefresh","_resumeModelRefresh","_rotate","_alignContent","contentVisual","containerRect","aligner","contentBounds","bbox","contentRect","alignedBounds","_transformedBounds","_rotatedBounds","_setBounds","_triggerBoundsChange","_layouting","refreshConnections","cloneDataItem","deselected","_internalSelection","_selectionChanged","deltaAngle","newPosition","sc","con","cons","nameOrPoint","toLocaleLowerCase","fnName","_transformPoint","boundsChange","shapeOptions","shapeVisual","_visualOptions","_updateConnectors","_showConnectors","rotatedPoint","visualOptions","visualTemplate","_initRouter","_sourcePoint","_targetPoint","_setSource","_setTarget","definers","fromConnector","toConnector","dataMap","_dataMap","fromX","fromY","toX","toY","filterConnectionDataItem","connectionsDataSource","getByUid","uid","clearField","shapeSource","defaultConnector","_removeFromSourceConnector","_clearSourceConnector","_setFromOptions","fromPoint","sourceDefiner","_sourceDefiner","shapeTarget","_removeFromTargetConnector","_clearTargetConnector","_setToOptions","toPoint","targetDefiner","_targetDefiner","instance","connectorName","setNewTarget","inactiveItem","_inactiveShapeItems","_deferredConnectionUpdates","onActivate","endIdx","startIdx","alignToPath","midIdx","_router","pts","definition","_resolveConnectors","_refreshPath","sourceConnectors","targetConnectors","_resolveAutoConnectors","minNonConflictSource","minNonConflictTarget","minSource","minTarget","sourceIdx","targetIdx","minNonConflict","_testRoutePoints","router","passRoute","exclude","_getRouteExclude","_shapesQuadTree","hitTestRect","_isPointInsideShape","boundsX","boundsY","Diagram","userOptions","_initElements","_initTheme","_extendLayoutOptions","_initDefaults","_interactionDefaults","_initCanvas","ShapesQuadTree","adornerLayer","_createHandlers","_clipboard","pauseMouseHandlers","_fetchFreshData","_createGlobalToolBar","_createOptionElements","theme","dataSource","draggable","autoBind","tooltip","toolBar","DiagramToolBar","click","_toolBarClick","modal","textAlign","prepend","_resize","createShape","editor","view","createModel","_createShape","edit","createConnection","_connectionsDataMap","addConnection","editModel","editorType","editors","cancelEdit","shapeEditors","shapeTemplate","connectionSelectorHandler","connectionSelector","connectionEditors","connectionTemplate","PopupEditor","_update","_cancel","_editArgs","_getEditDataSource","cancelChanges","_destroyEditor","saveEdit","sync","wrapper","close","attr","addClass","appendTo","userShapeDefaults","copyDefaultOptions","mobile","canvasContainer","viewPort","viewport","on","_wheel","_keydown","_userEvents","UserEvents","multiTouch","fastTap","tap","_tap","_dragStart","_drag","_dragEnd","gesturestart","_gestureStart","gesturechange","_gestureChange","gestureend","_gestureEnd","doubleTap","_doubleTap","supportDoubleTap","_mouseover","_mouseout","_mouseMove","_mouseDown","_mouseUp","_syncHandler","_resizeHandler","onResize","_pauseMouseHandlers","_eventPositions","event","_meta","preventDefault","_createToolBar","focused","ctrlPressed","keyCode","origEvent","originalEvent","wheelDelta","detail","mwDelta","touch","pageX","pageY","documentToModel","initialCenter","eventArgs","_gesture","_initialCenter","previousGesture","documentToView","scaleDelta","_zoom","updateZoom","_getValidZoom","zoomedPoint","_panTransform","_updateAdorners","pointPosition","_kendoNode","srcElement","themeOptions","themeName","themes","SASS_THEMES","shapesLength","_createShapes","_createConnections","_findConnectionTarget","unbindResize","off","destroyScroller","_destroyGlobalToolBar","is","_activeElement","scrollContainer","offsets","documentElement","document","parentNode","scrollHeight","load","setOptions","added","removed","_parseBounds","splitDiagramElements","_removeItem","_removeShapeDataItem","_removeConnectionDataItem","_getDiagramItems","_fixOrdering","bringIntoView","original","newPan","_zoomMainLayer","alignShapes","val","raw","hideTooltip","_getPan","animatedScrollTo","scrollTo","_copyOffset","copied","mapping","_updateCopiedConnection","sourceConnection","di","_containerOffset","containerOffset","viewToDocument","viewToModel","_transformWithMatrix","_matrixInvert","_matrix","_layerMatrix","layerToModel","_layerMatrixInvert","viewPoint","modelToDocument","setDataSource","_dataSource","fetch","setConnectionsDataSource","_connectionDataSource","_redrawConnections","getShapeByModelId","getShapeByModelUid","getConnectionByModelId","getConnectionByModelUid","_transformMainLayer","_finishPan","NaN","_storeViewMatrix","_storeLayerMatrix","canvasTransform","shapePos","conPos","removedConnections","_removeShape","_removeConnection","_removeDataItems","recursive","_removeShapeConnections","hasChildren","loaded","_addDataItem","_addDataItemByUid","_addDataItems","parentShape","_refreshSource","dataBound","_bindingRoots","_addItem","preventClosing","singleToolBar","popupZIndex","closest","popupWidth","_popup","popupHeight","connectionBounds","showAt","one","_normalizePointZoom","InactiveItemsCollection","undone","redone","_loadingShapes","_loadingConnections","dsOptions","ds","_shapesRefreshHandler","_shapesRequestStartHandler","_shapesErrorHandler","_refreshShapes","_shapesRequestStart","_error","DataSource","_treeDataSource","_connectionsRefreshHandler","_connectionsRequestStartHandler","_connectionsErrorHandler","_refreshConnections","_connectionsRequestStart","_connectionsError","_shouldRefresh","_removeShapes","_updateShapes","_syncShapes","_suspended","_rebindShapesAndConnections","_addShapes","_addConnections","inactiveItems","activate","dataItems","_removeConnections","_updateConnections","_addConnectionDataItem","_validateConnector","_unbindDataSource","_errorHandler","adorners","_refresh","hide","exportDOMVisual","scrollOffset","viewRect","clipPath","fromRect","wrap","clipWrap","clip","exportVisual","when","then","deferredConnectionUpdates","ExportMixin","PDFMixin","_tools","createToolBar","createTools","appendTools","createPopup","kendoPopup","getKendoPopup","buttons","_toolBar","kendoToolBar","resizable","getKendoToolBar","createTool","toolName","attributes","_setAttributes","open","newGroup","editTool","showText","deleteTool","rotateAnticlockwiseTool","_appendGroup","_rotateGroup","rotateClockwiseTool","createShapeTool","_createGroup","createConnectionTool","undoTool","_historyGroup","redoTool","_getAttributes","eventData","selectedElements","delete","selectedElemens","rotateClockwise","rotateAnticlockwise","Editor","_getFields","_initContainer","createEditable","Editable","clearContainer","modelFields","columns","formContent","_renderTemplate","_renderFields","_renderButtons","Window","userTriggered","sender","_cancelClick","_attachButtonEvents","unescape","form","_createButton","_cancelClickHandler","_updateClickHandler","_updateClick","_editUpdateClickHandler","reader","textField","idField","kendoDropDownList","dataValueField","dataTextField","optionLabel","valuePrimitive","InactiveItem","callbacks","callback","deffered","Deferred","deferred","resolve","QuadRoot","_add","_quadNode","_testRect","QuadNode","inBounds","nodeRect","nodeBottomRight","overlapsBounds","inserted","_initChildren","childIdx","shapeIdx","halfWidth","halfHeight","ROOT_SIZE","boundsChangeHandler","_boundsChange","initRoots","rootMap","rootSize","sectors","getSectors","inRoot","bottomX","bottomY","xIdx","yIdx","Model","_defaultId","ObservableObject","mainOptions","plugin","kendo$1","__meta__","category","description","depends","features","default","defineProperty"],"mappings":"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","file":"kendo.dataviz.diagram.min.js","sourcesContent":["(function (global, factory) {\n    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('kendo.data.js'), require('kendo.draganddrop.js'), require('kendo.userevents.js'), require('kendo.mobile.scroller.js'), require('kendo.core.js'), require('kendo.dataviz.core.js'), require('kendo.drawing.js'), require('kendo.toolbar.js'), require('kendo.editable.js'), require('kendo.window.js'), require('kendo.dropdownlist.js'), require('kendo.dataviz.themes.js'), require('kendo.html.button.js')) :\n    typeof define === 'function' && define.amd ? define(['exports', 'kendo.data', 'kendo.draganddrop', 'kendo.userevents', 'kendo.mobile.scroller', 'kendo.core', 'kendo.dataviz.core', 'kendo.drawing', 'kendo.toolbar', 'kendo.editable', 'kendo.window', 'kendo.dropdownlist', 'kendo.dataviz.themes', 'kendo.html.button'], factory) :\n    (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory((global.kendo = global.kendo || {}, global.kendo._globals = global.kendo._globals || {}, global.kendo._globals.DatavizDiagram = {})));\n})(this, (function (exports) {\n    (function($, undefined$1) {\n        var kendo = window.kendo,\n            diagram = kendo.dataviz.diagram = {},\n            deepExtend = kendo.deepExtend,\n            isArray = Array.isArray,\n            EPSILON = 1e-06;\n\n        /*-------------------Diverse utilities----------------------------*/\n        var Utils = {\n        };\n\n        deepExtend(Utils, {\n            isNearZero: function(num) {\n                return Math.abs(num) < EPSILON;\n            },\n            isDefined: function(obj) {\n                return typeof obj !== 'undefined';\n            },\n\n            isUndefined: function(obj) {\n                return (typeof obj === 'undefined') || obj === null;\n            },\n            /**\n             * Returns whether the given object is an object or a value.\n             */\n            isObject: function(obj) {\n                return obj === Object(obj);\n            },\n            /**\n             * Returns whether the object has a property with the given name.\n             */\n            has: function(obj, key) {\n                return Object.hasOwnProperty.call(obj, key);\n            },\n            /**\n             * Returns whether the given object is a string.\n             */\n            isString: function(obj) {\n                return Object.prototype.toString.call(obj) == '[object String]';\n            },\n            isBoolean: function(obj) {\n                return Object.prototype.toString.call(obj) == '[object Boolean]';\n            },\n            isType: function(obj, type) {\n                return Object.prototype.toString.call(obj) == '[object ' + type + ']';\n            },\n            /**\n             * Returns whether the given object is a number.\n             */\n            isNumber: function(obj) {\n                return !isNaN(parseFloat(obj)) && isFinite(obj);\n            },\n            /**\n             * Return whether the given object (array or dictionary).\n             */\n            isEmpty: function(obj) {\n                if (obj === null) {\n                    return true;\n                }\n                if (isArray(obj) || Utils.isString(obj)) {\n                    return obj.length === 0;\n                }\n                for (var key in obj) {\n                    if (Utils.has(obj, key)) {\n                        return false;\n                    }\n                }\n                return true;\n            },\n            simpleExtend: function(destination, source) {\n                if (!Utils.isObject(source)) {\n                    return;\n                }\n\n                for (var name in source) {\n                    destination[name] = source[name];\n                }\n            },\n            /**\n             * Returns an array of the specified size and with each entry set to the given value.\n             * @param size\n             * @param value\n             * @returns {Array}\n             */\n            initArray: function createIdArray(size, value) {\n                var array = [];\n                for (var i = 0; i < size; ++i) {\n                    array[i] = value;\n                }\n                return array;\n            },\n            serializePoints: function(points) {\n                var res = [];\n                for (var i = 0; i < points.length; i++) {\n                    var p = points[i];\n                    res.push(p.x + \";\" + p.y);\n                }\n                return res.join(\";\");\n            },\n            deserializePoints: function(s) {\n                var v = s.split(\";\"), points = [];\n                if (v.length % 2 !== 0) {\n                    throw \"Not an array of points.\";\n                }\n                for (var i = 0; i < v.length; i += 2) {\n                    points.push(new diagram.Point(\n                        parseInt(v[i], 10),\n                        parseInt(v[i + 1], 10)\n                    ));\n                }\n                return points;\n            },\n            /**\n             * Returns an integer within the given bounds.\n             * @param lower The inclusive lower bound.\n             * @param upper The exclusive upper bound.\n             * @returns {number}\n             */\n            randomInteger: function(lower, upper) {\n                return parseInt(Math.floor(Math.random() * upper) + lower, 10);\n            } ,\n            /*\n             Depth-first traversal of the given node.\n             */\n            DFT: function(el, func) {\n                func(el);\n                if (el.childNodes) {\n                    for (var i = 0; i < el.childNodes.length; i++) {\n                        var item = el.childNodes[i];\n                        this.DFT(item, func);\n                    }\n                }\n            },\n            /*\n             Returns the angle in degrees for the given matrix\n             */\n            getMatrixAngle: function(m) {\n                if (m === null || m.d === 0) {\n                    return 0;\n                }\n                return Math.atan2(m.b, m.d) * 180 / Math.PI;\n            },\n\n            /*\n             Returns the scaling factors for the given matrix.\n             */\n            getMatrixScaling: function(m) {\n                var sX = Math.sqrt(m.a * m.a + m.c * m.c);\n                var sY = Math.sqrt(m.b * m.b + m.d * m.d);\n                return [sX, sY];\n            }\n\n        });\n\n        /**\n         * The Range defines an array of equally separated numbers.\n         * @param start The start-value of the Range.\n         * @param stop The end-value of the Range.\n         * @param step The separation between the values (default:1).\n         * @returns {Array}\n         */\n        function Range(start, stop, step) {\n            if (typeof start == 'undefined' || typeof stop == 'undefined') {\n                return [];\n            }\n            if (step && Utils.sign(stop - start) != Utils.sign(step)) {\n                throw \"The sign of the increment should allow to reach the stop-value.\";\n            }\n            step = step || 1;\n            start = start || 0;\n            stop = stop || start;\n            if ((stop - start) / step === Infinity) {\n                throw \"Infinite range defined.\";\n            }\n            var range = [], i = -1, j;\n\n            function rangeIntegerScale(x) {\n                var k = 1;\n                while (x * k % 1) {\n                    k *= 10;\n                }\n                return k;\n            }\n\n            var k = rangeIntegerScale(Math.abs(step));\n            start *= k;\n            stop *= k;\n            step *= k;\n            if (start > stop && step > 0) {\n                step = -step;\n            }\n            if (step < 0) {\n                while ((j = start + step * ++i) >= stop) {\n                    range.push(j / k);\n                }\n            }\n            else {\n                while ((j = start + step * ++i) <= stop) {\n                    range.push(j / k);\n                }\n            }\n            return range;\n        }\n\n        /*-------------------Diverse math functions----------------------------*/\n\n        function findRadian(start, end) {\n            if (start == end) {\n                return 0;\n            }\n            var sngXComp = end.x - start.x,\n                sngYComp = start.y - end.y,\n                atan = Math.atan(sngXComp / sngYComp);\n            if (sngYComp >= 0) {\n                return sngXComp < 0 ? atan + (2 * Math.PI) : atan;\n            }\n            return atan + Math.PI;\n        }\n\n        Utils.sign = function(number) {\n            return number ? number < 0 ? -1 : 1 : 0;\n        };\n\n        Utils.findAngle = function(center, end) {\n            return findRadian(center, end) * 180 / Math.PI;\n        };\n\n        /*-------------------Array Helpers ----------------------------*/\n\n        Utils.forEach = function(arr, iterator, thisRef) {\n            for (var i = 0; i < arr.length; i++) {\n                iterator.call(thisRef, arr[i], i, arr);\n            }\n        };\n\n        Utils.any = function(arr, predicate) {\n            for (var i = 0; i < arr.length; ++i) {\n                if (predicate(arr[i])) {\n                    return arr[i];\n                }\n            }\n            return null;\n        };\n\n        Utils.remove = function(arr, what) {\n            var ax;\n            while ((ax = Utils.indexOf(arr, what)) !== -1) {\n                arr.splice(ax, 1);\n            }\n            return arr;\n        };\n\n        Utils.contains = function(arr, obj) {\n            return Utils.indexOf(arr, obj) !== -1;\n        };\n\n        Utils.indexOf = function(arr, what) {\n            return $.inArray(what, arr);\n        };\n\n        Utils.fold = function(list, iterator, acc, context) {\n            var initial = arguments.length > 2;\n\n            for (var i = 0; i < list.length; i++) {\n                var value = list[i];\n                if (!initial) {\n                    acc = value;\n                    initial = true;\n                }\n                else {\n                    acc = iterator.call(context, acc, value, i, list);\n                }\n            }\n\n            if (!initial) {\n                throw 'Reduce of empty array with no initial value';\n            }\n\n            return acc;\n        };\n\n        Utils.find = function(arr, iterator, context) {\n            var result;\n            Utils.any(arr, function(value, index, list) {\n                if (iterator.call(context, value, index, list)) {\n                    result = value;\n                    return true;\n                }\n                return false;\n            });\n            return result;\n        };\n\n        Utils.first = function(arr, constraint, context) {\n            if (arr.length === 0) {\n                return null;\n            }\n            if (Utils.isUndefined(constraint)) {\n                return arr[0];\n            }\n\n            return Utils.find(arr, constraint, context);\n        };\n\n        /**\n         * Inserts the given element at the specified position and returns the result.\n         */\n        Utils.insert = function(arr, element, position) {\n            arr.splice(position, 0, element);\n            return arr;\n        };\n\n        Utils.all = function(arr, iterator, context) {\n            var result = true;\n            var value;\n\n            for (var i = 0; i < arr.length; i++) {\n                value = arr[i];\n                result = result && iterator.call(context, value, i, arr);\n\n                if (!result) {\n                    break;\n                }\n            }\n\n            return result;\n        };\n\n        Utils.clear = function(arr) {\n            arr.splice(0, arr.length);\n        };\n\n        /**\n         * Sort the arrays on the basis of the first one (considered as keys and the other array as values).\n         * @param a\n         * @param b\n         * @param sortfunc (optiona) sorting function for the values in the first array\n         */\n        Utils.bisort = function(a, b, sortfunc) {\n            if (Utils.isUndefined(a)) {\n                throw \"First array is not specified.\";\n            }\n            if (Utils.isUndefined(b)) {\n                throw \"Second array is not specified.\";\n            }\n            if (a.length != b.length) {\n                throw \"The two arrays should have equal length\";\n            }\n\n            var all = [], i;\n\n            for (i = 0; i < a.length; i++) {\n                all.push({ 'x': a[i], 'y': b[i] });\n            }\n            if (Utils.isUndefined(sortfunc)) {\n                all.sort(function(m, n) {\n                    return m.x - n.x;\n                });\n            }\n            else {\n                all.sort(function(m, n) {\n                    return sortfunc(m.x, n.x);\n                });\n            }\n\n            Utils.clear(a);\n            Utils.clear(b);\n\n            for (i = 0; i < all.length; i++) {\n                a.push(all[i].x);\n                b.push(all[i].y);\n            }\n        };\n\n        Utils.addRange = function(arr, range) {\n            arr.push.apply(arr, range);\n        };\n\n        var Easing = {\n            easeInOut: function(pos) {\n                return ((-Math.cos(pos * Math.PI) / 2) + 0.5);\n            }\n        };\n\n        /**\n         * An animation ticker driving an adapter which sets a particular\n         * property in function of the tick.\n         * @type {*}\n         */\n        var Ticker = kendo.Class.extend({\n            init: function() {\n                this.adapters = [];\n                this.target = 0;\n                this.tick = 0;\n                this.interval = 20;\n                this.duration = 800;\n                this.lastTime = null;\n                this.handlers = [];\n                var _this = this;\n                this.transition = Easing.easeInOut;\n                this.timerDelegate = function() {\n                    _this.onTimerEvent();\n                };\n            },\n            addAdapter: function(a) {\n                this.adapters.push(a);\n            },\n            onComplete: function(handler) {\n                this.handlers.push(handler);\n            },\n            removeHandler: function(handler) {\n                this.handlers = $.grep(this.handlers, function(h) {\n                    return h !== handler;\n                });\n            },\n            trigger: function() {\n                var _this = this;\n                if (this.handlers) {\n                    Utils.forEach(this.handlers, function(h) {\n                        return h.call(_this.caller !== null ? _this.caller : _this);\n                    });\n                }\n            },\n            onStep: function() {\n            },\n            seekTo: function(to) {\n                this.seekFromTo(this.tick, to);\n            },\n            seekFromTo: function(from, to) {\n                this.target = Math.max(0, Math.min(1, to));\n                this.tick = Math.max(0, Math.min(1, from));\n                this.lastTime = new Date().getTime();\n                if (!this.intervalId) {\n                    this.intervalId = window.setInterval(this.timerDelegate, this.interval);\n                }\n            },\n            stop: function() {\n                if (this.intervalId) {\n                    window.clearInterval(this.intervalId);\n                    this.intervalId = null;\n\n                    //this.trigger.call(this);\n                    this.trigger();\n                    // this.next();\n                }\n            },\n            play: function(origin) {\n                if (this.adapters.length === 0) {\n                    return;\n                }\n                if (origin !== null) {\n                    this.caller = origin;\n                }\n                this.initState();\n                this.seekFromTo(0, 1);\n            },\n            reverse: function() {\n                this.seekFromTo(1, 0);\n            },\n            initState: function() {\n                if (this.adapters.length === 0) {\n                    return;\n                }\n                for (var i = 0; i < this.adapters.length; i++) {\n                    this.adapters[i].initState();\n                }\n            },\n            propagate: function() {\n                var value = this.transition(this.tick);\n\n                for (var i = 0; i < this.adapters.length; i++) {\n                    this.adapters[i].update(value);\n                }\n            },\n            onTimerEvent: function() {\n                var now = new Date().getTime();\n                var timePassed = now - this.lastTime;\n                this.lastTime = now;\n                var movement = (timePassed / this.duration) * (this.tick < this.target ? 1 : -1);\n                if (Math.abs(movement) >= Math.abs(this.tick - this.target)) {\n                    this.tick = this.target;\n                } else {\n                    this.tick += movement;\n                }\n\n                try {\n                    this.propagate();\n                } finally {\n                    this.onStep.call(this);\n                    if (this.target == this.tick) {\n                        this.stop();\n                    }\n                }\n            }\n        });\n\n        kendo.deepExtend(diagram, {\n            init: function(element) {\n                kendo.init(element, diagram.ui);\n            },\n\n            Utils: Utils,\n            Range: Range,\n            Ticker: Ticker\n        });\n    })(window.kendo.jQuery);\n\n    (function($, undefined$1) {\n        // Imports ================================================================\n        var kendo = window.kendo,\n            diagram = kendo.dataviz.diagram,\n            Class = kendo.Class,\n            deepExtend = kendo.deepExtend,\n            Utils = diagram.Utils,\n            Point = kendo.geometry.Point,\n            isFunction = kendo.isFunction,\n            contains = Utils.contains,\n            map = $.map;\n\n        // Constants ==============================================================\n        var HITTESTAREA = 3,\n            EPSILON = 1e-06;\n\n        class ExtendedPoint extends Point {\n            constructor(x, y) {\n                super(x, y);\n            }\n\n            clone() {\n                return new ExtendedPoint(this.x, this.y);\n            }\n\n            plus(p) {\n                return new ExtendedPoint(this.x + p.x, this.y + p.y);\n            }\n\n            minus(p) {\n                return new ExtendedPoint(this.x - p.x, this.y - p.y);\n            }\n\n            offset(value) {\n                return new ExtendedPoint(this.x - value, this.y - value);\n            }\n\n            times(s) {\n                return new ExtendedPoint(this.x * s, this.y * s);\n            }\n\n            normalize() {\n                if (this.length() === 0) {\n                    return new ExtendedPoint();\n                }\n                return this.times(1 / this.length());\n            }\n\n            length() {\n                return Math.sqrt(this.x * this.x + this.y * this.y);\n            }\n\n            toString() {\n                return \"(\" + this.x + \",\" + this.y + \")\";\n            }\n\n            lengthSquared() {\n                return (this.x * this.x + this.y * this.y);\n            }\n\n            middleOf(p, q) {\n                return new ExtendedPoint(q.x - p.x, q.y - p.y).times(0.5).plus(p);\n            }\n\n            toPolar(useDegrees) {\n                var factor = 1;\n                if (useDegrees) {\n                    factor = 180 / Math.PI;\n                }\n                var a = Math.atan2(Math.abs(this.y), Math.abs(this.x));\n                var halfpi = Math.PI / 2;\n                var len = this.length();\n                if (this.x === 0) {\n                    // note that the angle goes down and not the usual mathematical convention\n\n                    if (this.y === 0) {\n                        return new Polar(0, 0);\n                    }\n                    if (this.y > 0) {\n                        return new Polar(len, factor * halfpi);\n                    }\n                    if (this.y < 0) {\n                        return new Polar(len, factor * 3 * halfpi);\n                    }\n                }\n                else if (this.x > 0) {\n                    if (this.y === 0) {\n                        return new Polar(len, 0);\n                    }\n                    if (this.y > 0) {\n                        return new Polar(len, factor * a);\n                    }\n                    if (this.y < 0) {\n                        return new Polar(len, factor * (4 * halfpi - a));\n                    }\n                }\n                else {\n                    if (this.y === 0) {\n                        return new Polar(len, 2 * halfpi);\n                    }\n                    if (this.y > 0) {\n                        return new Polar(len, factor * (2 * halfpi - a));\n                    }\n                    if (this.y < 0) {\n                        return new Polar(len, factor * (2 * halfpi + a));\n                    }\n                }\n            }\n            isOnLine(from, to) {\n                if (from.x > to.x) { // from must be the leftmost point\n                    var temp = to;\n                    to = from;\n                    from = temp;\n                }\n                var r1 = new Rect(from.x, from.y).inflate(HITTESTAREA, HITTESTAREA),\n                    r2 = new Rect(to.x, to.y).inflate(HITTESTAREA, HITTESTAREA), o1, u1;\n                if (r1.union(r2).contains(this)) {\n                    if (from.x === to.x || from.y === to.y) {\n                        return true;\n                    }\n                    else if (from.y < to.y) {\n                        o1 = r1.x + (((r2.x - r1.x) * (this.y - (r1.y + r1.height))) / ((r2.y + r2.height) - (r1.y + r1.height)));\n                        u1 = (r1.x + r1.width) + ((((r2.x + r2.width) - (r1.x + r1.width)) * (this.y - r1.y)) / (r2.y - r1.y));\n                    }\n                    else {\n                        o1 = r1.x + (((r2.x - r1.x) * (this.y - r1.y)) / (r2.y - r1.y));\n                        u1 = (r1.x + r1.width) + ((((r2.x + r2.width) - (r1.x + r1.width)) * (this.y - (r1.y + r1.height))) / ((r2.y + r2.height) - (r1.y + r1.height)));\n                    }\n                    return (this.x > o1 && this.x < u1);\n                }\n                return false;\n            }\n            parse(str) {\n                var tempStr = str.slice(1, str.length - 1),\n                    xy = tempStr.split(\",\"),\n                    x = parseInt(xy[0], 10),\n                    y = parseInt(xy[1], 10);\n                if (!isNaN(x) && !isNaN(y)) {\n                    return new ExtendedPoint(x, y);\n                }\n            }\n        }\n\n        /**\n         * Structure combining a Point with two additional points representing the handles or tangents attached to the first point.\n         * If the additional points are null or equal to the first point the path will be sharp.\n         * Left and right correspond to the direction of the underlying path.\n         */\n        var PathDefiner = Class.extend(\n            {\n                init: function(p, left, right) {\n                    this.point = p;\n                    this.left = left;\n                    this.right = right;\n                }\n            }\n        );\n\n        /**\n         * Defines a rectangular region.\n         */\n        var Rect = Class.extend({\n            init: function(x, y, width, height) {\n                this.x = x || 0;\n                this.y = y || 0;\n                this.width = width || 0;\n                this.height = height || 0;\n            },\n            contains: function(point) {\n                return ((point.x >= this.x) && (point.x <= (this.x + this.width)) && (point.y >= this.y) && (point.y <= (this.y + this.height)));\n            },\n            inflate: function(dx, dy) {\n                if (dy === undefined$1) {\n                    dy = dx;\n                }\n\n                this.x -= dx;\n                this.y -= dy;\n                this.width += 2 * dx + 1;\n                this.height += 2 * dy + 1;\n                return this;\n            },\n            offset: function(dx, dy) {\n                var x = dx, y = dy;\n                if (dx instanceof ExtendedPoint) {\n                    x = dx.x;\n                    y = dx.y;\n                }\n                this.x += x;\n                this.y += y;\n                return this;\n            },\n            union: function(r) {\n                var x1 = Math.min(this.x, r.x);\n                var y1 = Math.min(this.y, r.y);\n                var x2 = Math.max((this.x + this.width), (r.x + r.width));\n                var y2 = Math.max((this.y + this.height), (r.y + r.height));\n                return new Rect(x1, y1, x2 - x1, y2 - y1);\n            },\n            center: function() {\n                return new ExtendedPoint(this.x + this.width / 2, this.y + this.height / 2);\n            },\n            top: function() {\n                return new ExtendedPoint(this.x + this.width / 2, this.y);\n            },\n            right: function() {\n                return new ExtendedPoint(this.x + this.width, this.y + this.height / 2);\n            },\n            bottom: function() {\n                return new ExtendedPoint(this.x + this.width / 2, this.y + this.height);\n            },\n            left: function() {\n                return new ExtendedPoint(this.x, this.y + this.height / 2);\n            },\n            topLeft: function() {\n                return new ExtendedPoint(this.x, this.y);\n            },\n            topRight: function() {\n                return new ExtendedPoint(this.x + this.width, this.y);\n            },\n            bottomLeft: function() {\n                return new ExtendedPoint(this.x, this.y + this.height);\n            },\n            bottomRight: function() {\n                return new ExtendedPoint(this.x + this.width, this.y + this.height);\n            },\n            clone: function() {\n                return new Rect(this.x, this.y, this.width, this.height);\n            },\n            isEmpty: function() {\n                return !this.width && !this.height;\n            },\n            equals: function(rect) {\n                return this.x === rect.x && this.y === rect.y && this.width === rect.width && this.height === rect.height;\n            },\n            rotatedBounds: function(angle) {\n                var rect = this.clone(),\n                    points = this.rotatedPoints(angle),\n                    tl = points[0],\n                    tr = points[1],\n                    br = points[2],\n                    bl = points[3];\n\n                rect.x = Math.min(br.x, tl.x, tr.x, bl.x);\n                rect.y = Math.min(br.y, tl.y, tr.y, bl.y);\n                rect.width = Math.max(br.x, tl.x, tr.x, bl.x) - rect.x;\n                rect.height = Math.max(br.y, tl.y, tr.y, bl.y) - rect.y;\n\n                return rect;\n            },\n            rotatedPoints: function(angle) {\n                var rect = this,\n                    c = rect.center(),\n                    br = rect.bottomRight().rotate(angle, c),\n                    tl = rect.topLeft().rotate(angle, c),\n                    tr = rect.topRight().rotate(angle, c),\n                    bl = rect.bottomLeft().rotate(angle, c);\n\n                return [tl, tr, br, bl];\n            },\n            toString: function(delimiter) {\n                delimiter = delimiter || \" \";\n\n                return this.x + delimiter + this.y + delimiter + this.width + delimiter + this.height;\n            },\n            scale: function(scaleX, scaleY, staicPoint, adornerCenter, angle) {\n                var tl = this.topLeft();\n                var thisCenter = this.center();\n                tl.rotate(angle, thisCenter).rotate(angle, adornerCenter);\n\n                var delta = staicPoint.minus(tl);\n                var scaled = new ExtendedPoint(delta.x * scaleX, delta.y * scaleY);\n                var position = delta.minus(scaled);\n                tl = tl.plus(position);\n                tl.rotate(angle, adornerCenter).rotate(angle, thisCenter);\n\n                this.x = tl.x;\n                this.y = tl.y;\n\n                this.width *= scaleX;\n                this.height *= scaleY;\n            },\n\n            zoom: function(zoom) {\n                this.x *= zoom;\n                this.y *= zoom;\n                this.width *= zoom;\n                this.height *= zoom;\n                return this;\n            },\n\n            overlaps: function(rect) {\n                var bottomRight = this.bottomRight();\n                var rectBottomRight = rect.bottomRight();\n                var overlaps = !(bottomRight.x < rect.x || bottomRight.y < rect.y ||\n                    rectBottomRight.x < this.x || rectBottomRight.y < this.y);\n                return overlaps;\n            }\n        });\n\n        var Size = Class.extend({\n            init: function(width, height) {\n                this.width = width;\n                this.height = height;\n            }\n        });\n\n        Size.prototype.Empty = new Size(0, 0);\n\n        Rect.toRect = function(rect) {\n            if (!(rect instanceof Rect)) {\n                rect = new Rect(rect.x, rect.y, rect.width, rect.height);\n            }\n\n            return rect;\n        };\n\n        Rect.empty = function() {\n            return new Rect(0, 0, 0, 0);\n        };\n\n        Rect.fromPoints = function(p, q) {\n            if (isNaN(p.x) || isNaN(p.y) || isNaN(q.x) || isNaN(q.y)) {\n                throw \"Some values are NaN.\";\n            }\n            return new Rect(Math.min(p.x, q.x), Math.min(p.y, q.y), Math.abs(p.x - q.x), Math.abs(p.y - q.y));\n        };\n\n        function isNearZero(num) {\n            return Math.abs(num) < EPSILON;\n        }\n\n        function intersectLine(start1, end1, start2, end2, isSegment) {\n            var tangensdiff = ((end1.x - start1.x) * (end2.y - start2.y)) - ((end1.y - start1.y) * (end2.x - start2.x));\n            if (isNearZero(tangensdiff)) {\n                //parallel lines\n                return;\n            }\n\n            var num1 = ((start1.y - start2.y) * (end2.x - start2.x)) - ((start1.x - start2.x) * (end2.y - start2.y));\n            var num2 = ((start1.y - start2.y) * (end1.x - start1.x)) - ((start1.x - start2.x) * (end1.y - start1.y));\n            var r = num1 / tangensdiff;\n            var s = num2 / tangensdiff;\n\n            if (isSegment && (r < 0 || r > 1 || s < 0 || s > 1)) {\n                //r < 0 => line 1 is below line 2\n                //r > 1 => line 1 is above line 2\n                //s < 0 => line 2 is below line 1\n                //s > 1 => line 2 is above line 1\n                return;\n            }\n\n            return new ExtendedPoint(start1.x + (r * (end1.x - start1.x)), start1.y + (r * (end1.y - start1.y)));\n        }\n\n        var Intersect = {\n            lines: function(start1, end1, start2, end2) {\n                return intersectLine(start1, end1, start2, end2);\n            },\n            segments: function(start1, end1, start2, end2) {\n                return intersectLine(start1, end1, start2, end2, true);\n            },\n            rectWithLine: function(rect, start, end) {\n                return Intersect.segments(start, end, rect.topLeft(), rect.topRight()) ||\n                    Intersect.segments(start, end, rect.topRight(), rect.bottomRight()) ||\n                    Intersect.segments(start, end, rect.bottomLeft(), rect.bottomRight()) ||\n                    Intersect.segments(start, end, rect.topLeft(), rect.bottomLeft());\n            },\n            rects: function(rect1, rect2, angle) {\n                var tl = rect2.topLeft(),\n                    tr = rect2.topRight(),\n                    bl = rect2.bottomLeft(),\n                    br = rect2.bottomRight();\n                var center = rect2.center();\n                if (angle) {\n                    tl = tl.rotate(angle, center);\n                    tr = tr.rotate(angle, center);\n                    bl = bl.rotate(angle, center);\n                    br = br.rotate(angle, center);\n                }\n\n                var intersect = rect1.contains(tl) ||\n                    rect1.contains(tr) ||\n                    rect1.contains(bl) ||\n                    rect1.contains(br) ||\n                    Intersect.rectWithLine(rect1, tl, tr) ||\n                    Intersect.rectWithLine(rect1, tl, bl) ||\n                    Intersect.rectWithLine(rect1, tr, br) ||\n                    Intersect.rectWithLine(rect1, bl, br);\n\n                if (!intersect) {//last possible case is rect1 to be completely within rect2\n                    tl = rect1.topLeft();\n                    tr = rect1.topRight();\n                    bl = rect1.bottomLeft();\n                    br = rect1.bottomRight();\n\n                    if (angle) {\n                        var reverseAngle = 360 - angle;\n                        tl = tl.rotate(reverseAngle, center);\n                        tr = tr.rotate(reverseAngle, center);\n                        bl = bl.rotate(reverseAngle, center);\n                        br = br.rotate(reverseAngle, center);\n                    }\n\n                    intersect = rect2.contains(tl) ||\n                        rect2.contains(tr) ||\n                        rect2.contains(bl) ||\n                        rect2.contains(br);\n                }\n\n                return intersect;\n            }\n        };\n\n        /**\n         * Aligns two rectangles, where one is the container and the other is content.\n         */\n        var RectAlign = Class.extend({\n            init: function(container) {\n                this.container = Rect.toRect(container);\n            },\n\n            align: function(content, alignment) {\n                var alignValues = alignment.toLowerCase().split(\" \");\n\n                for (var i = 0; i < alignValues.length; i++) {\n                    content = this._singleAlign(content, alignValues[i]);\n                }\n\n                return content;\n            },\n            _singleAlign: function(content, alignment) {\n                if (isFunction(this[alignment])) {\n                    return this[alignment](content);\n                }\n                else {\n                    return content;\n                }\n            },\n\n            left: function(content) {\n                return this._align(content, this._left);\n            },\n            center: function(content) {\n                return this._align(content, this._center);\n            },\n            right: function(content) {\n                return this._align(content, this._right);\n            },\n            stretch: function(content) {\n                return this._align(content, this._stretch);\n            },\n            top: function(content) {\n                return this._align(content, this._top);\n            },\n            middle: function(content) {\n                return this._align(content, this._middle);\n            },\n            bottom: function(content) {\n                return this._align(content, this._bottom);\n            },\n\n            _left: function(container, content) {\n                content.x = container.x;\n            },\n            _center: function(container, content) {\n                content.x = ((container.width - content.width) / 2) || 0;\n            },\n            _right: function(container, content) {\n                content.x = container.width - content.width;\n            },\n            _top: function(container, content) {\n                content.y = container.y;\n            },\n            _middle: function(container, content) {\n                content.y = ((container.height - content.height) / 2) || 0;\n            },\n            _bottom: function(container, content) {\n                content.y = container.height - content.height;\n            },\n            _stretch: function(container, content) {\n                content.x = 0;\n                content.y = 0;\n                content.height = container.height;\n                content.width = container.width;\n            },\n            _align: function(content, alignCalc) {\n                content = Rect.toRect(content);\n                alignCalc(this.container, content);\n\n                return content;\n            }\n        });\n\n        var Polar = Class.extend({\n            init: function(r, a) {\n                this.r = r;\n                this.angle = a;\n            }\n        });\n\n        /**\n         * SVG transformation matrix.\n         */\n        var Matrix = Class.extend({\n            init: function(a, b, c, d, e, f) {\n                this.a = a || 0;\n                this.b = b || 0;\n                this.c = c || 0;\n                this.d = d || 0;\n                this.e = e || 0;\n                this.f = f || 0;\n            },\n            plus: function(m) {\n                this.a += m.a;\n                this.b += m.b;\n                this.c += m.c;\n                this.d += m.d;\n                this.e += m.e;\n                this.f += m.f;\n            },\n            minus: function(m) {\n                this.a -= m.a;\n                this.b -= m.b;\n                this.c -= m.c;\n                this.d -= m.d;\n                this.e -= m.e;\n                this.f -= m.f;\n            },\n            times: function(m) {\n                return new Matrix(\n                    this.a * m.a + this.c * m.b,\n                    this.b * m.a + this.d * m.b,\n                    this.a * m.c + this.c * m.d,\n                    this.b * m.c + this.d * m.d,\n                    this.a * m.e + this.c * m.f + this.e,\n                    this.b * m.e + this.d * m.f + this.f\n                );\n            },\n            apply: function(p) {\n                return new ExtendedPoint(this.a * p.x + this.c * p.y + this.e, this.b * p.x + this.d * p.y + this.f);\n            },\n            applyRect: function(r) {\n                return Rect.fromPoints(this.apply(r.topLeft()), this.apply(r.bottomRight()));\n            },\n            toString: function() {\n                return \"matrix(\" + this.a + \" \" + this.b + \" \" + this.c + \" \" + this.d + \" \" + this.e + \" \" + this.f + \")\";\n            }\n        });\n\n        deepExtend(Matrix, {\n            fromSVGMatrix: function(vm) {\n                var m = new Matrix();\n                m.a = vm.a;\n                m.b = vm.b;\n                m.c = vm.c;\n                m.d = vm.d;\n                m.e = vm.e;\n                m.f = vm.f;\n                return m;\n            },\n            fromMatrixVector: function(v) {\n                var m = new Matrix();\n                m.a = v.a;\n                m.b = v.b;\n                m.c = v.c;\n                m.d = v.d;\n                m.e = v.e;\n                m.f = v.f;\n                return m;\n            },\n            fromList: function(v) {\n                if (v.length !== 6) {\n                    throw \"The given list should consist of six elements.\";\n                }\n                var m = new Matrix();\n                m.a = v[0];\n                m.b = v[1];\n                m.c = v[2];\n                m.d = v[3];\n                m.e = v[4];\n                m.f = v[5];\n                return m;\n            },\n            translation: function(x, y) {\n                var m = new Matrix();\n                m.a = 1;\n                m.b = 0;\n                m.c = 0;\n                m.d = 1;\n                m.e = x;\n                m.f = y;\n                return m;\n            },\n            unit: function() {\n                return new Matrix(1, 0, 0, 1, 0, 0);\n            },\n            rotation: function(angle, x, y) {\n                var m = new Matrix();\n                m.a = Math.cos(angle * Math.PI / 180);\n                m.b = Math.sin(angle * Math.PI / 180);\n                m.c = -m.b;\n                m.d = m.a;\n                m.e = (x - x * m.a + y * m.b) || 0;\n                m.f = (y - y * m.a - x * m.b) || 0;\n                return m;\n            },\n            scaling: function(scaleX, scaleY) {\n                var m = new Matrix();\n                m.a = scaleX;\n                m.b = 0;\n                m.c = 0;\n                m.d = scaleY;\n                m.e = 0;\n                m.f = 0;\n                return m;\n            },\n            parse: function(v) {\n                var parts, nums;\n                if (v) {\n                    v = v.trim();\n                    // of the form \"matrix(...)\"\n                    if (v.slice(0, 6).toLowerCase() === \"matrix\") {\n                        nums = v.slice(7, v.length - 1).trim();\n                        parts = nums.split(\",\");\n                        if (parts.length === 6) {\n                            return Matrix.fromList(map(parts, function(p) {\n                                return parseFloat(p);\n                            }));\n                        }\n                        parts = nums.split(\" \");\n                        if (parts.length === 6) {\n                            return Matrix.fromList(map(parts, function(p) {\n                                return parseFloat(p);\n                            }));\n                        }\n                    }\n                    // of the form \"(...)\"\n                    if (v.slice(0, 1) === \"(\" && v.slice(v.length - 1) === \")\") {\n                        v = v.substr(1, v.length - 1);\n                    }\n                    if (v.indexOf(\",\") > 0) {\n                        parts = v.split(\",\");\n                        if (parts.length === 6) {\n                            return Matrix.fromList(map(parts, function(p) {\n                                return parseFloat(p);\n                            }));\n                        }\n                    }\n                    if (v.indexOf(\" \") > 0) {\n                        parts = v.split(\" \");\n                        if (parts.length === 6) {\n                            return Matrix.fromList(map(parts, function(p) {\n                                return parseFloat(p);\n                            }));\n                        }\n                    }\n                }\n                return parts;\n            }\n        });\n\n        /**\n         * SVG transformation represented as a vector.\n         */\n        var MatrixVector = Class.extend({\n            init: function(a, b, c, d, e, f) {\n                this.a = a || 0;\n                this.b = b || 0;\n                this.c = c || 0;\n                this.d = d || 0;\n                this.e = e || 0;\n                this.f = f || 0;\n            },\n            fromMatrix: function FromMatrix(m) {\n                var v = new MatrixVector();\n                v.a = m.a;\n                v.b = m.b;\n                v.c = m.c;\n                v.d = m.d;\n                v.e = m.e;\n                v.f = m.f;\n                return v;\n            }\n        });\n\n        /**\n         * Returns a value with Gaussian (normal) distribution.\n         * @param mean The mean value of the distribution.\n         * @param deviation The deviation (spreading at half-height) of the distribution.\n         * @returns {number}\n         */\n        function normalVariable(mean, deviation) {\n            var x, y, r;\n            do {\n                x = Math.random() * 2 - 1;\n                y = Math.random() * 2 - 1;\n                r = x * x + y * y;\n            }\n            while (!r || r > 1);\n            return mean + deviation * x * Math.sqrt(-2 * Math.log(r) / r);\n        }\n\n        /**\n         * Returns a random identifier which can be used as an ID of objects, eventually augmented with a prefix.\n         * @returns {string}\n         */\n        function randomId(length) {\n            if (Utils.isUndefined(length)) {\n                length = 10;\n            }\n            // old version return Math.floor((1 + Math.random()) * 0x1000000).toString(16).substring(1);\n            var result = '';\n            var chars = '0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ';\n            for (var i = length; i > 0; --i) {\n                result += chars.charAt(Math.round(Math.random() * (chars.length - 1)));\n            }\n            return result;\n        }\n\n        var Geometry = {\n\n            /**\n             * Returns the squared distance to the line defined by the two given Points.\n             * @param p An arbitrary Point.\n             * @param a An endpoint of the line or segment.\n             * @param b The complementary endpoint of the line or segment.\n             */\n            _distanceToLineSquared: function(p, a, b) {\n                function d2(pt1, pt2) {\n                    return (pt1.x - pt2.x) * (pt1.x - pt2.x) + (pt1.y - pt2.y) * (pt1.y - pt2.y);\n                }\n\n                if (a === b) { // returns the distance of p to a\n                    return d2(p, a);\n                }\n\n                var vx = b.x - a.x,\n                    vy = b.y - a.y,\n                    dot = (p.x - a.x) * vx + (p.y - a.y) * vy;\n                if (dot < 0) {\n                    return d2(a, p); // sits on side of a\n                }\n\n                dot = (b.x - p.x) * vx + (b.y - p.y) * vy;\n                if (dot < 0) {\n                    return d2(b, p); // sits on side of b\n                }\n                // regular case, use crossproduct to get the sine out\n                dot = (b.x - p.x) * vy - (b.y - p.y) * vx;\n                return dot * dot / (vx * vx + vy * vy);\n            },\n\n            /**\n             * Returns the distance to the line defined by the two given Points.\n             * @param p An arbitrary Point.\n             * @param a An endpoint of the line or segment.\n             * @param b The complementary endpoint of the line or segment.\n             */\n            distanceToLine: function(p, a, b) {\n                return Math.sqrt(this._distanceToLineSquared(p, a, b));\n            },\n\n            /**\n             * Returns the distance of the given points to the polyline defined by the points.\n             * @param p An arbitrary point.\n             * @param points The points defining the polyline.\n             * @returns {Number}\n             */\n            distanceToPolyline: function(p, points) {\n                var minimum = Number.MAX_VALUE;\n                if (Utils.isUndefined(points) || points.length === 0) {\n                    return Number.MAX_VALUE;\n                }\n                for (var s = 0; s < points.length - 1; s++) {\n                    var p1 = points[s];\n                    var p2 = points[s + 1];\n\n                    var d = this._distanceToLineSquared(p, p1, p2);\n                    if (d < minimum) {\n                        minimum = d;\n                    }\n                }\n                return Math.sqrt(minimum);\n            }\n        };\n\n        /*---------------The HashTable structure--------------------------------*/\n\n        /**\n         * Represents a collection of key-value pairs that are organized based on the hash code of the key.\n         * _buckets[hashId] = {key: key, value:...}\n         * Important: do not use the standard Array access method, use the get/set methods instead.\n         * See http://en.wikipedia.org/wiki/Hash_table\n         */\n        var HashTable = kendo.Class.extend({\n            init: function() {\n                this._buckets = [];\n                this.length = 0;\n            },\n\n            /**\n             * Adds the literal object with the given key (of the form {key: key,....}).\n             */\n            add: function(key, value) {\n\n                var obj = this._createGetBucket(key);\n                if (Utils.isDefined(value)) {\n                    obj.value = value;\n                }\n                return obj;\n            },\n\n            /**\n             * Gets the literal object with the given key.\n             */\n            get: function(key) {\n                if (this._bucketExists(key)) {\n                    return this._createGetBucket(key);\n                }\n                return null;\n            },\n\n            /**\n             * Set the key-value pair.\n             * @param key The key of the entry.\n             * @param value The value to set. If the key already exists the value will be overwritten.\n             */\n            set: function(key, value) {\n                this.add(key, value);\n            },\n\n            /**\n             * Determines whether the HashTable contains a specific key.\n             */\n            containsKey: function(key) {\n                return this._bucketExists(key);\n            },\n\n            /**\n             * Removes the element with the specified key from the hashtable.\n             * Returns the removed bucket.\n             */\n            remove: function(key) {\n                if (this._bucketExists(key)) {\n                    var hashId = this._hash(key);\n                    delete this._buckets[hashId];\n                    this.length--;\n                    return key;\n                }\n            },\n\n            /**\n             * Foreach with an iterator working on the key-value pairs.\n             * @param func\n             */\n            forEach: function(func) {\n                var hashes = this._hashes();\n                for (var i = 0, len = hashes.length; i < len; i++) {\n                    var hash = hashes[i];\n                    var bucket = this._buckets[hash];\n                    if (Utils.isUndefined(bucket)) {\n                        continue;\n                    }\n                    func(bucket);\n                }\n            },\n\n            /**\n             * Returns a (shallow) clone of the current HashTable.\n             * @returns {HashTable}\n             */\n            clone: function() {\n                var ht = new HashTable();\n                var hashes = this._hashes();\n                for (var i = 0, len = hashes.length; i < len; i++) {\n                    var hash = hashes[i];\n                    var bucket = this._buckets[hash];\n                    if (Utils.isUndefined(bucket)) {\n                        continue;\n                    }\n                    ht.add(bucket.key, bucket.value);\n                }\n                return ht;\n            },\n\n            /**\n             * Returns the hashes of the buckets.\n             * @returns {Array}\n             * @private\n             */\n            _hashes: function() {\n                var hashes = [];\n                for (var hash in this._buckets) {\n                    if (this._buckets.hasOwnProperty(hash)) {\n                        hashes.push(hash);\n                    }\n                }\n                return hashes;\n            },\n\n            _bucketExists: function(key) {\n                var hashId = this._hash(key);\n                return Utils.isDefined(this._buckets[hashId]);\n            },\n\n            /**\n             * Returns-adds the createGetBucket with the given key. If not present it will\n             * be created and returned.\n             * A createGetBucket is a literal object of the form {key: key, ...}.\n             */\n            _createGetBucket: function(key) {\n                var hashId = this._hash(key);\n                var bucket = this._buckets[hashId];\n                if (Utils.isUndefined(bucket)) {\n                    bucket = { key: key };\n                    this._buckets[hashId] = bucket;\n                    this.length++;\n                }\n                return bucket;\n            },\n\n            /**\n             * Hashing of the given key.\n             */\n            _hash: function(key) {\n                if (Utils.isNumber(key)) {\n                    return key;\n                }\n                if (Utils.isString(key)) {\n                    return this._hashString(key);\n                }\n                if (Utils.isObject(key)) {\n                    return this._objectHashId(key);\n                }\n                throw \"Unsupported key type.\";\n            },\n\n            /**\n             * Hashing of a string.\n             */\n            _hashString: function(s) {\n                // see for example http://stackoverflow.com/questions/7616461/generate-a-hash-from-string-in-javascript-jquery\n                var result = 0;\n                if (s.length === 0) {\n                    return result;\n                }\n                for (var i = 0; i < s.length; i++) {\n                    var ch = s.charCodeAt(i);\n                    result = ((result * 32) - result) + ch;\n                }\n                return result;\n            },\n\n            /**\n             * Returns the unique identifier for an object. This is automatically assigned and add on the object.\n             */\n            _objectHashId: function(key) {\n                var id = key._hashId;\n                if (Utils.isUndefined(id)) {\n                    id = randomId();\n                    key._hashId = id;\n                }\n                return id;\n            }\n        });\n\n        /*---------------The Dictionary structure--------------------------------*/\n\n        /**\n         * Represents a collection of key-value pairs.\n         * Important: do not use the standard Array access method, use the get/Set methods instead.\n         */\n        var Dictionary = kendo.Observable.extend({\n            /**\n             * Initializes a new instance of the Dictionary class.\n             * @param dictionary Loads the content of the given dictionary into this new one.\n             */\n            init: function(dictionary) {\n                var that = this;\n                kendo.Observable.fn.init.call(that);\n                this._hashTable = new HashTable();\n                this.length = 0;\n                if (Utils.isDefined(dictionary)) {\n                    if (Array.isArray(dictionary)) {\n                        for (var i = 0; i < dictionary.length; i++) {\n                            this.add(dictionary[i]);\n                        }\n                    } else {\n                        dictionary.forEach(function(k, v) {\n                            this.add(k, v);\n                        }, this);\n                    }\n                }\n            },\n\n            /**\n             * Adds a key-value to the dictionary.\n             * If the key already exists this will assign the given value to the existing entry.\n             */\n            add: function(key, value) {\n                var entry = this._hashTable.get(key);\n                if (!entry) {\n                    entry = this._hashTable.add(key);\n                    this.length++;\n                    this.trigger('changed');\n                }\n                entry.value = value;\n            },\n\n            /**\n             * Set the key-value pair.\n             * @param key The key of the entry.\n             * @param value The value to set. If the key already exists the value will be overwritten.\n             */\n            set: function(key, value) {\n                this.add(key, value);\n            },\n\n            /**\n             * Gets the value associated with the given key in the dictionary.\n             */\n            get: function(key) {\n                var entry = this._hashTable.get(key);\n                if (entry) {\n                    return entry.value;\n                }\n                throw new Error(\"Cannot find key \" + key);\n            },\n\n            /**\n             * Returns whether the dictionary contains the given key.\n             */\n            containsKey: function(key) {\n                return this._hashTable.containsKey(key);\n            },\n\n            /**\n             * Removes the element with the specified key from the dictionary.\n             */\n            remove: function(key) {\n                if (this.containsKey(key)) {\n                    this.trigger(\"changed\");\n                    this.length--;\n                    return this._hashTable.remove(key);\n                }\n            },\n\n            /**\n             * The functional gets the key and value as parameters.\n             */\n            forEach: function(func, thisRef) {\n                this._hashTable.forEach(function(entry) {\n                    func.call(thisRef, entry.key, entry.value);\n                });\n            },\n\n            /**\n             * Same as forEach except that only the value is passed to the functional.\n             */\n            forEachValue: function(func, thisRef) {\n                this._hashTable.forEach(function(entry) {\n                    func.call(thisRef, entry.value);\n                });\n            },\n\n            /**\n             * Calls a defined callback function for each key in the dictionary.\n             */\n            forEachKey: function(func, thisRef) {\n                this._hashTable.forEach(function(entry) {\n                    func.call(thisRef, entry.key);\n                });\n            },\n\n            /**\n             * Gets an array with all keys in the dictionary.\n             */\n            keys: function() {\n                var keys = [];\n                this.forEachKey(function(key) {\n                    keys.push(key);\n                });\n                return keys;\n            }\n        });\n\n        /*---------------Queue structure--------------------------------*/\n\n        var Queue = kendo.Class.extend({\n\n            init: function() {\n                this._tail = null;\n                this._head = null;\n                this.length = 0;\n            },\n\n            /**\n             * Enqueues an object to the end of the queue.\n             */\n            enqueue: function(value) {\n                var entry = { value: value, next: null };\n                if (!this._head) {\n                    this._head = entry;\n                    this._tail = this._head;\n                }\n                else {\n                    this._tail.next = entry;\n                    this._tail = this._tail.next;\n                }\n                this.length++;\n            },\n\n            /**\n             * Removes and returns the object at top of the queue.\n             */\n            dequeue: function() {\n                if (this.length < 1) {\n                    throw new Error(\"The queue is empty.\");\n                }\n                var value = this._head.value;\n                this._head = this._head.next;\n                this.length--;\n                return value;\n            },\n\n            contains: function(item) {\n                var current = this._head;\n                while (current) {\n                    if (current.value === item) {\n                        return true;\n                    }\n                    current = current.next;\n                }\n                return false;\n            }\n        });\n\n\n        /**\n         * While other data structures can have multiple times the same item a Set owns only\n         * once a particular item.\n         * @type {*}\n         */\n        var Set = kendo.Observable.extend({\n            init: function(resource) {\n                var that = this;\n                kendo.Observable.fn.init.call(that);\n                this._hashTable = new HashTable();\n                this.length = 0;\n                if (Utils.isDefined(resource)) {\n                    if (resource instanceof HashTable) {\n                        resource.forEach(function(d) {\n                            this.add(d);\n                        });\n                    }\n                    else if (resource instanceof Dictionary) {\n                        resource.forEach(function(k, v) {\n                            this.add({ key: k, value: v });\n                        }, this);\n                    }\n                }\n            },\n\n            contains: function(item) {\n                return this._hashTable.containsKey(item);\n            },\n\n            add: function(item) {\n                var entry = this._hashTable.get(item);\n                if (!entry) {\n                    this._hashTable.add(item, item);\n                    this.length++;\n                    this.trigger('changed');\n                }\n            },\n\n            get: function(item) {\n                if (this.contains(item)) {\n                    return this._hashTable.get(item).value;\n                }\n                else {\n                    return null;\n                }\n            },\n\n            /**\n             * Returns the hash of the item.\n             * @param item\n             * @returns {*}\n             */\n            hash: function(item) {\n                return this._hashTable._hash(item);\n            },\n\n            /**\n             * Removes the given item from the set. No exception is thrown if the item is not in the Set.\n             * @param item\n             */\n            remove: function(item) {\n                if (this.contains(item)) {\n                    this._hashTable.remove(item);\n                    this.length--;\n                    this.trigger('changed');\n                }\n            },\n            /**\n             * Foreach with an iterator working on the key-value pairs.\n             * @param func\n             */\n            forEach: function(func, context) {\n                this._hashTable.forEach(function(kv) {\n                    func(kv.value);\n                }, context);\n            },\n            toArray: function() {\n                var r = [];\n                this.forEach(function(d) {\n                    r.push(d);\n                });\n                return r;\n            }\n        });\n\n        /*----------------Node-------------------------------*/\n\n        /**\n         * Defines the node (vertex) of a Graph.\n         */\n        var Node = kendo.Class.extend({\n\n            init: function(id, shape) {\n\n                /**\n                 * Holds all the links incident with the current node.\n                 * Do not use this property to manage the incoming links, use the appropriate add/remove methods instead.\n                 */\n                this.links = [];\n\n                /**\n                 * Holds the links from the current one to another Node .\n                 * Do not use this property to manage the incoming links, use the appropriate add/remove methods instead.\n                 */\n                this.outgoing = [];\n\n                /**\n                 * Holds the links from another Node to the current one.\n                 * Do not use this property to manage the incoming links, use the appropriate add/remove methods instead.\n                 */\n                this.incoming = [];\n\n                /**\n                 * Holds the weight of this Node.\n                 */\n                this.weight = 1;\n\n                if (Utils.isDefined(id)) {\n                    this.id = id;\n                }\n                else {\n                    this.id = randomId();\n                }\n                if (Utils.isDefined(shape)) {\n                    this.associatedShape = shape;\n                    // transfer the shape's bounds to the runtime props\n                    var b = shape.bounds();\n                    this.width = b.width;\n                    this.height = b.height;\n                    this.x = b.x;\n                    this.y = b.y;\n                }\n                else {\n                    this.associatedShape = null;\n                }\n                /**\n                 * The payload of the node.\n                 * @type {null}\n                 */\n                this.data = null;\n                this.type = \"Node\";\n                this.shortForm = \"Node '\" + this.id + \"'\";\n                /**\n                 * Whether this is an injected node during the analysis or layout process.\n                 * @type {boolean}\n                 */\n                this.isVirtual = false;\n            },\n\n            /**\n             * Returns whether this node has no links attached.\n             */\n            isIsolated: function() {\n                return Utils.isEmpty(this.links);\n            },\n\n            /**\n             * Gets or sets the bounding rectangle of this node.\n             * This should be considered as runtime data, the property is not hotlinked to a SVG item.\n             */\n            bounds: function(r) {\n                if (!Utils.isDefined(r)) {\n                    return new diagram.Rect(this.x, this.y, this.width, this.height);\n                }\n\n                this.x = r.x;\n                this.y = r.y;\n                this.width = r.width;\n                this.height = r.height;\n            },\n\n            /**\n             * Returns whether there is at least one link with the given (complementary) node. This can be either an\n             * incoming or outgoing link.\n             */\n            isLinkedTo: function(node) {\n                var that = this;\n                return Utils.any(that.links, function(link) {\n                    return link.getComplement(that) === node;\n                });\n            },\n\n            /**\n             * Gets the children of this node, defined as the adjacent nodes with a link from this node to the adjacent one.\n             * @returns {Array}\n             */\n            getChildren: function() {\n                if (this.outgoing.length === 0) {\n                    return [];\n                }\n                var children = [];\n                for (var i = 0, len = this.outgoing.length; i < len; i++) {\n                    var link = this.outgoing[i];\n                    children.push(link.getComplement(this));\n                }\n                return children;\n            },\n\n            /**\n             * Gets the parents of this node, defined as the adjacent nodes with a link from the adjacent node to this one.\n             * @returns {Array}\n             */\n            getParents: function() {\n                if (this.incoming.length === 0) {\n                    return [];\n                }\n                var parents = [];\n                for (var i = 0, len = this.incoming.length; i < len; i++) {\n                    var link = this.incoming[i];\n                    parents.push(link.getComplement(this));\n                }\n                return parents;\n            },\n\n            /**\n             * Returns a clone of the Node. Note that the identifier is not cloned since it's a different Node instance.\n             * @returns {Node}\n             */\n            clone: function() {\n                var copy = new Node();\n                if (Utils.isDefined(this.weight)) {\n                    copy.weight = this.weight;\n                }\n                if (Utils.isDefined(this.balance)) {\n                    copy.balance = this.balance;\n                }\n                if (Utils.isDefined(this.owner)) {\n                    copy.owner = this.owner;\n                }\n                copy.associatedShape = this.associatedShape;\n                copy.x = this.x;\n                copy.y = this.y;\n                copy.width = this.width;\n                copy.height = this.height;\n                return copy;\n            },\n\n            /**\n             * Returns whether there is a link from the current node to the given node.\n             */\n            adjacentTo: function(node) {\n                return this.isLinkedTo(node) !== null;\n            },\n\n            /**\n             * Removes the given link from the link collection this node owns.\n             * @param link\n             */\n            removeLink: function(link) {\n                if (link.source === this) {\n                    Utils.remove(this.links, link);\n                    Utils.remove(this.outgoing, link);\n                    link.source = null;\n                }\n\n                if (link.target === this) {\n                    Utils.remove(this.links, link);\n                    Utils.remove(this.incoming, link);\n                    link.target = null;\n                }\n            },\n\n            /**\n             * Returns whether there is a (outgoing) link from the current node to the given one.\n             */\n            hasLinkTo: function(node) {\n                return Utils.any(this.outgoing, function(link) {\n                    return link.target === node;\n                });\n            },\n\n            /**\n             * Returns the degree of this node, i.e. the sum of incoming and outgoing links.\n             */\n            degree: function() {\n                return this.links.length;\n            },\n\n            /**\n             * Returns whether this node is either the source or the target of the given link.\n             */\n            incidentWith: function(link) {\n                return contains(this.links, link);\n            },\n\n            /**\n             * Returns the links between this node and the given one.\n             */\n            getLinksWith: function(node) {\n                return Utils.all(this.links, function(link) {\n                    return link.getComplement(this) === node;\n                }, this);\n            },\n\n            /**\n             * Returns the nodes (either parent or child) which are linked to the current one.\n             */\n            getNeighbors: function() {\n                var neighbors = [];\n                Utils.forEach(this.incoming, function(e) {\n                    neighbors.push(e.getComplement(this));\n                }, this);\n                Utils.forEach(this.outgoing, function(e) {\n                    neighbors.push(e.getComplement(this));\n                }, this);\n                return neighbors;\n            }\n        });\n\n        /**\n         * Defines a directed link (edge, connection) of a Graph.\n         */\n        var Link = kendo.Class.extend({\n\n            init: function(source, target, id, connection) {\n                if (Utils.isUndefined(source)) {\n                    throw \"The source of the new link is not set.\";\n                }\n                if (Utils.isUndefined(target)) {\n                    throw \"The target of the new link is not set.\";\n                }\n                var sourceFound, targetFound;\n                if (Utils.isString(source)) {\n                    sourceFound = new Node(source);\n                }\n                else {\n                    sourceFound = source;\n                }\n                if (Utils.isString(target)) {\n                    targetFound = new Node(target);\n                }\n                else {\n                    targetFound = target;\n                }\n\n                this.source = sourceFound;\n                this.target = targetFound;\n                this.source.links.push(this);\n                this.target.links.push(this);\n                this.source.outgoing.push(this);\n                this.target.incoming.push(this);\n                if (Utils.isDefined(id)) {\n                    this.id = id;\n                }\n                else {\n                    this.id = randomId();\n                }\n                if (Utils.isDefined(connection)) {\n                    this.associatedConnection = connection;\n                }\n                else {\n                    this.associatedConnection = null;\n                }\n                this.type = \"Link\";\n                this.shortForm = \"Link '\" + this.source.id + \"->\" + this.target.id + \"'\";\n            },\n\n            /**\n             * Returns the complementary node of the given one, if any.\n             */\n            getComplement: function(node) {\n                if (this.source !== node && this.target !== node) {\n                    throw \"The given node is not incident with this link.\";\n                }\n                return this.source === node ? this.target : this.source;\n            },\n\n            /**\n             * Returns the overlap of the current link with the given one, if any.\n             */\n            getCommonNode: function(link) {\n                if (this.source === link.source || this.source === link.target) {\n                    return this.source;\n                }\n                if (this.target === link.source || this.target === link.target) {\n                    return this.target;\n                }\n                return null;\n            },\n\n            /**\n             * Returns whether the current link is bridging the given nodes.\n             */\n            isBridging: function(v1, v2) {\n                return this.source === v1 && this.target === v2 || this.source === v2 && this.target === v1;\n            },\n\n            /**\n             * Returns the source and target of this link as a tuple.\n             */\n            getNodes: function() {\n                return [this.source, this.target];\n            },\n\n            /**\n             * Returns whether the given node is either the source or the target of the current link.\n             */\n            incidentWith: function(node) {\n                return this.source === node || this.target === node;\n            },\n\n            /**\n             * Returns whether the given link is a continuation of the current one. This can be both\n             * via an incoming or outgoing link.\n             */\n            adjacentTo: function(link) {\n                return contains(this.source.links, link) || contains(this.target.links, link);\n            },\n\n            /**\n             * Changes the source-node of this link.\n             */\n            changeSource: function(node) {\n                Utils.remove(this.source.links, this);\n                Utils.remove(this.source.outgoing, this);\n\n                node.links.push(this);\n                node.outgoing.push(this);\n\n                this.source = node;\n            },\n\n            /**\n             * Changes the target-node of this link.\n             * @param node\n             */\n            changeTarget: function(node) {\n                Utils.remove(this.target.links, this);\n                Utils.remove(this.target.incoming, this);\n\n                node.links.push(this);\n                node.incoming.push(this);\n\n                this.target = node;\n            },\n\n            /**\n             * Changes both the source and the target nodes of this link.\n             */\n            changesNodes: function(v, w) {\n                if (this.source === v) {\n                    this.changeSource(w);\n                }\n                else if (this.target === v) {\n                    this.changeTarget(w);\n                }\n            },\n\n            /**\n             * Reverses the direction of this link.\n             */\n            reverse: function() {\n                var oldSource = this.source;\n                var oldTarget = this.target;\n\n                this.source = oldTarget;\n                Utils.remove(oldSource.outgoing, this);\n                this.source.outgoing.push(this);\n\n                this.target = oldSource;\n                Utils.remove(oldTarget.incoming, this);\n                this.target.incoming.push(this);\n                return this;\n            },\n\n            /**\n             * Ensures that the given target defines the endpoint of this link.\n             */\n            directTo: function(target) {\n                if (this.source !== target && this.target !== target) {\n                    throw \"The given node is not incident with this link.\";\n                }\n                if (this.target !== target) {\n                    this.reverse();\n                }\n            },\n\n            /**\n             * Returns a reversed clone of this link.\n             */\n            createReverseEdge: function() {\n                var r = this.clone();\n                r.reverse();\n                r.reversed = true;\n                return r;\n            },\n\n            /**\n             * Returns a clone of this link.\n             */\n            clone: function() {\n                var clone = new Link(this.source, this.target);\n                return clone;\n            }\n        });\n\n        /*--------------Graph structure---------------------------------*/\n        /**\n         * Defines a directed graph structure.\n         * Note that the incidence structure resides in the nodes through the incoming and outgoing links collection, rahter than\n         * inside the Graph.\n         */\n        var Graph = kendo.Class.extend({\n            init: function(idOrDiagram) {\n                /**\n                 * The links or edge collection of this Graph.\n                 * @type {Array}\n                 */\n                this.links = [];\n                /**\n                 * The node or vertex collection of this Graph.\n                 * @type {Array}\n                 */\n                this.nodes = [];\n\n                this._nodeMap = new Dictionary();\n                /**\n                 * The optional reference to the Diagram on which this Graph is based.\n                 * @type {null}\n                 */\n                this.diagram = null;\n\n                /**\n                 * The root of this Graph. If not set explicitly the first Node with zero incoming links will be taken.\n                 * @type {null}\n                 * @private\n                 */\n                this._root = null;\n                if (Utils.isDefined(idOrDiagram)) {\n                    if (Utils.isString(idOrDiagram)) {\n                        this.id = idOrDiagram;\n                    }\n                    else {\n                        this.diagram = idOrDiagram;\n                        this.id = idOrDiagram.id;\n                    }\n                }\n                else {\n                    this.id = randomId();\n                }\n\n                /**\n                 * The bounds of this graph if the nodes have spatial extension defined.\n                 * @type {Rect}\n                 */\n                this.bounds = new Rect();\n                // keeps track whether the children & parents have been created\n                this._hasCachedRelationships = false;\n                this.type = \"Graph\";\n            },\n            /**\n             * Caches the relational information of parents and children in the 'parents' and 'children'\n             * properties.\n             * @param forceRebuild If set to true the relational info will be rebuild even if already present.\n             */\n            cacheRelationships: function(forceRebuild) {\n                if (Utils.isUndefined(forceRebuild)) {\n                    forceRebuild = false;\n                }\n                if (this._hasCachedRelationships && !forceRebuild) {\n                    return;\n                }\n                for (var i = 0, len = this.nodes.length; i < len; i++) {\n                    var node = this.nodes[i];\n                    node.children = this.getChildren(node);\n                    node.parents = this.getParents(node);\n                }\n                this._hasCachedRelationships = true;\n            },\n\n            /**\n             * Assigns tree-levels to the nodes assuming this is a tree graph.\n             * If not connected or not a tree the process will succeed but\n             * will have little meaning.\n             * @param startNode The node from where the level numbering starts, usually the root of the tree.\n             * @param visited The collection of visited nodes.\n             * @param offset The offset or starting counter of the level info.\n             */\n            assignLevels: function(startNode, offset, visited) {\n                if (!startNode) {\n                    throw \"Start node not specified.\";\n                }\n                if (Utils.isUndefined(offset)) {\n                    offset = 0;\n                }\n                // if not done before, cache the parents and children\n                this.cacheRelationships();\n                if (Utils.isUndefined(visited)) {\n                    visited = new Dictionary();\n                    Utils.forEach(this.nodes, function(n) {\n                        visited.add(n, false);\n                    });\n                }\n                visited.set(startNode, true);\n                startNode.level = offset;\n                var children = startNode.children;\n                for (var i = 0, len = children.length; i < len; i++) {\n                    var child = children[i];\n                    if (!child || visited.get(child)) {\n                        continue;\n                    }\n                    this.assignLevels(child, offset + 1, visited);\n                }\n            },\n\n            /**\n             * Gets or set the root of this graph.\n             * If not set explicitly the first Node with zero incoming links will be taken.\n             * @param value\n             * @returns {*}\n             */\n            root: function(value) {\n                if (Utils.isUndefined(value)) {\n                    if (!this._root) {\n                        // TODO: better to use the longest path for the most probable root?\n                        var found = Utils.first(this.nodes, function(n) {\n                            return n.incoming.length === 0;\n                        });\n                        if (found) {\n                            return found;\n                        }\n                        return Utils.first(this.nodes);\n                    }\n                    else {\n                        return this._root;\n                    }\n                }\n                else {\n                    this._root = value;\n                }\n            },\n\n            /**\n             * Returns the connected components of this graph.\n             * Note that the returned graphs are made up of the nodes and links of this graph, i.e. a pointer to the items of this graph.\n             * If you alter the items of the components you'll alter the original graph and vice versa.\n             * @returns {Array}\n             */\n            getConnectedComponents: function() {\n                this.componentIndex = 0;\n                this.setItemIndices();\n                var componentId = Utils.initArray(this.nodes.length, -1);\n\n                for (var v = 0; v < this.nodes.length; v++) {\n                    if (componentId[v] === -1) {\n                        this._collectConnectedNodes(componentId, v);\n                        this.componentIndex++;\n                    }\n                }\n\n                var components = [], i;\n                for (i = 0; i < this.componentIndex; ++i) {\n                    components[i] = new Graph();\n                }\n                for (i = 0; i < componentId.length; ++i) {\n                    var graph = components[componentId[i]];\n                    graph.addNodeAndOutgoings(this.nodes[i]);\n                }\n                // sorting the components in decreasing order of node count\n                components.sort(function(a, b) {\n                    return b.nodes.length - a.nodes.length;\n                });\n                return components;\n            },\n\n            _collectConnectedNodes: function(setIds, nodeIndex) {\n                setIds[nodeIndex] = this.componentIndex; // part of the current component\n                var node = this.nodes[nodeIndex];\n                Utils.forEach(node.links,\n                    function(link) {\n                        var next = link.getComplement(node);\n                        var nextId = next.index;\n                        if (setIds[nextId] === -1) {\n                            this._collectConnectedNodes(setIds, nextId);\n                        }\n                    }, this);\n            },\n\n            /**\n             * Calculates the bounds of this Graph if the Nodes have spatial dimensions defined.\n             * @returns {Rect}\n             */\n            calcBounds: function() {\n                if (this.isEmpty()) {\n                    this.bounds = new Rect();\n                    return this.bounds;\n                }\n                var b = null;\n                for (var i = 0, len = this.nodes.length; i < len; i++) {\n                    var node = this.nodes[i];\n                    if (!b) {\n                        b = node.bounds();\n                    }\n                    else {\n                        b = b.union(node.bounds());\n                    }\n                }\n                this.bounds = b;\n                return this.bounds;\n            },\n\n            /**\n             * Creates a spanning tree for the current graph.\n             * Important: this will not return a spanning forest if the graph is disconnected.\n             * Prim's algorithm  finds a minimum-cost spanning tree of an edge-weighted, connected, undirected graph;\n             * see http://en.wikipedia.org/wiki/Prim%27s_algorithm .\n             * @param root The root of the spanning tree.\n             * @returns {Graph}\n             */\n            getSpanningTree: function(root) {\n                var tree = new Graph();\n                var map = new Dictionary(), source, target;\n                tree.root = root.clone();\n                tree.root.level = 0;\n                tree.root.id = root.id;\n                map.add(root, tree.root);\n                root.level = 0;\n\n                var visited = [];\n                var remaining = [];\n                tree._addNode(tree.root);\n                visited.push(root);\n                remaining.push(root);\n\n                var levelCount = 1;\n                while (remaining.length > 0) {\n                    var next = remaining.pop();\n                    for (var ni = 0; ni < next.links.length; ni++) {\n                        var link = next.links[ni];\n                        var cn = link.getComplement(next);\n                        if (contains(visited, cn)) {\n                            continue;\n                        }\n\n                        cn.level = next.level + 1;\n                        if (levelCount < cn.level + 1) {\n                            levelCount = cn.level + 1;\n                        }\n                        if (!contains(remaining, cn)) {\n                            remaining.push(cn);\n                        }\n                        if (!contains(visited, cn)) {\n                            visited.push(cn);\n                        }\n                        if (map.containsKey(next)) {\n                            source = map.get(next);\n                        }\n                        else {\n                            source = next.clone();\n                            source.level = next.level;\n                            source.id = next.id;\n                            map.add(next, source);\n                        }\n                        if (map.containsKey(cn)) {\n                            target = map.get(cn);\n                        }\n                        else {\n                            target = cn.clone();\n                            target.level = cn.level;\n                            target.id = cn.id;\n                            map.add(cn, target);\n                        }\n                        var newLink = new Link(source, target);\n                        tree.addLink(newLink);\n                    }\n\n                }\n\n                var treeLevels = [];\n                for (var i = 0; i < levelCount; i++) {\n                    treeLevels.push([]);\n                }\n\n                Utils.forEach(tree.nodes, function(node) {\n                    treeLevels[node.level].push(node);\n                });\n\n                tree.treeLevels = treeLevels;\n                tree.cacheRelationships();\n                return tree;\n            },\n\n            /**\n             * Returns a random node in this graph.\n             * @param excludedNodes The collection of nodes which should not be considered.\n             * @param incidenceLessThan The maximum degree or incidence the random node should have.\n             * @returns {*}\n             */\n            takeRandomNode: function(excludedNodes, incidenceLessThan) {\n                if (Utils.isUndefined(excludedNodes)) {\n                    excludedNodes = [];\n                }\n                if (Utils.isUndefined(incidenceLessThan)) {\n                    incidenceLessThan = 4;\n                }\n                if (this.nodes.length === 0) {\n                    return null;\n                }\n                if (this.nodes.length === 1) {\n                    return contains(excludedNodes, this.nodes[0]) ? null : this.nodes[0];\n                }\n                var pool = $.grep(this.nodes, function(node) {\n                    return !contains(excludedNodes, node) && node.degree() <= incidenceLessThan;\n                });\n                if (Utils.isEmpty(pool)) {\n                    return null;\n                }\n                return pool[Utils.randomInteger(0, pool.length)];\n            },\n\n            /**\n             * Returns whether this is an empty graph.\n             */\n            isEmpty: function() {\n                return Utils.isEmpty(this.nodes);\n            },\n\n            /**\n             * Checks whether the endpoints of the links are all in the nodes collection.\n             */\n            isHealthy: function() {\n                return Utils.all(this.links, function(link) {\n                    return contains(this.nodes, link.source) && contains(this.nodes, link.target);\n                }, this);\n            },\n\n            /**\n             * Gets the parents of this node, defined as the adjacent nodes with a link from the adjacent node to this one.\n             * @returns {Array}\n             */\n            getParents: function(n) {\n                if (!this.hasNode(n)) {\n                    throw \"The given node is not part of this graph.\";\n                }\n                return n.getParents();\n            },\n\n            /**\n             * Gets the children of this node, defined as the adjacent nodes with a link from this node to the adjacent one.\n             * @returns {Array}\n             */\n            getChildren: function(n) {\n                if (!this.hasNode(n)) {\n                    throw \"The given node is not part of this graph.\";\n                }\n                return n.getChildren();\n            },\n\n            /**\n             * Adds a new link to the graph between the given nodes.\n             */\n            addLink: function(sourceOrLink, target, owner) {\n\n                if (Utils.isUndefined(sourceOrLink)) {\n                    throw \"The source of the link is not defined.\";\n                }\n                if (Utils.isUndefined(target)) {\n                    // can only be undefined if the first one is a Link\n                    if (Utils.isDefined(sourceOrLink.type) && sourceOrLink.type === \"Link\") {\n                        this.addExistingLink(sourceOrLink);\n                        return;\n                    }\n                    else {\n                        throw \"The target of the link is not defined.\";\n                    }\n                }\n\n                var foundSource = this.getNode(sourceOrLink);\n                if (Utils.isUndefined(foundSource)) {\n                    foundSource = this.addNode(sourceOrLink);\n                }\n                var foundTarget = this.getNode(target);\n                if (Utils.isUndefined(foundTarget)) {\n                    foundTarget = this.addNode(target);\n                }\n\n                var newLink = new Link(foundSource, foundTarget);\n\n                if (Utils.isDefined(owner)) {\n                    newLink.owner = owner;\n                }\n\n                /*newLink.source.outgoing.push(newLink);\n                 newLink.source.links.push(newLink);\n                 newLink.target.incoming.push(newLink);\n                 newLink.target.links.push(newLink);*/\n\n                this.links.push(newLink);\n\n                return newLink;\n            },\n\n            /**\n             * Removes all the links in this graph.\n             */\n            removeAllLinks: function() {\n                while (this.links.length > 0) {\n                    var link = this.links[0];\n                    this.removeLink(link);\n                }\n            },\n\n            /**\n             * Adds the given link to the current graph.\n             */\n            addExistingLink: function(link) {\n\n                if (this.hasLink(link)) {\n                    return;\n                }\n                this.links.push(link);\n                if (this.hasNode(link.source.id)) {\n                    // priority to the existing node with the id even if other props are different\n                    var s = this.getNode(link.source.id);\n                    link.changeSource(s);\n                }\n                else {\n                    this.addNode(link.source);\n                }\n\n                if (this.hasNode(link.target.id)) {\n                    var t = this.getNode(link.target.id);\n                    link.changeTarget(t);\n                }\n                else {\n                    this.addNode(link.target);\n                }\n\n                /*  if (!link.source.outgoing.contains(link)) {\n                 link.source.outgoing.push(link);\n                 }\n                 if (!link.source.links.contains(link)) {\n                 link.source.links.push(link);\n                 }\n                 if (!link.target.incoming.contains(link)) {\n                 link.target.incoming.push(link);\n                 }\n                 if (!link.target.links.contains(link)) {\n                 link.target.links.push(link);\n                 }*/\n            },\n\n            /**\n             * Returns whether the given identifier or Link is part of this graph.\n             * @param linkOrId An identifier or a Link object.\n             * @returns {*}\n             */\n            hasLink: function(linkOrId) {\n                if (Utils.isString(linkOrId)) {\n                    return Utils.any(this.links, function(link) {\n                        return link.id === linkOrId;\n                    });\n                }\n                if (linkOrId.type === \"Link\") {\n                    return contains(this.links, linkOrId);\n                }\n                throw \"The given object is neither an identifier nor a Link.\";\n            },\n            /**\n             * Gets the node with the specified Id or null if not part of this graph.\n             */\n            getNode: function(nodeOrId) {\n                var id = nodeOrId.id || nodeOrId;\n                if (this._nodeMap.containsKey(id)) {\n                    return this._nodeMap.get(id);\n                }\n            },\n\n            /**\n             * Returns whether the given node or node Id is part of this graph.\n             */\n            hasNode: function(nodeOrId) {\n                var id = nodeOrId.id || nodeOrId;\n                return this._nodeMap.containsKey(id);\n            },\n\n            _addNode: function(node) {\n                this.nodes.push(node);\n                this._nodeMap.add(node.id, node);\n            },\n\n            _removeNode: function(node) {\n                Utils.remove(this.nodes, node);\n                this._nodeMap.remove(node.id);\n            },\n\n            /**\n             * Removes the given node from this graph.\n             * The node can be specified as an object or as an identifier (string).\n             */\n            removeNode: function(nodeOrId) {\n                var n = nodeOrId;\n                if (Utils.isString(nodeOrId)) {\n                    n = this.getNode(nodeOrId);\n                }\n\n                if (Utils.isDefined(n)) {\n                    var links = n.links;\n                    n.links = [];\n                    for (var i = 0, len = links.length; i < len; i++) {\n                        var link = links[i];\n                        this.removeLink(link);\n                    }\n                    this._removeNode(n);\n                }\n                else {\n                    throw \"The identifier should be a Node or the Id (string) of a node.\";\n                }\n            },\n\n            /**\n             * Returns whether the given nodes are connected with a least one link independently of the direction.\n             */\n            areConnected: function(n1, n2) {\n                return Utils.any(this.links, function(link) {\n                    return link.source == n1 && link.target == n2 || link.source == n2 && link.target == n1;\n                });\n            },\n\n            /**\n             * Removes the given link from this graph.\n             */\n            removeLink: function(link) {\n                /*    if (!this.links.contains(link)) {\n                 throw \"The given link is not part of the Graph.\";\n                 }\n                 */\n                Utils.remove(this.links, link);\n\n                Utils.remove(link.source.outgoing, link);\n                Utils.remove(link.source.links, link);\n                Utils.remove(link.target.incoming, link);\n                Utils.remove(link.target.links, link);\n            },\n\n            /**\n             * Adds a new node to this graph, if not already present.\n             * The node can be an existing Node or the identifier of a new node.\n             * No error is thrown if the node is already there and the existing one is returned.\n             */\n            addNode: function(nodeOrId, layoutRect, owner) {\n\n                var newNode = null;\n\n                if (!Utils.isDefined(nodeOrId)) {\n                    throw \"No Node or identifier for a new Node is given.\";\n                }\n\n                if (Utils.isString(nodeOrId)) {\n                    if (this.hasNode(nodeOrId)) {\n                        return this.getNode(nodeOrId);\n                    }\n                    newNode = new Node(nodeOrId);\n                }\n                else {\n                    if (this.hasNode(nodeOrId)) {\n                        return this.getNode(nodeOrId);\n                    }\n                    // todo: ensure that the param is a Node?\n                    newNode = nodeOrId;\n                }\n\n                if (Utils.isDefined(layoutRect)) {\n                    newNode.bounds(layoutRect);\n                }\n\n                if (Utils.isDefined(owner)) {\n                    newNode.owner = owner;\n                }\n                this._addNode(newNode);\n                return newNode;\n            },\n\n            /**\n             * Adds the given Node and its outgoing links.\n             */\n            addNodeAndOutgoings: function(node) {\n                if (!this.hasNode(node)) {\n                    this._addNode(node);\n                }\n\n                var newLinks = node.outgoing;\n                node.outgoing = [];\n                Utils.forEach(newLinks, function(link) {\n                    this.addExistingLink(link);\n                }, this);\n            },\n\n            /**\n             * Sets the 'index' property on the links and nodes of this graph.\n             */\n            setItemIndices: function() {\n                var i;\n                for (i = 0; i < this.nodes.length; ++i) {\n                    this.nodes[i].index = i;\n                }\n\n                for (i = 0; i < this.links.length; ++i) {\n                    this.links[i].index = i;\n                }\n            },\n\n            /**\n             * Returns a clone of this graph.\n             */\n            clone: function(saveMapping) {\n                var copy = new Graph();\n                var save = Utils.isDefined(saveMapping) && saveMapping === true;\n                if (save) {\n                    copy.nodeMap = new Dictionary();\n                    copy.linkMap = new Dictionary();\n                }\n                // we need a map even if the saveMapping is not set\n                var map = new Dictionary();\n                Utils.forEach(this.nodes, function(nOriginal) {\n                    var nCopy = nOriginal.clone();\n                    map.set(nOriginal, nCopy);\n                    copy._addNode(nCopy);\n\n                    if (save) {\n                        copy.nodeMap.set(nCopy, nOriginal);\n                    }\n                });\n\n                Utils.forEach(this.links, function(linkOriginal) {\n                    if (map.containsKey(linkOriginal.source) && map.containsKey(linkOriginal.target)) {\n                        var linkCopy = copy.addLink(map.get(linkOriginal.source), map.get(linkOriginal.target));\n                        if (save) {\n                            copy.linkMap.set(linkCopy, linkOriginal);\n                        }\n                    }\n                });\n\n                return copy;\n            },\n\n            /**\n             * The parsing allows a quick way to create graphs.\n             *  - [\"n1->n2\", \"n2->n3\"]: creates the three nodes and adds the links\n             *  - [\"n1->n2\", {id: \"QSDF\"}, \"n2->n3\"]: same as previous but also performs a deep extend of the link between n1 and n2 with the given object.\n             */\n            linearize: function(addIds) {\n                return Graph.Utils.linearize(this, addIds);\n            },\n\n            /**\n             * Performs a depth-first traversal starting at the given node.\n             * @param startNode a node or id of a node in this graph\n             * @param action\n             */\n            depthFirstTraversal: function(startNode, action) {\n                if (Utils.isUndefined(startNode)) {\n                    throw \"You need to supply a starting node.\";\n                }\n                if (Utils.isUndefined(action)) {\n                    throw \"You need to supply an action.\";\n                }\n                if (!this.hasNode(startNode)) {\n                    throw \"The given start-node is not part of this graph\";\n                }\n                var foundNode = this.getNode(startNode);// case the given one is an Id\n                var visited = [];\n                this._dftIterator(foundNode, action, visited);\n            },\n\n            _dftIterator: function(node, action, visited) {\n\n                action(node);\n                visited.push(node);\n                var children = node.getChildren();\n                for (var i = 0, len = children.length; i < len; i++) {\n                    var child = children[i];\n                    if (contains(visited, child)) {\n                        continue;\n                    }\n                    this._dftIterator(child, action, visited);\n                }\n            },\n\n            /**\n             * Performs a breadth-first traversal starting at the given node.\n             * @param startNode a node or id of a node in this graph\n             * @param action\n             */\n            breadthFirstTraversal: function(startNode, action) {\n\n                if (Utils.isUndefined(startNode)) {\n                    throw \"You need to supply a starting node.\";\n                }\n                if (Utils.isUndefined(action)) {\n                    throw \"You need to supply an action.\";\n                }\n\n                if (!this.hasNode(startNode)) {\n                    throw \"The given start-node is not part of this graph\";\n                }\n                var foundNode = this.getNode(startNode);// case the given one is an Id\n                var queue = new Queue();\n                var visited = [];\n                queue.enqueue(foundNode);\n\n                while (queue.length > 0) {\n                    var node = queue.dequeue();\n                    action(node);\n                    visited.push(node);\n                    var children = node.getChildren();\n                    for (var i = 0, len = children.length; i < len; i++) {\n                        var child = children[i];\n                        if (contains(visited, child) || contains(queue, child)) {\n                            continue;\n                        }\n                        queue.enqueue(child);\n                    }\n                }\n            },\n\n            /**\n             * This is the classic Tarjan algorithm for strongly connected components.\n             * See e.g. http://en.wikipedia.org/wiki/Tarjan's_strongly_connected_components_algorithm\n             * @param excludeSingleItems Whether isolated nodes should be excluded from the analysis.\n             * @param node The start node from which the analysis starts.\n             * @param indices  Numbers the nodes consecutively in the order in which they are discovered.\n             * @param lowLinks The smallest index of any node known to be reachable from the node, including the node itself\n             * @param connected The current component.\n             * @param stack The bookkeeping stack of things to visit.\n             * @param index The counter of visited nodes used to assign the indices.\n             * @private\n             */\n            _stronglyConnectedComponents: function(excludeSingleItems, node, indices, lowLinks, connected, stack, index) {\n                indices.add(node, index);\n                lowLinks.add(node, index);\n                index++;\n\n                stack.push(node);\n\n                var children = node.getChildren(), next;\n                for (var i = 0, len = children.length; i < len; i++) {\n                    next = children[i];\n                    if (!indices.containsKey(next)) {\n                        this._stronglyConnectedComponents(excludeSingleItems, next, indices, lowLinks, connected, stack, index);\n                        lowLinks.add(node, Math.min(lowLinks.get(node), lowLinks.get(next)));\n                    }\n                    else if (contains(stack, next)) {\n                        lowLinks.add(node, Math.min(lowLinks.get(node), indices.get(next)));\n                    }\n                }\n                // If v is a root node, pop the stack and generate a strong component\n                if (lowLinks.get(node) === indices.get(node)) {\n                    var component = [];\n                    do {\n                        next = stack.pop();\n                        component.push(next);\n                    }\n                    while (next !== node);\n                    if (!excludeSingleItems || (component.length > 1)) {\n                        connected.push(component);\n                    }\n                }\n            },\n\n            /**\n             * Returns the cycles found in this graph.\n             * The returned arrays consist of the nodes which are strongly coupled.\n             * @param excludeSingleItems Whether isolated nodes should be excluded.\n             * @returns {Array} The array of cycles found.\n             */\n            findCycles: function(excludeSingleItems) {\n                if (Utils.isUndefined(excludeSingleItems)) {\n                    excludeSingleItems = true;\n                }\n                var indices = new Dictionary();\n                var lowLinks = new Dictionary();\n                var connected = [];\n                var stack = [];\n                for (var i = 0, len = this.nodes.length; i < len; i++) {\n                    var node = this.nodes[i];\n                    if (indices.containsKey(node)) {\n                        continue;\n                    }\n                    this._stronglyConnectedComponents(excludeSingleItems, node, indices, lowLinks, connected, stack, 0);\n                }\n                return connected;\n            },\n\n            /**\n             * Returns whether this graph is acyclic.\n             * @returns {*}\n             */\n            isAcyclic: function() {\n                return Utils.isEmpty(this.findCycles());\n            },\n\n            /**\n             * Returns whether the given graph is a subgraph of this one.\n             * @param other Another graph instance.\n             */\n            isSubGraph: function(other) {\n                var otherArray = other.linearize();\n                var thisArray = this.linearize();\n                return Utils.all(otherArray, function(s) {\n                    return contains(thisArray, s);\n                });\n            },\n\n            /**\n             *  Makes an acyclic graph from the current (connected) one.\n             * * @returns {Array} The reversed links.\n             */\n            makeAcyclic: function() {\n                // if empty or almost empty\n                if (this.isEmpty() || this.nodes.length <= 1 || this.links.length <= 1) {\n                    return [];\n                }\n                // singular case of just two nodes\n                if (this.nodes.length == 2) {\n                    var result = [];\n                    if (this.links.length > 1) {\n                        var oneLink = this.links[0];\n                        var oneNode = oneLink.source;\n                        for (var i = 0, len = this.links.length; i < len; i++) {\n                            var link = this.links[i];\n                            if (link.source == oneNode) {\n                                continue;\n                            }\n                            var rev = link.reverse();\n                            result.push(rev);\n                        }\n                    }\n                    return result;\n                }\n\n                var copy = this.clone(true); // copy.nodeMap tells you the mapping\n                var N = this.nodes.length;\n\n                var intensityCatalog = new Dictionary();\n\n                /**\n                 * If there are both incoming and outgoing links this will return the flow intensity (out-in).\n                 * Otherwise the node acts as a flow source with N specifying the (equal) intensity.\n                 * @param node\n                 * @returns {number}\n                 */\n                var flowIntensity = function(node, N) {\n                    if (node.outgoing.length === 0) {\n                        return (2 - N);\n                    }\n                    else if (node.incoming.length === 0) {\n                        return (N - 2);\n                    }\n                    else {\n                        return node.outgoing.length - node.incoming.length;\n                    }\n                };\n\n                /**\n                 * Collects the nodes with the same intensity.\n                 * @param node\n                 * @param intensityCatalog\n                 */\n                var catalogEqualIntensity = function(node, intensityCatalog) {\n                    var intensity = flowIntensity(node, N);\n                    if (!intensityCatalog.containsKey(intensity)) {\n                        intensityCatalog.set(intensity, []);\n                    }\n                    intensityCatalog.get(intensity).push(node);\n                };\n\n                Utils.forEach(copy.nodes, function(v) {\n                    catalogEqualIntensity(v, intensityCatalog);\n                });\n\n                var sourceStack = [];\n                var targetStack = [];\n\n                while (copy.nodes.length > 0) {\n                    var source, target, intensity;\n                    if (intensityCatalog.containsKey(2 - N)) {\n                        var targets = intensityCatalog.get(2 - N); // nodes without outgoings\n                        while (targets.length > 0) {\n                            target = targets.pop();\n                            for (var li = 0; li < target.links.length; li++) {\n                                var targetLink = target.links[li];\n                                source = targetLink.getComplement(target);\n                                intensity = flowIntensity(source, N);\n                                Utils.remove(intensityCatalog.get(intensity), source);\n                                source.removeLink(targetLink);\n                                catalogEqualIntensity(source, intensityCatalog);\n                            }\n                            copy._removeNode(target);\n                            targetStack.unshift(target);\n                        }\n                    }\n\n                    // move sources to sourceStack\n                    if (intensityCatalog.containsKey(N - 2)) {\n                        var sources = intensityCatalog.get(N - 2); // nodes without incomings\n                        while (sources.length > 0) {\n                            source = sources.pop();\n                            for (var si = 0; si < source.links.length; si++) {\n                                var sourceLink = source.links[si];\n                                target = sourceLink.getComplement(source);\n                                intensity = flowIntensity(target, N);\n                                Utils.remove(intensityCatalog.get(intensity), target);\n                                target.removeLink(sourceLink);\n                                catalogEqualIntensity(target, intensityCatalog);\n                            }\n                            sourceStack.push(source);\n                            copy._removeNode(source);\n                        }\n                    }\n\n                    if (copy.nodes.length > 0) {\n                        for (var k = N - 3; k > 2 - N; k--) {\n                            if (intensityCatalog.containsKey(k) &&\n                                intensityCatalog.get(k).length > 0) {\n                                var maxdiff = intensityCatalog.get(k);\n                                var v = maxdiff.pop();\n                                for (var ri = 0; ri < v.links.length; ri++) {\n                                    var ril = v.links[ri];\n                                    var u = ril.getComplement(v);\n                                    intensity = flowIntensity(u, N);\n                                    Utils.remove(intensityCatalog.get(intensity), u);\n                                    u.removeLink(ril);\n                                    catalogEqualIntensity(u, intensityCatalog);\n                                }\n                                sourceStack.push(v);\n                                copy._removeNode(v);\n                                break;\n                            }\n                        }\n                    }\n                }\n\n                sourceStack = sourceStack.concat(targetStack);\n\n                var vertexOrder = new Dictionary();\n                for (var kk = 0; kk < this.nodes.length; kk++) {\n                    vertexOrder.set(copy.nodeMap.get(sourceStack[kk]), kk);\n                }\n\n                var reversedEdges = [];\n                Utils.forEach(this.links, function(link) {\n                    if (vertexOrder.get(link.source) > vertexOrder.get(link.target)) {\n                        link.reverse();\n                        reversedEdges.push(link);\n                    }\n                });\n                return reversedEdges;\n            }\n        });\n\n        /**\n         * A collection of predefined graphs for demo and testing purposes.\n         */\n        Graph.Predefined = {\n            /**\n             * Eight-shapes graph all connected in a cycle.\n             * @returns {*}\n             * @constructor\n             */\n            EightGraph: function() {\n                return Graph.Utils.parse([ \"1->2\", \"2->3\", \"3->4\", \"4->1\", \"3->5\", \"5->6\", \"6->7\", \"7->3\"]);\n            },\n\n            /**\n             * Creates a typical mindmap diagram.\n             * @returns {*}\n             * @constructor\n             */\n            Mindmap: function() {\n                return Graph.Utils.parse([\"0->1\", \"0->2\", \"0->3\", \"0->4\", \"0->5\", \"1->6\", \"1->7\", \"7->8\", \"2->9\", \"9->10\", \"9->11\", \"3->12\",\n                    \"12->13\", \"13->14\", \"4->15\", \"4->16\", \"15->17\", \"15->18\", \"18->19\", \"18->20\", \"14->21\", \"14->22\", \"5->23\", \"23->24\", \"23->25\", \"6->26\"]);\n            },\n\n            /**\n             * Three nodes connected in a cycle.\n             * @returns {*}\n             * @constructor\n             */\n            ThreeGraph: function() {\n                return Graph.Utils.parse([ \"1->2\", \"2->3\", \"3->1\"]);\n            },\n\n            /**\n             * A tree with each node having two children.\n             * @param levels How many levels the binary tree should have.\n             * @returns {diagram.Graph}\n             * @constructor\n             */\n            BinaryTree: function(levels) {\n                if (Utils.isUndefined(levels)) {\n                    levels = 5;\n                }\n                return Graph.Utils.createBalancedTree(levels, 2);\n            },\n\n            /**\n             * A linear graph (discrete line segment).\n             * @param length How many segments (the node count is hence (length+1)).\n             * @returns {diagram.Graph}\n             * @constructor\n             */\n            Linear: function(length) {\n                if (Utils.isUndefined(length)) {\n                    length = 10;\n                }\n                return Graph.Utils.createBalancedTree(length, 1);\n            },\n\n            /**\n             * A standard tree-graph with the specified levels and children (siblings) count.\n             * Note that for a balanced tree of level N and sibling count s, counting the root as level zero:\n             *  - NodeCount = (1-s^(N+1))/(1-s)]\n             *  - LinkCount = s.(1-s^N)/(1-s)\n             * @param levels How many levels the tree should have.\n             * @param siblingsCount How many siblings each level should have.\n             * @returns {diagram.Graph}\n             * @constructor\n             */\n            Tree: function(levels, siblingsCount) {\n                return Graph.Utils.createBalancedTree(levels, siblingsCount);\n            },\n\n            /**\n             * Creates a forest.\n             * Note that for a balanced forest of level N, sibling count s and tree count t, counting the root as level zero:\n             *  - NodeCount = t.(1-s^(N+1))/(1-s)]\n             *  - LinkCount = t.s.(1-s^N)/(1-s)\n             * @param levels How many levels the tree should have.\n             * @param siblingsCount How many siblings each level should have.\n             * @param trees The amount of trees the forest should have.\n             * @returns {diagram.Graph}\n             * @constructor\n             */\n            Forest: function(levels, siblingsCount, trees) {\n                return Graph.Utils.createBalancedForest(levels, siblingsCount, trees);\n            },\n\n            /**\n             * A workflow-like graph with cycles.\n             * @returns {*}\n             * @constructor\n             */\n            Workflow: function() {\n                return Graph.Utils.parse(\n                    [\"0->1\", \"1->2\", \"2->3\", \"1->4\", \"4->3\", \"3->5\", \"5->6\", \"6->3\", \"6->7\", \"5->4\"]\n                );\n            },\n\n            /**\n             * A grid graph with the direction of the links avoiding cycles.\n             * Node count: (n+1).(m+1)\n             * Link count: n.(m+1) + m.(n+1)\n             * @param n Horizontal count of grid cells. If zero this will result in a linear graph.\n             * @param m Vertical count of grid cells. If zero this will result in a linear graph.\n             * @constructor\n             */\n            Grid: function(n, m) {\n                var g = new diagram.Graph();\n                if (n <= 0 && m <= 0) {\n                    return g;\n                }\n\n                for (var i = 0; i < n + 1; i++) {\n                    var previous = null;\n                    for (var j = 0; j < m + 1; j++) {\n                        // using x-y coordinates to name the nodes\n                        var node = new Node(i.toString() + \".\" + j.toString());\n                        g.addNode(node);\n                        if (previous) {\n                            g.addLink(previous, node);\n                        }\n                        if (i > 0) {\n                            var left = g.getNode((i - 1).toString() + \".\" + j.toString());\n                            g.addLink(left, node);\n                        }\n                        previous = node;\n                    }\n                }\n                return g;\n            }\n\n        };\n\n        /**\n         * Graph generation and other utilities.\n         */\n        Graph.Utils = {\n            /**\n             * The parsing allows a quick way to create graphs.\n             *  - [\"n1->n2\", \"n2->n3\"]: creates the three nodes and adds the links\n             *  - [\"n1->n2\", {id: \"id177\"}, \"n2->n3\"]: same as previous but also performs a deep extend of the link between n1 and n2 with the given object.\n             */\n            parse: function(graphString) {\n\n                var previousLink, graph = new diagram.Graph(), parts = graphString.slice();\n                for (var i = 0, len = parts.length; i < len; i++) {\n                    var part = parts[i];\n                    if (Utils.isString(part)) // link spec\n                    {\n                        if (part.indexOf(\"->\") < 0) {\n                            throw \"The link should be specified as 'a->b'.\";\n                        }\n                        var p = part.split(\"->\");\n                        if (p.length != 2) {\n                            throw \"The link should be specified as 'a->b'.\";\n                        }\n                        previousLink = new Link(p[0], p[1]);\n                        graph.addLink(previousLink);\n                    }\n                    if (Utils.isObject(part)) {\n                        if (!previousLink) {\n                            throw \"Specification found before Link definition.\";\n                        }\n                        kendo.deepExtend(previousLink, part);\n                    }\n                }\n                return graph;\n            },\n\n            /**\n             * Returns a linearized representation of the given Graph.\n             * See also the Graph.Utils.parse method for the inverse operation.\n             */\n            linearize: function(graph, addIds) {\n                if (Utils.isUndefined(graph)) {\n                    throw \"Expected an instance of a Graph object in slot one.\";\n                }\n                if (Utils.isUndefined(addIds)) {\n                    addIds = false;\n                }\n                var lin = [];\n                for (var i = 0, len = graph.links.length; i < len; i++) {\n                    var link = graph.links[i];\n                    lin.push(link.source.id + \"->\" + link.target.id);\n                    if (addIds) {\n                        lin.push({ id: link.id });\n                    }\n                }\n                return lin;\n            },\n\n            /**\n             * The method used by the diagram creation to instantiate a shape.\n             * @param kendoDiagram The Kendo diagram where the diagram will be created.\n             * @param p The position at which to place the shape.\n             * @param shapeDefaults Optional Shape options.\n             * @param id Optional identifier of the shape.\n             * @returns {*}\n             * @private\n             */\n            _addShape: function(kendoDiagram, p, id, shapeDefaults) {\n                if (Utils.isUndefined(p)) {\n                    p = new ExtendedPoint(0, 0);\n                }\n\n                if (Utils.isUndefined(id)) {\n                    id = randomId();\n                }\n\n                shapeDefaults = kendo.deepExtend({\n                    width: 20,\n                    height: 20,\n                    id: id,\n                    radius: 10,\n                    fill: \"#778899\",\n                    data: \"circle\",\n                    undoable: false,\n                    x: p.x,\n                    y: p.y\n                }, shapeDefaults);\n\n                return kendoDiagram.addShape(shapeDefaults);\n            },\n            /**\n             * The method used by the diagram creation to instantiate a connection.\n             * @param diagram he Kendo diagram where the diagram will be created.\n             * @param from The source shape.\n             * @param to The target shape.\n             * @param options Optional Connection options.\n             * @returns {*}\n             * @private\n             */\n            _addConnection: function(diagram, from, to, options) {\n                return diagram.connect(from, to, options);\n            },\n\n            /**\n             * Creates a diagram from the given Graph.\n             * @param diagram The Kendo diagram where the diagram will be created.\n             * @param graph The graph structure defining the diagram.\n             */\n            createDiagramFromGraph: function(diagram, graph, doLayout, randomSize) {\n\n                if (Utils.isUndefined(diagram)) {\n                    throw \"The diagram surface is undefined.\";\n                }\n                if (Utils.isUndefined(graph)) {\n                    throw \"No graph specification defined.\";\n                }\n                if (Utils.isUndefined(doLayout)) {\n                    doLayout = true;\n                }\n                if (Utils.isUndefined(randomSize)) {\n                    randomSize = false;\n                }\n\n                var width = diagram.element.clientWidth || 200;\n                var height = diagram.element.clientHeight || 200;\n                var map = [], node, shape;\n                for (var i = 0, len = graph.nodes.length; i < len; i++) {\n                    node = graph.nodes[i];\n                    var p = node.position;\n                    if (Utils.isUndefined(p)) {\n                        if (Utils.isDefined(node.x) && Utils.isDefined(node.y)) {\n                            p = new ExtendedPoint(node.x, node.y);\n                        }\n                        else {\n                            p = new ExtendedPoint(Utils.randomInteger(10, width - 20), Utils.randomInteger(10, height - 20));\n                        }\n                    }\n                    var opt = {};\n\n                    if (node.id === \"0\") {\n                        /* kendo.deepExtend(opt,\n                         {\n                         fill: \"Orange\",\n                         data: 'circle',\n                         width: 100,\n                         height: 100,\n                         center: new Point(50, 50)\n                         });*/\n                    }\n                    else if (randomSize) {\n                        kendo.deepExtend(opt, {\n                            width: Math.random() * 150 + 20,\n                            height: Math.random() * 80 + 50,\n                            data: 'rectangle',\n                            fill: {\n                                color: \"#778899\"\n                            }\n                        });\n                    }\n\n                    shape = this._addShape(diagram, p, node.id, opt);\n                    //shape.content(node.id);\n\n                    var bounds = shape.bounds();\n                    if (Utils.isDefined(bounds)) {\n                        node.x = bounds.x;\n                        node.y = bounds.y;\n                        node.width = bounds.width;\n                        node.height = bounds.height;\n                    }\n                    map[node.id] = shape;\n                }\n                for (var gli = 0; gli < graph.links.length; gli++) {\n                    var link = graph.links[gli];\n                    var sourceShape = map[link.source.id];\n                    if (Utils.isUndefined(sourceShape)) {\n                        continue;\n                    }\n                    var targetShape = map[link.target.id];\n                    if (Utils.isUndefined(targetShape)) {\n                        continue;\n                    }\n                    this._addConnection(diagram, sourceShape, targetShape, { id: link.id });\n\n                }\n                if (doLayout) {\n                    var l = new diagram.SpringLayout(diagram);\n                    l.layoutGraph(graph, { limitToView: false });\n                    for (var shi = 0; shi < graph.nodes.length; shi++) {\n                        node = graph.nodes[shi];\n                        shape = map[node.id];\n                        shape.bounds(new Rect(node.x, node.y, node.width, node.height));\n                    }\n                }\n            },\n\n            /**\n             * Creates a balanced tree with the specified number of levels and siblings count.\n             * Note that for a balanced tree of level N and sibling count s, counting the root as level zero:\n             *  - NodeCount = (1-s^(N+1))/(1-s)]\n             *  - LinkCount = s.(1-s^N)/(1-s)\n             * @param levels How many levels the tree should have.\n             * @param siblingsCount How many siblings each level should have.\n             * @returns {diagram.Graph}\n             */\n            createBalancedTree: function(levels, siblingsCount) {\n                if (Utils.isUndefined(levels)) {\n                    levels = 3;\n                }\n                if (Utils.isUndefined(siblingsCount)) {\n                    siblingsCount = 3;\n                }\n\n                var g = new diagram.Graph(), counter = -1, lastAdded = [], news;\n                if (levels <= 0 || siblingsCount <= 0) {\n                    return g;\n                }\n                var root = new Node((++counter).toString());\n                g.addNode(root);\n                g.root = root;\n                lastAdded.push(root);\n                for (var i = 0; i < levels; i++) {\n                    news = [];\n                    for (var j = 0; j < lastAdded.length; j++) {\n                        var parent = lastAdded[j];\n                        for (var k = 0; k < siblingsCount; k++) {\n                            var item = new Node((++counter).toString());\n                            g.addLink(parent, item);\n                            news.push(item);\n                        }\n                    }\n                    lastAdded = news;\n                }\n                return g;\n            },\n\n            /**\n             * Creates a balanced tree with the specified number of levels and siblings count.\n             * Note that for a balanced forest of level N, sibling count s and tree count t, counting the root as level zero:\n             *  - NodeCount = t.(1-s^(N+1))/(1-s)]\n             *  - LinkCount = t.s.(1-s^N)/(1-s)\n             * @param levels How many levels the tree should have.\n             * @param siblingsCount How many siblings each level should have.\n             * @returns {diagram.Graph}\n             * @param treeCount The number of trees the forest should have.\n             */\n            createBalancedForest: function(levels, siblingsCount, treeCount) {\n                if (Utils.isUndefined(levels)) {\n                    levels = 3;\n                }\n                if (Utils.isUndefined(siblingsCount)) {\n                    siblingsCount = 3;\n                }\n                if (Utils.isUndefined(treeCount)) {\n                    treeCount = 5;\n                }\n                var g = new diagram.Graph(), counter = -1, lastAdded = [], news;\n                if (levels <= 0 || siblingsCount <= 0 || treeCount <= 0) {\n                    return g;\n                }\n\n                for (var t = 0; t < treeCount; t++) {\n                    var root = new Node((++counter).toString());\n                    g.addNode(root);\n                    lastAdded = [root];\n                    for (var i = 0; i < levels; i++) {\n                        news = [];\n                        for (var j = 0; j < lastAdded.length; j++) {\n                            var parent = lastAdded[j];\n                            for (var k = 0; k < siblingsCount; k++) {\n                                var item = new Node((++counter).toString());\n                                g.addLink(parent, item);\n                                news.push(item);\n                            }\n                        }\n                        lastAdded = news;\n                    }\n                }\n                return g;\n            },\n\n            /**\n             * Creates a random graph (uniform distribution) with the specified amount of nodes.\n             * @param nodeCount The amount of nodes the random graph should have.\n             * @param maxIncidence The maximum allowed degree of the nodes.\n             * @param isTree Whether the return graph should be a tree (default: false).\n             * @returns {diagram.Graph}\n             */\n            createRandomConnectedGraph: function(nodeCount, maxIncidence, isTree) {\n\n                /* Swa's Mathematica export of random Bernoulli graphs\n                 gr[n_,p_]:=Module[{g=RandomGraph[BernoulliGraphDistribution[n,p],VertexLabels->\"Name\",DirectedEdges->True]},\n                 While[Not[ConnectedGraphQ[g]],g=RandomGraph[BernoulliGraphDistribution[n,p],VertexLabels->\"Name\",DirectedEdges->True]];g];\n                 project[a_]:=(\"\\\"\"<>ToString[Part[#,1]]<>\"->\"<>ToString[Part[#,2]]<>\"\\\"\")&     @ a;\n                 export[g_]:=project/@ EdgeList[g]\n                 g = gr[12,.1]\n                 export [g]\n                 */\n\n                if (Utils.isUndefined(nodeCount)) {\n                    nodeCount = 40;\n                }\n                if (Utils.isUndefined(maxIncidence)) {\n                    maxIncidence = 4;\n                }\n                if (Utils.isUndefined(isTree)) {\n                    isTree = false;\n                }\n\n                var g = new diagram.Graph(), counter = -1;\n                if (nodeCount <= 0) {\n                    return g;\n                }\n\n                var root = new Node((++counter).toString());\n                g.addNode(root);\n                if (nodeCount === 1) {\n                    return g;\n                }\n                if (nodeCount > 1) {\n                    // random tree\n                    for (var i = 1; i < nodeCount; i++) {\n                        var poolNode = g.takeRandomNode([], maxIncidence);\n                        if (!poolNode) {\n                            //failed to find one so the graph will have less nodes than specified\n                            break;\n                        }\n                        var newNode = g.addNode(i.toString());\n                        g.addLink(poolNode, newNode);\n                    }\n                    if (!isTree && nodeCount > 1) {\n                        var randomAdditions = Utils.randomInteger(1, nodeCount);\n                        for (var ri = 0; ri < randomAdditions; ri++) {\n                            var n1 = g.takeRandomNode([], maxIncidence);\n                            var n2 = g.takeRandomNode([], maxIncidence);\n                            if (n1 && n2 && !g.areConnected(n1, n2)) {\n                                g.addLink(n1, n2);\n                            }\n                        }\n                    }\n                    return g;\n                }\n            },\n\n            /**\n             * Generates a random diagram.\n             * @param diagram The host diagram.\n             * @param shapeCount The number of shapes the random diagram should contain.\n             * @param maxIncidence The maximum degree the shapes can have.\n             * @param isTree Whether the generated diagram should be a tree\n             * @param layoutType The optional layout type to apply after the diagram is generated.\n             */\n            randomDiagram: function(diagram, shapeCount, maxIncidence, isTree, randomSize) {\n                var g = kendo.dataviz.diagram.Graph.Utils.createRandomConnectedGraph(shapeCount, maxIncidence, isTree);\n                Graph.Utils.createDiagramFromGraph(diagram, g, false, randomSize);\n            }\n        };\n\n        kendo.deepExtend(diagram, {\n            init: function(element) {\n                kendo.init(element, diagram.ui);\n            },\n\n            Point: ExtendedPoint,\n            Intersect: Intersect,\n            Geometry: Geometry,\n            Rect: Rect,\n            Size: Size,\n            RectAlign: RectAlign,\n            Matrix: Matrix,\n            MatrixVector: MatrixVector,\n            normalVariable: normalVariable,\n            randomId: randomId,\n            Dictionary: Dictionary,\n            HashTable: HashTable,\n            Queue: Queue,\n            Set: Set,\n            Node: Node,\n            Link: Link,\n            Graph: Graph,\n            PathDefiner: PathDefiner\n        });\n    })(window.kendo.jQuery);\n\n    (function($, undefined$1) {\n        // Imports ================================================================\n        var kendo = window.kendo,\n            diagram = kendo.dataviz.diagram,\n            Class = kendo.Class,\n            deepExtend = kendo.deepExtend,\n            Point = diagram.Point,\n            Rect = diagram.Rect,\n            Matrix = diagram.Matrix,\n            Utils = diagram.Utils,\n            isNumber = Utils.isNumber,\n            isString = Utils.isString,\n            MatrixVector = diagram.MatrixVector,\n\n            g = kendo.geometry,\n            d = kendo.drawing,\n\n            defined = d.util.defined,\n\n            inArray = $.inArray;\n\n        // Constants ==============================================================\n        var TRANSPARENT = \"transparent\",\n            Markers = {\n                none: \"none\",\n                arrowStart: \"ArrowStart\",\n                filledCircle: \"FilledCircle\",\n                arrowEnd: \"ArrowEnd\"\n            },\n            FULL_CIRCLE_ANGLE = 360,\n            START = \"start\",\n            END = \"end\",\n            WIDTH = \"width\",\n            HEIGHT = \"height\",\n            X = \"x\",\n            Y = \"y\";\n\n        diagram.Markers = Markers;\n\n        function diffNumericOptions(options, fields) {\n            var elementOptions = this.options;\n            var hasChanges = false;\n            var value, field;\n            for (var i = 0; i < fields.length; i++) {\n                field = fields[i];\n                value = options[field];\n                if (isNumber(value) && elementOptions[field] !== value) {\n                    elementOptions[field] = value;\n                    hasChanges = true;\n                }\n            }\n\n            return hasChanges;\n        }\n\n        var Scale = Class.extend({\n            init: function(x, y) {\n                this.x = x;\n                this.y = y;\n            },\n            toMatrix: function() {\n                return Matrix.scaling(this.x, this.y);\n            },\n            toString: function() {\n                return kendo.format(\"scale({0},{1})\", this.x, this.y);\n            },\n            invert: function() {\n                return new Scale(1 / this.x, 1 / this.y);\n            }\n        });\n\n        var Translation = Class.extend({\n            init: function(x, y) {\n                this.x = x;\n                this.y = y;\n            },\n            toMatrixVector: function() {\n                return new MatrixVector(0, 0, 0, 0, this.x, this.y);\n            },\n            toMatrix: function() {\n                return Matrix.translation(this.x, this.y);\n            },\n            toString: function() {\n                return kendo.format(\"translate({0},{1})\", this.x, this.y);\n            },\n            plus: function(delta) {\n                this.x += delta.x;\n                this.y += delta.y;\n            },\n            times: function(factor) {\n                this.x *= factor;\n                this.y *= factor;\n            },\n            length: function() {\n                return Math.sqrt(this.x * this.x + this.y * this.y);\n            },\n            normalize: function() {\n                if (this.Length === 0) {\n                    return;\n                }\n                this.times(1 / this.length());\n            },\n            invert: function() {\n                return new Translation(-this.x, -this.y);\n            }\n        });\n\n        var Rotation = Class.extend({\n            init: function(angle, x, y) {\n                this.x = x || 0;\n                this.y = y || 0;\n                this.angle = angle;\n            },\n            toString: function() {\n                if (this.x && this.y) {\n                    return kendo.format(\"rotate({0},{1},{2})\", this.angle, this.x, this.y);\n                } else {\n                    return kendo.format(\"rotate({0})\", this.angle);\n                }\n            },\n            toMatrix: function() {\n                return Matrix.rotation(this.angle, this.x, this.y); // T*R*T^-1\n            },\n            center: function() {\n                return new Point(this.x, this.y);\n            },\n            invert: function() {\n                return new Rotation(FULL_CIRCLE_ANGLE - this.angle, this.x, this.y);\n            }\n        });\n\n        Rotation.ZERO = new Rotation(0);\n\n        Rotation.create = function(rotation) {\n            return new Rotation(rotation.angle, rotation.x, rotation.y);\n        };\n\n        Rotation.parse = function(str) {\n            var values = str.slice(1, str.length - 1).split(\",\"),\n                angle = values[0],\n                x = values[1],\n                y = values[2];\n            var rotation = new Rotation(angle, x, y);\n            return rotation;\n        };\n\n        var CompositeTransform = Class.extend({\n            init: function(x, y, scaleX, scaleY, angle, center) {\n                this.translate = new Translation(x, y);\n                if (scaleX !== undefined$1 && scaleY !== undefined$1) {\n                    this.scale = new Scale(scaleX, scaleY);\n                }\n                if (angle !== undefined$1) {\n                    this.rotate = center ? new Rotation(angle, center.x, center.y) : new Rotation(angle);\n                }\n            },\n            toString: function() {\n                var toString = function(transform) {\n                    return transform ? transform.toString() : \"\";\n                };\n\n                return toString(this.translate) +\n                    toString(this.rotate) +\n                    toString(this.scale);\n            },\n\n            render: function(visual) {\n                visual._transform = this;\n                visual._renderTransform();\n            },\n\n            toMatrix: function() {\n                var m = Matrix.unit();\n\n                if (this.translate) {\n                    m = m.times(this.translate.toMatrix());\n                }\n                if (this.rotate) {\n                    m = m.times(this.rotate.toMatrix());\n                }\n                if (this.scale) {\n                    m = m.times(this.scale.toMatrix());\n                }\n                return m;\n            },\n            invert: function() {\n                var rotate = this.rotate ? this.rotate.invert() : undefined$1,\n                    rotateMatrix = rotate ? rotate.toMatrix() : Matrix.unit(),\n                    scale = this.scale ? this.scale.invert() : undefined$1,\n                    scaleMatrix = scale ? scale.toMatrix() : Matrix.unit();\n\n                var translatePoint = new Point(-this.translate.x, -this.translate.y);\n                translatePoint = rotateMatrix.times(scaleMatrix).apply(translatePoint);\n                var translate = new Translation(translatePoint.x, translatePoint.y);\n\n                var transform = new CompositeTransform();\n                transform.translate = translate;\n                transform.rotate = rotate;\n                transform.scale = scale;\n\n                return transform;\n            }\n        });\n\n        var AutoSizeableMixin = {\n            _setScale: function() {\n                var options = this.options;\n                var originWidth = this._originWidth;\n                var originHeight = this._originHeight;\n                var scaleX = options.width / originWidth;\n                var scaleY = options.height / originHeight;\n\n                if (!isNumber(scaleX)) {\n                    scaleX = 1;\n                }\n                if (!isNumber(scaleY)) {\n                    scaleY = 1;\n                }\n\n                this._transform.scale = new Scale(scaleX, scaleY);\n            },\n\n            _setTranslate: function() {\n                var options = this.options;\n                var x = options.x || 0;\n                var y = options.y || 0;\n                this._transform.translate = new Translation(x, y);\n            },\n\n            _initSize: function() {\n                var options = this.options;\n                var transform = false;\n                if (options.autoSize !== false && (defined(options.width) || defined(options.height))) {\n                    this._measure(true);\n                    this._setScale();\n                    transform = true;\n                }\n\n                if (defined(options.x) || defined(options.y)) {\n                    this._setTranslate();\n                    transform = true;\n                }\n\n                if (transform) {\n                    this._renderTransform();\n                }\n            },\n\n            _updateSize: function(options) {\n                var update = false;\n\n                if (this.options.autoSize !== false && this._diffNumericOptions(options, [WIDTH, HEIGHT])) {\n                    update = true;\n                    this._measure(true);\n                    this._setScale();\n                }\n\n                if (this._diffNumericOptions(options, [X, Y])) {\n                    update = true;\n                    this._setTranslate();\n                }\n\n                if (update) {\n                    this._renderTransform();\n                }\n\n                return update;\n            }\n        };\n\n        var Element = Class.extend({\n            init: function(options) {\n                var element = this;\n                element.options = deepExtend({}, element.options, options);\n                element.id = element.options.id;\n                element._originSize = Rect.empty();\n                element._transform = new CompositeTransform();\n            },\n\n            visible: function(value) {\n                return this.drawingContainer().visible(value);\n            },\n\n            redraw: function(options) {\n                if (options && options.id) {\n                     this.id = options.id;\n                }\n            },\n\n            position: function(x, y) {\n                var options = this.options;\n                if (!defined(x)) {\n                   return new Point(options.x, options.y);\n                }\n\n                if (defined(y)) {\n                    options.x = x;\n                    options.y = y;\n                } else if (x instanceof Point) {\n                    options.x = x.x;\n                    options.y = x.y;\n                }\n\n                this._transform.translate = new Translation(options.x, options.y);\n                this._renderTransform();\n            },\n\n            rotate: function(angle, center) {\n                if (defined(angle)) {\n                    this._transform.rotate = new Rotation(angle, center.x, center.y);\n                    this._renderTransform();\n                }\n                return this._transform.rotate || Rotation.ZERO;\n            },\n\n            drawingContainer: function() {\n                return this.drawingElement;\n            },\n\n            _renderTransform: function() {\n                var matrix = this._transform.toMatrix();\n                this.drawingContainer().transform(new g.Matrix(matrix.a, matrix.b, matrix.c, matrix.d, matrix.e, matrix.f));\n            },\n\n            _hover: function() {},\n\n            _diffNumericOptions: diffNumericOptions,\n\n            _measure: function(force) {\n                var rect;\n                if (!this._measured || force) {\n                    var box = this._boundingBox() || new g.Rect();\n                    var startPoint = box.topLeft();\n                    rect = new Rect(startPoint.x, startPoint.y, box.width(), box.height());\n                    this._originSize = rect;\n                    this._originWidth = rect.width;\n                    this._originHeight = rect.height;\n                    this._measured = true;\n                } else {\n                    rect = this._originSize;\n                }\n                return rect;\n            },\n\n            _boundingBox: function() {\n                return this.drawingElement.rawBBox();\n            }\n        });\n\n        var VisualBase = Element.extend({\n            init: function(options) {\n                Element.fn.init.call(this, options);\n\n                options = this.options;\n                options.fill = normalizeDrawingOptions(options.fill);\n                options.stroke = normalizeDrawingOptions(options.stroke);\n            },\n\n            options: {\n                stroke: {\n                    color: \"gray\",\n                    width: 1\n                },\n                fill: {\n                    color: TRANSPARENT\n                }\n            },\n\n            fill: function(color, opacity) {\n                this._fill({\n                    color: getColor(color),\n                    opacity: opacity\n                });\n            },\n\n            stroke: function(color, width, opacity) {\n                this._stroke({\n                    color: getColor(color),\n                    width: width,\n                    opacity: opacity\n                });\n            },\n\n            redraw: function(options) {\n                if (options) {\n                    var stroke = options.stroke;\n                    var fill = options.fill;\n                    if (stroke) {\n                        this._stroke(normalizeDrawingOptions(stroke));\n                    }\n                    if (fill) {\n                        this._fill(normalizeDrawingOptions(fill));\n                    }\n\n                    Element.fn.redraw.call(this, options);\n                }\n            },\n\n            _hover: function(show) {\n                var drawingElement = this.drawingElement;\n                var options = this.options;\n                var hover = options.hover;\n\n                if (hover && hover.fill) {\n                    var fill = show ? normalizeDrawingOptions(hover.fill) : options.fill;\n                    drawingElement.fill(fill.color, fill.opacity);\n                }\n            },\n\n            _stroke: function(strokeOptions) {\n                var options = this.options;\n                deepExtend(options, {\n                    stroke: strokeOptions\n                });\n\n                strokeOptions = options.stroke;\n\n                var stroke = null;\n                if (strokeOptions.width > 0) {\n                    stroke = {\n                        color: strokeOptions.color,\n                        width: strokeOptions.width,\n                        opacity: strokeOptions.opacity,\n                        dashType: strokeOptions.dashType\n                    };\n                }\n\n                this.drawingElement.options.set(\"stroke\", stroke);\n            },\n\n            _fill: function(fillOptions) {\n                var options = this.options;\n                deepExtend(options, {\n                    fill: fillOptions || {}\n                });\n                var fill = options.fill;\n\n                if (fill.gradient) {\n                    var gradient = fill.gradient;\n                    var GradientClass = (gradient.type === \"radial\" ? d.RadialGradient : d.LinearGradient);\n                    this.drawingElement.fill(new GradientClass(gradient));\n                } else {\n                    this.drawingElement.fill(fill.color, fill.opacity);\n                }\n            }\n        });\n\n        var TextBlock = VisualBase.extend({\n            init: function(options) {\n                options = this._textColor(options);\n                VisualBase.fn.init.call(this, options);\n\n                this._font();\n                this._initText();\n                this._initSize();\n            },\n\n            options: {\n                fontSize: 15,\n                fontFamily: \"sans-serif\",\n                stroke: {\n                    width: 0\n                },\n                fill: {\n                    color: \"black\"\n                },\n                autoSize: true\n            },\n\n            _initText: function() {\n                var options = this.options;\n\n                this.drawingElement = new d.Text(defined(options.text) ? options.text : \"\", new g.Point(), {\n                    font: options.font\n                });\n\n                this._fill();\n                this._stroke();\n            },\n\n            _textColor: function(options) {\n                if (options && options.color) {\n                    options = deepExtend({}, options, {\n                        fill: {\n                            color: options.color\n                        }\n                    });\n                }\n                return options;\n            },\n\n            _font: function() {\n                var options = this.options;\n                if (options.fontFamily && defined(options.fontSize)) {\n                    var fontOptions = [];\n\n                    if (options.fontStyle) {\n                        fontOptions.push(options.fontStyle);\n                    }\n\n                    if (options.fontWeight) {\n                        fontOptions.push(options.fontWeight);\n                    }\n\n                    fontOptions.push(options.fontSize + (isNumber(options.fontSize) ? \"px\" : \"\"));\n                    fontOptions.push(options.fontFamily);\n\n                    options.font = fontOptions.join(\" \");\n                } else {\n                    delete options.font;\n                }\n            },\n\n            content: function(text) {\n                return this.drawingElement.content(text);\n            },\n\n            redraw: function(options) {\n                if (options) {\n                    var sizeChanged = false;\n                    var textOptions = this.options;\n\n                    options = this._textColor(options);\n\n                    VisualBase.fn.redraw.call(this, options);\n\n                    if (options.fontFamily || defined(options.fontSize) || options.fontStyle || options.fontWeight) {\n                        deepExtend(textOptions, {\n                            fontFamily: options.fontFamily,\n                            fontSize: options.fontSize,\n                            fontStyle: options.fontStyle,\n                            fontWeight: options.fontWeight\n                        });\n                        this._font();\n                        this.drawingElement.options.set(\"font\", textOptions.font);\n                        sizeChanged = true;\n                    }\n\n                    if (options.text) {\n                        this.content(options.text);\n                        sizeChanged = true;\n                    }\n\n                    if (!this._updateSize(options) && sizeChanged) {\n                        this._initSize();\n                    }\n                }\n            }\n        });\n\n        deepExtend(TextBlock.fn, AutoSizeableMixin);\n\n        var Rectangle = VisualBase.extend({\n            init: function(options) {\n                VisualBase.fn.init.call(this, options);\n                this._initPath();\n                this._setPosition();\n            },\n\n            _setPosition: function() {\n                var options = this.options;\n                var x = options.x;\n                var y = options.y;\n                if (defined(x) || defined(y)) {\n                    this.position(x || 0, y || 0);\n                }\n            },\n\n            redraw: function(options) {\n                if (options) {\n                    VisualBase.fn.redraw.call(this, options);\n                    if (this._diffNumericOptions(options, [WIDTH, HEIGHT])) {\n                        this._drawPath();\n                    }\n                    if (this._diffNumericOptions(options, [X, Y])) {\n                        this._setPosition();\n                    }\n                }\n            },\n\n            _initPath: function() {\n                var options = this.options;\n                this.drawingElement = new d.Path({\n                    stroke: options.stroke,\n                    closed: true\n                });\n\n                this._fill();\n                this._drawPath();\n            },\n\n            _drawPath: function() {\n                var drawingElement = this.drawingElement;\n                var sizeOptions = sizeOptionsOrDefault(this.options);\n                var width = sizeOptions.width;\n                var height = sizeOptions.height;\n\n                drawingElement.segments.elements([\n                    createSegment(0, 0),\n                    createSegment(width, 0),\n                    createSegment(width, height),\n                    createSegment(0, height)\n                ]);\n            }\n        });\n\n        var MarkerBase = VisualBase.extend({\n            init: function(options) {\n               VisualBase.fn.init.call(this, options);\n               var anchor = this.options.anchor;\n               this.anchor = new g.Point(anchor.x, anchor.y);\n               this.createElement();\n            },\n\n            options: {\n               stroke: {\n                    color: TRANSPARENT,\n                    width: 0\n               },\n               fill: {\n                    color: \"black\"\n               }\n            },\n\n            _transformToPath: function(point, path) {\n                var transform = path.transform();\n                if (point && transform) {\n                    point = point.transformCopy(transform);\n                }\n                return point;\n            },\n\n            redraw: function(options) {\n                if (options) {\n                    if (options.position) {\n                        this.options.position = options.position;\n                    }\n\n                    VisualBase.fn.redraw.call(this, options);\n                }\n            }\n        });\n\n        var CircleMarker = MarkerBase.extend({\n            options: {\n                radius: 4,\n                anchor: {\n                    x: 0,\n                    y: 0\n                }\n            },\n\n            createElement: function() {\n                var options = this.options;\n                this.drawingElement = new d.Circle(new g.Circle(this.anchor, options.radius), {\n                    fill: options.fill,\n                    stroke: options.stroke\n                });\n            },\n\n            positionMarker: function(path) {\n                var options = this.options;\n                var position = options.position;\n                var segments = path.segments;\n                var targetSegment;\n                var point;\n\n                if (position == START) {\n                    targetSegment = segments[0];\n                } else {\n                    targetSegment = segments[segments.length - 1];\n                }\n                if (targetSegment) {\n                    point = this._transformToPath(targetSegment.anchor(), path);\n                    this.drawingElement.transform(g.transform().translate(point.x, point.y));\n                }\n            }\n        });\n\n        var ArrowMarker = MarkerBase.extend({\n            options: {\n                path: \"M 0 0 L 10 5 L 0 10 L 3 5 z\" ,\n                anchor: {\n                    x: 10,\n                    y: 5\n                }\n            },\n\n            createElement: function() {\n                var options = this.options;\n                this.drawingElement = d.Path.parse(options.path, {\n                    fill: options.fill,\n                    stroke: options.stroke\n                });\n            },\n\n            positionMarker: function(path) {\n                var points = this._linePoints(path);\n                var start = points.start;\n                var end = points.end;\n                var transform = g.transform();\n                if (start) {\n                    transform.rotate(lineAngle(start, end), end);\n                }\n\n                if (end) {\n                    var anchor = this.anchor;\n                    var translate = end.clone().translate(-anchor.x, -anchor.y);\n                    transform.translate(translate.x, translate.y);\n                }\n                this.drawingElement.transform(transform);\n            },\n\n            _linePoints: function(path) {\n                var options = this.options;\n                var segments = path.segments;\n                var startPoint, endPoint, targetSegment;\n                if (options.position == START) {\n                    targetSegment = segments[0];\n                    if (targetSegment) {\n                        endPoint = targetSegment.anchor();\n                        startPoint = targetSegment.controlOut();\n                        var nextSegment = segments[1];\n                        if (!startPoint && nextSegment) {\n                            startPoint = nextSegment.anchor();\n                        }\n                    }\n                } else {\n                    targetSegment = segments[segments.length - 1];\n                    if (targetSegment) {\n                        endPoint = targetSegment.anchor();\n                        startPoint = targetSegment.controlIn();\n                        var prevSegment = segments[segments.length - 2];\n                        if (!startPoint && prevSegment) {\n                            startPoint = prevSegment.anchor();\n                        }\n                    }\n                }\n                if (endPoint) {\n                    return {\n                        start: this._transformToPath(startPoint, path),\n                        end: this._transformToPath(endPoint, path)\n                    };\n                }\n            }\n        });\n\n        var MarkerPathMixin = {\n            _getPath: function(position) {\n                var path = this.drawingElement;\n                if (path instanceof d.MultiPath) {\n                    if (position == START) {\n                        path = path.paths[0];\n                    } else {\n                        path = path.paths[path.paths.length - 1];\n                    }\n                }\n                if (path && path.segments.length) {\n                    return path;\n                }\n            },\n\n            _normalizeMarkerOptions: function(options) {\n                var startCap = options.startCap;\n                var endCap = options.endCap;\n\n                if (isString(startCap)) {\n                    options.startCap = {\n                        type: startCap\n                    };\n                }\n\n                if (isString(endCap)) {\n                    options.endCap = {\n                        type: endCap\n                    };\n                }\n            },\n\n            _removeMarker: function(position) {\n                var marker = this._markers[position];\n                if (marker) {\n                    this.drawingContainer().remove(marker.drawingElement);\n                    delete this._markers[position];\n                }\n            },\n\n            _createMarkers: function() {\n                var options = this.options;\n                this._normalizeMarkerOptions(options);\n\n                this._markers = {};\n                this._markers[START] = this._createMarker(options.startCap, START);\n                this._markers[END] = this._createMarker(options.endCap, END);\n            },\n\n            _createMarker: function(options, position) {\n                var type = (options || {}).type;\n                var path = this._getPath(position);\n                var markerType, marker;\n                if (!path) {\n                    this._removeMarker(position);\n                    return;\n                }\n\n                if (type == Markers.filledCircle) {\n                    markerType = CircleMarker;\n                } else if (type == Markers.arrowStart || type == Markers.arrowEnd) {\n                    markerType = ArrowMarker;\n                } else {\n                    this._removeMarker(position);\n                }\n                if (markerType) {\n                    marker = new markerType(deepExtend({}, options, {\n                        position: position\n                    }));\n                    marker.positionMarker(path);\n                    this.drawingContainer().append(marker.drawingElement);\n\n                    return marker;\n                }\n            },\n\n            _positionMarker: function(position) {\n                var marker = this._markers[position];\n\n                if (marker) {\n                    var path = this._getPath(position);\n                    if (path) {\n                        marker.positionMarker(path);\n                    } else {\n                        this._removeMarker(position);\n                    }\n                }\n            },\n\n            _capMap: {\n                start: \"startCap\",\n                end: \"endCap\"\n            },\n\n            _redrawMarker: function(pathChange, position, options) {\n                this._normalizeMarkerOptions(options);\n\n                var pathOptions = this.options;\n                var cap = this._capMap[position];\n                var pathCapType = (pathOptions[cap] || {}).type;\n                var optionsCap = options[cap];\n                var created = false;\n                if (optionsCap) {\n                    pathOptions[cap] = deepExtend({}, pathOptions[cap], optionsCap);\n                    if (optionsCap.type && pathCapType != optionsCap.type) {\n                        this._removeMarker(position);\n                        this._markers[position] = this._createMarker(pathOptions[cap], position);\n                        created = true;\n                    } else if (this._markers[position]) {\n                       this._markers[position].redraw(optionsCap);\n                    }\n                } else if (pathChange && !this._markers[position] && pathOptions[cap]) {\n                    this._markers[position] = this._createMarker(pathOptions[cap], position);\n                    created = true;\n                }\n                return created;\n            },\n\n            _redrawMarkers: function(pathChange, options) {\n                if (!this._redrawMarker(pathChange, START, options) && pathChange) {\n                    this._positionMarker(START);\n                }\n                if (!this._redrawMarker(pathChange, END, options) && pathChange) {\n                    this._positionMarker(END);\n                }\n            }\n        };\n\n        var Path = VisualBase.extend({\n            init: function(options) {\n                VisualBase.fn.init.call(this, options);\n                this.container = new d.Group();\n                this._createElements();\n                this._initSize();\n            },\n\n            options: {\n                autoSize: true\n            },\n\n            drawingContainer: function() {\n                return this.container;\n            },\n\n            data: function(value) {\n                var options = this.options;\n                if (value) {\n                    if (options.data != value) {\n                       options.data = value;\n                       this._setData(value);\n                       this._initSize();\n                       this._redrawMarkers(true, {});\n                    }\n                } else {\n                    return options.data;\n                }\n            },\n\n            redraw: function(options) {\n                if (options) {\n                    VisualBase.fn.redraw.call(this, options);\n\n                    var pathOptions = this.options;\n                    var data = options.data;\n\n                    if (defined(data) && pathOptions.data != data) {\n                        pathOptions.data = data;\n                        this._setData(data);\n                        if (!this._updateSize(options)) {\n                            this._initSize();\n                        }\n                        this._redrawMarkers(true, options);\n                    } else {\n                        this._updateSize(options);\n                        this._redrawMarkers(false, options);\n                    }\n                }\n            },\n\n            _createElements: function() {\n                var options = this.options;\n\n                this.drawingElement = d.Path.parse(options.data || \"\", {\n                    stroke: options.stroke\n                });\n\n                this._fill();\n                this.container.append(this.drawingElement);\n                this._createMarkers();\n            },\n\n            _setData: function(data) {\n                var drawingElement = this.drawingElement;\n                var multipath = d.Path.parse(data || \"\");\n                var paths = multipath.paths.slice(0);\n                multipath.paths.elements([]);\n                drawingElement.paths.elements(paths);\n            }\n        });\n\n        deepExtend(Path.fn, AutoSizeableMixin);\n        deepExtend(Path.fn, MarkerPathMixin);\n\n        var Line = VisualBase.extend({\n            init: function(options) {\n                VisualBase.fn.init.call(this, options);\n                this.container = new d.Group();\n                this._initPath();\n                this._createMarkers();\n            },\n\n            drawingContainer: function() {\n                return this.container;\n            },\n\n            redraw: function(options) {\n                if (options) {\n                    options = options || {};\n                    var from = options.from;\n                    var to = options.to;\n                    if (from) {\n                        this.options.from = from;\n                    }\n\n                    if (to) {\n                        this.options.to = to;\n                    }\n\n                    if (from || to) {\n                        this._drawPath();\n                        this._redrawMarkers(true, options);\n                    } else {\n                        this._redrawMarkers(false, options);\n                    }\n\n                    VisualBase.fn.redraw.call(this, options);\n                }\n            },\n\n            _initPath: function() {\n                var options = this.options;\n                var drawingElement = this.drawingElement = new d.Path({\n                    stroke: options.stroke\n                });\n\n                this._fill();\n                this._drawPath();\n                this.container.append(drawingElement);\n            },\n\n            _drawPath: function() {\n                var options = this.options;\n                var drawingElement = this.drawingElement;\n                var from = options.from || new Point();\n                var to = options.to || new Point();\n\n                drawingElement.segments.elements([\n                    createSegment(from.x, from.y),\n                    createSegment(to.x, to.y)\n                ]);\n            }\n        });\n\n        deepExtend(Line.fn, MarkerPathMixin);\n\n        var Polyline = VisualBase.extend({\n            init: function(options) {\n                VisualBase.fn.init.call(this, options);\n                this.container = new d.Group();\n                this._initPath();\n                this._createMarkers();\n            },\n\n            drawingContainer: function() {\n                return this.container;\n            },\n\n            points: function(points) {\n                var options = this.options;\n                if (points) {\n                    options.points = points;\n                    this._updatePath();\n                } else {\n                    return options.points;\n                }\n            },\n\n            redraw: function(options) {\n                if (options) {\n                    var points = options.points;\n                    VisualBase.fn.redraw.call(this, options);\n\n                    if (points && this._pointsDiffer(points)) {\n                        this.points(points);\n                        this._redrawMarkers(true, options);\n                    } else {\n                        this._redrawMarkers(false, options);\n                    }\n                }\n            },\n\n            _initPath: function() {\n                var options = this.options;\n                this.drawingElement = new d.Path({\n                    stroke: options.stroke\n                });\n\n                this._fill();\n                this.container.append(this.drawingElement);\n\n                if (options.points) {\n                    this._updatePath();\n                }\n            },\n\n            _pointsDiffer: function(points) {\n                var currentPoints = this.options.points;\n                var differ = currentPoints.length !== points.length;\n                if (!differ) {\n                    for (var i = 0; i < points.length; i++) {\n                        if (currentPoints[i].x !== points[i].x || currentPoints[i].y !== points[i].y) {\n                            differ = true;\n                            break;\n                        }\n                    }\n                }\n\n                return differ;\n            },\n\n            _updatePath: function() {\n                var drawingElement = this.drawingElement;\n                var options = this.options;\n                var points = options.points;\n                var segments = [];\n                var point;\n                for (var i = 0; i < points.length; i++) {\n                    point = points[i];\n                    segments.push(createSegment(point.x, point.y));\n                }\n\n                drawingElement.segments.elements(segments);\n            },\n\n            options: {\n                points: []\n            }\n        });\n\n        deepExtend(Polyline.fn, MarkerPathMixin);\n\n        var Image = Element.extend({\n            init: function(options) {\n                Element.fn.init.call(this, options);\n\n                this._initImage();\n            },\n\n            redraw: function(options) {\n                if (options) {\n                    if (options.source) {\n                        this.drawingElement.src(options.source);\n                    }\n\n                    if (this._diffNumericOptions(options, [WIDTH, HEIGHT, X, Y])) {\n                        this.drawingElement.rect(this._rect());\n                    }\n\n                    Element.fn.redraw.call(this, options);\n                }\n            },\n\n            _initImage: function() {\n                var options = this.options;\n                var rect = this._rect();\n\n                this.drawingElement = new d.Image(options.source, rect, {});\n            },\n\n            _rect: function() {\n                var sizeOptions = sizeOptionsOrDefault(this.options);\n                var origin = new g.Point(sizeOptions.x, sizeOptions.y);\n                var size = new g.Size(sizeOptions.width, sizeOptions.height);\n\n                return new g.Rect(origin, size);\n            }\n        });\n\n        var Group = Element.extend({\n            init: function(options) {\n                this.children = [];\n                Element.fn.init.call(this, options);\n                this.drawingElement = new d.Group();\n                this._initSize();\n            },\n\n            options: {\n                autoSize: false\n            },\n\n            append: function(visual) {\n                this.drawingElement.append(visual.drawingContainer());\n                this.children.push(visual);\n                this._childrenChange = true;\n            },\n\n            remove: function(visual) {\n                if (this._remove(visual)) {\n                    this._childrenChange = true;\n                }\n            },\n\n            _remove: function(visual) {\n                var index = inArray(visual, this.children);\n                if (index >= 0) {\n                    this.drawingElement.removeAt(index);\n                    this.children.splice(index, 1);\n                    return true;\n                }\n            },\n\n            clear: function() {\n                this.drawingElement.clear();\n                this.children = [];\n                this._childrenChange = true;\n            },\n\n            toFront: function(visuals) {\n                var visual;\n\n                for (var i = 0; i < visuals.length; i++) {\n                    visual = visuals[i];\n                    if (this._remove(visual)) {\n                        this.append(visual);\n                    }\n                }\n            },\n            //TO DO: add drawing group support for moving and inserting children\n            toBack: function(visuals) {\n                this._reorderChildren(visuals, 0);\n            },\n\n            toIndex: function(visuals, indices) {\n                this._reorderChildren(visuals, indices);\n            },\n\n            _reorderChildren: function(visuals, indices) {\n                var group = this.drawingElement;\n                var drawingChildren = group.children.slice(0);\n                var children = this.children;\n                var fixedPosition = isNumber(indices);\n                var i, index, toIndex, drawingElement, visual;\n\n                for (i = 0; i < visuals.length; i++) {\n                    visual = visuals[i];\n                    drawingElement = visual.drawingContainer();\n\n                    index = inArray(visual, children);\n                    if (index >= 0) {\n                        drawingChildren.splice(index, 1);\n                        children.splice(index, 1);\n\n                        toIndex = fixedPosition ? indices : indices[i];\n\n                        drawingChildren.splice(toIndex, 0, drawingElement);\n                        children.splice(toIndex, 0, visual);\n                    }\n                }\n                group.clear();\n                group.append.apply(group, drawingChildren);\n            },\n\n            redraw: function(options) {\n                if (options) {\n                    if (this._childrenChange) {\n                        this._childrenChange = false;\n                        if (!this._updateSize(options)) {\n                            this._initSize();\n                        }\n                    } else {\n                        this._updateSize(options);\n                    }\n\n                    Element.fn.redraw.call(this, options);\n                }\n            },\n\n            _boundingBox: function() {\n                var children = this.children;\n                var boundingBox;\n                var visual, childBoundingBox;\n                for (var i = 0; i < children.length; i++) {\n                    visual = children[i];\n                    if (visual.visible() && visual._includeInBBox !== false) {\n                        childBoundingBox = visual.drawingContainer().clippedBBox(null);\n                        if (childBoundingBox) {\n                            if (boundingBox) {\n                                boundingBox = g.Rect.union(boundingBox, childBoundingBox);\n                            } else {\n                                boundingBox = childBoundingBox;\n                            }\n                        }\n                    }\n                }\n\n                return boundingBox;\n            }\n        });\n\n        deepExtend(Group.fn, AutoSizeableMixin);\n\n        var Layout = Group.extend({\n            init: function(rect, options) {\n                this.children = [];\n                Element.fn.init.call(this, options);\n                this.drawingElement = new d.Layout(toDrawingRect(rect), options);\n                this._initSize();\n            },\n\n            rect: function(rect) {\n                if (rect) {\n                    this.drawingElement.rect(toDrawingRect(rect));\n                } else {\n                    var drawingRect = this.drawingElement.rect();\n                    if (drawingRect) {\n                        return new Rect(drawingRect.origin.x, drawingRect.origin.y, drawingRect.size.width, drawingRect.size.height);\n                    }\n                }\n            },\n\n            reflow: function() {\n                this.drawingElement.reflow();\n            },\n\n            redraw: function(options) {\n                kendo.deepExtend(this.drawingElement.options, options);\n                Group.fn.redraw.call(this, options);\n            }\n        });\n\n        var Circle = VisualBase.extend({\n            init: function(options) {\n                VisualBase.fn.init.call(this, options);\n                this._initCircle();\n                this._initSize();\n            },\n\n            redraw: function(options) {\n                if (options) {\n                    var circleOptions = this.options;\n\n                    if (options.center) {\n                        deepExtend(circleOptions, {\n                            center: options.center\n                        });\n                        this._center.move(circleOptions.center.x, circleOptions.center.y);\n                    }\n\n                    if (this._diffNumericOptions(options, [\"radius\"])) {\n                        this._circle.setRadius(circleOptions.radius);\n                    }\n\n                    this._updateSize(options);\n\n                    VisualBase.fn.redraw.call(this, options);\n                }\n            },\n\n            _initCircle: function() {\n                var options = this.options;\n                var width = options.width;\n                var height = options.height;\n                var radius = options.radius;\n                if (!defined(radius)) {\n                    if (!defined(width)) {\n                        width = height;\n                    }\n                    if (!defined(height)) {\n                        height = width;\n                    }\n                    options.radius = radius = Math.min(width, height) / 2;\n                }\n\n                var center = options.center || { x: radius, y: radius };\n                this._center = new g.Point(center.x, center.y);\n                this._circle = new g.Circle(this._center, radius);\n                this.drawingElement = new d.Circle(this._circle, {\n                    stroke: options.stroke\n                });\n\n                this._fill();\n            }\n        });\n        deepExtend(Circle.fn, AutoSizeableMixin);\n\n        var Canvas = Class.extend({\n            init: function(element, options) {\n                options = options || {};\n                this.element = element;\n                this.surface = d.Surface.create(element, options);\n                if (kendo.isFunction(this.surface.translate)) {\n                    this.translate = this._translate;\n                }\n\n                this.drawingElement = new d.Group();\n                this._viewBox = new Rect(0, 0, options.width, options.height);\n                this.size(this._viewBox);\n            },\n\n            bounds: function() {\n                var box = this.drawingElement.clippedBBox();\n                return new Rect(0, 0, box.width(), box.height());\n            },\n\n            size: function(size) {\n                var viewBox = this._viewBox;\n                if (defined(size)) {\n                    viewBox.width = size.width;\n                    viewBox.height = size.height;\n                    this.surface.setSize(size);\n                }\n                return {\n                    width: viewBox.width,\n                    height: viewBox.height\n                };\n            },\n\n            _translate: function(x, y) {\n                var viewBox = this._viewBox;\n                if (defined(x) && defined(y)) {\n                    viewBox.x = x;\n                    viewBox.y = y;\n                    this.surface.translate({ x: x, y: y });\n                }\n                return {\n                    x: viewBox.x,\n                    y: viewBox.y\n                };\n            },\n\n            draw: function() {\n                this.surface.draw(this.drawingElement);\n            },\n\n            append: function(visual) {\n                this.drawingElement.append(visual.drawingContainer());\n                return this;\n            },\n\n            remove: function(visual) {\n                this.drawingElement.remove(visual.drawingContainer());\n            },\n\n            insertBefore: function() {\n\n            },\n\n            clear: function() {\n                this.drawingElement.clear();\n            },\n\n            destroy: function(clearHtml) {\n                this.surface.destroy();\n                if (clearHtml) {\n                    $(this.element).remove();\n                }\n            }\n        });\n\n        // Helper functions ===========================================\n\n        function sizeOptionsOrDefault(options) {\n            return {\n                x: options.x || 0,\n                y: options.y || 0,\n                width: options.width || 0,\n                height: options.height || 0\n            };\n        }\n\n        function normalizeDrawingOptions(options) {\n            if (options) {\n                var drawingOptions = options;\n\n                if (isString(drawingOptions)) {\n                    drawingOptions = {\n                        color: drawingOptions\n                    };\n                }\n\n                if (drawingOptions.color) {\n                    drawingOptions.color = getColor(drawingOptions.color);\n                }\n                return drawingOptions;\n            }\n        }\n\n        function getColor(value) {\n            var color;\n            if (value != TRANSPARENT) {\n                color = new d.Color(value).toHex();\n            } else {\n                color = value;\n            }\n            return color;\n        }\n\n        function lineAngle(p1, p2) {\n            var xDiff = p2.x - p1.x;\n            var yDiff = p2.y - p1.y;\n            var angle = d.util.deg(Math.atan2(yDiff, xDiff));\n            return angle;\n        }\n\n        function createSegment(x, y) {\n            return new g.Segment(new g.Point(x, y));\n        }\n\n        function toDrawingRect(rect) {\n            if (rect) {\n                return new g.Rect([rect.x, rect.y], [rect.width, rect.height]);\n            }\n        }\n\n        // Exports ================================================================\n        kendo.deepExtend(diagram, {\n            init: function(element) {\n                kendo.init(element, diagram.ui);\n            },\n            diffNumericOptions: diffNumericOptions,\n            Element: Element,\n            Scale: Scale,\n            Translation: Translation,\n            Rotation: Rotation,\n            Circle: Circle,\n            Group: Group,\n            Rectangle: Rectangle,\n            Canvas: Canvas,\n            Path: Path,\n            Layout: Layout,\n            Line: Line,\n            MarkerBase: MarkerBase,\n            ArrowMarker: ArrowMarker,\n            CircleMarker: CircleMarker,\n            Polyline: Polyline,\n            CompositeTransform: CompositeTransform,\n            TextBlock: TextBlock,\n            Image: Image,\n            VisualBase: VisualBase\n        });\n    })(window.kendo.jQuery);\n\n    (function($, undefined$1) {\n            // Imports ================================================================\n            var kendo = window.kendo,\n                dataviz = kendo.dataviz,\n                diagram = dataviz.diagram,\n                Class = kendo.Class,\n                Group = diagram.Group,\n                Rect = diagram.Rect,\n                Rectangle = diagram.Rectangle,\n                Utils = diagram.Utils,\n                isUndefined = Utils.isUndefined,\n                Point = diagram.Point,\n                Circle = diagram.Circle,\n                Ticker = diagram.Ticker,\n                deepExtend = kendo.deepExtend,\n                Movable = kendo.ui.Movable,\n                util = kendo.drawing.util,\n                defined = util.defined,\n                inArray = $.inArray;\n\n            // Constants ==============================================================\n            var Cursors = {\n                    arrow: \"default\",\n                    grip: \"pointer\",\n                    cross: \"pointer\",\n                    add: \"pointer\",\n                    move: \"move\",\n                    select: \"pointer\",\n                    south: \"s-resize\",\n                    east: \"e-resize\",\n                    west: \"w-resize\",\n                    north: \"n-resize\",\n                    rowresize: \"row-resize\",\n                    colresize: \"col-resize\"\n                },\n                HIT_TEST_DISTANCE = 10,\n                AUTO = \"Auto\",\n                TOP = \"Top\",\n                RIGHT = \"Right\",\n                LEFT = \"Left\",\n                BOTTOM = \"Bottom\",\n                DEFAULT_SNAP_SIZE = 10,\n                DEFAULT_SNAP_ANGLE = 10,\n                DRAG_START = \"dragStart\",\n                DRAG = \"drag\",\n                DRAG_END = \"dragEnd\",\n                ITEMROTATE = \"itemRotate\",\n                ITEMBOUNDSCHANGE = \"itemBoundsChange\",\n                MIN_SNAP_SIZE = 5,\n                MIN_SNAP_ANGLE = 5,\n                MOUSE_ENTER = \"mouseEnter\",\n                MOUSE_LEAVE = \"mouseLeave\",\n                ZOOM_START = \"zoomStart\",\n                ZOOM_END = \"zoomEnd\",\n                SCROLL_MIN = -20000,\n                SCROLL_MAX = 20000,\n                FRICTION = 0.90,\n                FRICTION_MOBILE = 0.93,\n                VELOCITY_MULTIPLIER = 5,\n                TRANSPARENT = \"transparent\",\n                PAN = \"pan\",\n                ROTATED = \"rotated\",\n                SOURCE = \"source\",\n                TARGET = \"target\",\n                HANDLE_NAMES = {\n                    \"-1\": SOURCE,\n                    \"1\": TARGET\n                };\n\n            diagram.Cursors = Cursors;\n\n            var PositionAdapter = kendo.Class.extend({\n                init: function(layoutState) {\n                    this.layoutState = layoutState;\n                    this.diagram = layoutState.diagram;\n                },\n                initState: function() {\n                    this.froms = [];\n                    this.tos = [];\n                    this.subjects = [];\n                    function pusher(id, bounds) {\n                        var shape = this.diagram.getShapeById(id);\n                        if (shape) {\n                            this.subjects.push(shape);\n                            this.froms.push(shape.bounds().topLeft());\n                            this.tos.push(bounds.topLeft());\n                        }\n                    }\n\n                    this.layoutState.nodeMap.forEach(pusher, this);\n                },\n                update: function(tick) {\n                    if (this.subjects.length <= 0) {\n                        return;\n                    }\n                    for (var i = 0; i < this.subjects.length; i++) {\n                        //todo: define a Lerp function instead\n                        this.subjects[i].position(\n                            new Point(this.froms[i].x + (this.tos[i].x - this.froms[i].x) * tick, this.froms[i].y + (this.tos[i].y - this.froms[i].y) * tick)\n                        );\n                    }\n                }\n            });\n\n            var LayoutUndoUnit = Class.extend({\n                init: function(initialState, finalState, animate) {\n                    if (isUndefined(animate)) {\n                        this.animate = false;\n                    }\n                    else {\n                        this.animate = animate;\n                    }\n                    this._initialState = initialState;\n                    this._finalState = finalState;\n                    this.title = \"Diagram layout\";\n                },\n                undo: function() {\n                    this.setState(this._initialState);\n                },\n                redo: function() {\n                    this.setState(this._finalState);\n                },\n                setState: function(state) {\n                    var diagram = state.diagram;\n                    if (this.animate) {\n                        state.linkMap.forEach(\n                            function(id, points) {\n                                var conn = diagram.getShapeById(id);\n                                conn.visible(false);\n                                if (conn) {\n                                    conn.points(points);\n                                }\n                            }\n                        );\n                        var ticker = new Ticker();\n                        ticker.addAdapter(new PositionAdapter(state));\n                        ticker.onComplete(function() {\n                            state.linkMap.forEach(\n                                function(id) {\n                                    var conn = diagram.getShapeById(id);\n                                    conn.visible(true);\n                                }\n                            );\n                        });\n                        ticker.play();\n                    }\n                    else {\n                        state.nodeMap.forEach(function(id, bounds) {\n                            var shape = diagram.getShapeById(id);\n                            if (shape) {\n                                shape.position(bounds.topLeft());\n                            }\n                        });\n                        state.linkMap.forEach(\n                            function(id, points) {\n                                var conn = diagram.getShapeById(id);\n                                if (conn) {\n                                    conn.points(points);\n                                }\n                            }\n                        );\n                    }\n                }\n            });\n\n            var CompositeUnit = Class.extend({\n                init: function(unit) {\n                    this.units = [];\n                    this.title = \"Composite unit\";\n                    if (unit !== undefined$1) {\n                        this.units.push(unit);\n                    }\n                },\n                add: function(undoUnit) {\n                    this.units.push(undoUnit);\n                },\n                undo: function() {\n                    for (var i = 0; i < this.units.length; i++) {\n                        this.units[i].undo();\n                    }\n                },\n                redo: function() {\n                    for (var i = 0; i < this.units.length; i++) {\n                        this.units[i].redo();\n                    }\n                }\n            });\n\n            var ConnectionEditUnit = Class.extend({\n                init: function(item, redoSource, redoTarget) {\n                    this.item = item;\n                    this._redoSource = redoSource;\n                    this._redoTarget = redoTarget;\n                    if (defined(redoSource)) {\n                        this._undoSource = item.source();\n                    }\n\n                    if (defined(redoTarget)) {\n                        this._undoTarget = item.target();\n                    }\n                    this.title = \"Connection Editing\";\n                },\n                undo: function() {\n                    if (this._undoSource !== undefined$1) {\n                        this.item._updateConnector(this._undoSource, \"source\");\n                    }\n\n                    if (this._undoTarget !== undefined$1) {\n                        this.item._updateConnector(this._undoTarget, \"target\");\n                    }\n\n                    this.item.updateModel();\n                },\n                redo: function() {\n                    if (this._redoSource !== undefined$1) {\n                        this.item._updateConnector(this._redoSource, \"source\");\n                    }\n\n                    if (this._redoTarget !== undefined$1) {\n                        this.item._updateConnector(this._redoTarget, \"target\");\n                    }\n\n                    this.item.updateModel();\n                }\n            });\n\n            var ConnectionEditUndoUnit = Class.extend({\n                init: function(item, undoSource, undoTarget) {\n                    this.item = item;\n                    this._undoSource = undoSource;\n                    this._undoTarget = undoTarget;\n                    this._redoSource = item.source();\n                    this._redoTarget = item.target();\n                    this.title = \"Connection Editing\";\n                },\n                undo: function() {\n                    this.item._updateConnector(this._undoSource, \"source\");\n                    this.item._updateConnector(this._undoTarget, \"target\");\n                    this.item.updateModel();\n                },\n                redo: function() {\n                    this.item._updateConnector(this._redoSource, \"source\");\n                    this.item._updateConnector(this._redoTarget, \"target\");\n                    this.item.updateModel();\n                }\n            });\n\n            var DeleteConnectionUnit = Class.extend({\n                init: function(connection) {\n                    this.connection = connection;\n                    this.diagram = connection.diagram;\n                    this.targetConnector = connection.targetConnector;\n                    this.title = \"Delete connection\";\n                },\n                undo: function() {\n                    this.diagram._addConnection(this.connection, false);\n                },\n                redo: function() {\n                    this.diagram.remove(this.connection, false);\n                }\n            });\n\n            var DeleteShapeUnit = Class.extend({\n                init: function(shape) {\n                    this.shape = shape;\n                    this.diagram = shape.diagram;\n                    this.title = \"Deletion\";\n                },\n                undo: function() {\n                    this.diagram._addShape(this.shape, false);\n                    this.shape.select(false);\n                },\n                redo: function() {\n                    this.shape.select(false);\n                    this.diagram.remove(this.shape, false);\n                }\n            });\n            /**\n             * Holds the undoredo state when performing a rotation, translation or scaling. The adorner is optional.\n             * @type {*}\n             */\n            var TransformUnit = Class.extend({\n                init: function(shapes, undoStates, adorner) {\n                    this.shapes = shapes;\n                    this.undoStates = undoStates;\n                    this.title = \"Transformation\";\n                    this.redoStates = [];\n                    this.adorner = adorner;\n                    for (var i = 0; i < this.shapes.length; i++) {\n                        var shape = this.shapes[i];\n                        this.redoStates.push(shape.bounds());\n                    }\n                },\n                undo: function() {\n                    for (var i = 0; i < this.shapes.length; i++) {\n                        var shape = this.shapes[i];\n                        shape.bounds(this.undoStates[i]);\n                        if (shape.hasOwnProperty(\"layout\")) {\n                            shape.layout(shape, this.redoStates[i], this.undoStates[i]);\n                        }\n                        shape.updateModel();\n                    }\n                    if (this.adorner) {\n                        this.adorner.refreshBounds();\n                        this.adorner.refresh();\n                    }\n                },\n                redo: function() {\n                    for (var i = 0; i < this.shapes.length; i++) {\n                        var shape = this.shapes[i];\n                        shape.bounds(this.redoStates[i]);\n                        // the 'layout' property, if implemented, lets the shape itself work out what to do with the new bounds\n                        if (shape.hasOwnProperty(\"layout\")) {\n                            shape.layout(shape, this.undoStates[i], this.redoStates[i]);\n                        }\n                        shape.updateModel();\n                    }\n\n                    if (this.adorner) {\n                        this.adorner.refreshBounds();\n                        this.adorner.refresh();\n                    }\n                }\n            });\n\n            var AddConnectionUnit = Class.extend({\n                init: function(connection, diagram) {\n                    this.connection = connection;\n                    this.diagram = diagram;\n                    this.title = \"New connection\";\n                },\n\n                undo: function() {\n                    this.diagram.remove(this.connection, false);\n                },\n\n                redo: function() {\n                    this.diagram._addConnection(this.connection, false);\n                }\n            });\n\n            var AddShapeUnit = Class.extend({\n                init: function(shape, diagram) {\n                    this.shape = shape;\n                    this.diagram = diagram;\n                    this.title = \"New shape\";\n                },\n\n                undo: function() {\n                    this.diagram.deselect();\n                    this.diagram.remove(this.shape, false);\n                },\n\n                redo: function() {\n                    this.diagram._addShape(this.shape, false);\n                }\n            });\n\n            var PanUndoUnit = Class.extend({\n                init: function(initialPosition, finalPosition, diagram) {\n                    this.initial = initialPosition;\n                    this.finalPos = finalPosition;\n                    this.diagram = diagram;\n                    this.title = \"Pan Unit\";\n                },\n                undo: function() {\n                    this.diagram.pan(this.initial);\n                },\n                redo: function() {\n                    this.diagram.pan(this.finalPos);\n                }\n            });\n\n            var RotateUnit = Class.extend({\n                init: function(adorner, shapes, undoRotates) {\n                    this.shapes = shapes;\n                    this.undoRotates = undoRotates;\n                    this.title = \"Rotation\";\n                    this.redoRotates = [];\n                    this.redoAngle = adorner._angle;\n                    this.adorner = adorner;\n                    this.center = adorner._innerBounds.center();\n                    for (var i = 0; i < this.shapes.length; i++) {\n                        var shape = this.shapes[i];\n                        this.redoRotates.push(shape.rotate().angle);\n                    }\n                },\n                undo: function() {\n                    var i, shape;\n                    for (i = 0; i < this.shapes.length; i++) {\n                        shape = this.shapes[i];\n                        shape.rotate(this.undoRotates[i], this.center, false);\n                        if (shape.hasOwnProperty(\"layout\")) {\n                            shape.layout(shape);\n                        }\n                        shape.updateModel();\n                    }\n                    if (this.adorner) {\n                        this.adorner._initialize();\n                        this.adorner.refresh();\n                    }\n                },\n                redo: function() {\n                    var i, shape;\n                    for (i = 0; i < this.shapes.length; i++) {\n                        shape = this.shapes[i];\n                        shape.rotate(this.redoRotates[i], this.center, false);\n                        if (shape.hasOwnProperty(\"layout\")) {\n                            shape.layout(shape);\n                        }\n                        shape.updateModel();\n                    }\n                    if (this.adorner) {\n                        this.adorner._initialize();\n                        this.adorner.refresh();\n                    }\n                }\n            });\n\n            var ToFrontUnit = Class.extend({\n                init: function(diagram, items, initialIndices) {\n                    this.diagram = diagram;\n                    this.indices = initialIndices;\n                    this.items = items;\n                    this.title = \"Rotate Unit\";\n                },\n                undo: function() {\n                    this.diagram._toIndex(this.items, this.indices);\n                },\n                redo: function() {\n                    this.diagram.toFront(this.items, false);\n                }\n            });\n\n            var ToBackUnit = Class.extend({\n                init: function(diagram, items, initialIndices) {\n                    this.diagram = diagram;\n                    this.indices = initialIndices;\n                    this.items = items;\n                    this.title = \"Rotate Unit\";\n                },\n                undo: function() {\n                    this.diagram._toIndex(this.items, this.indices);\n                },\n                redo: function() {\n                    this.diagram.toBack(this.items, false);\n                }\n            });\n\n            /**\n             * Undo-redo service.\n             */\n            var UndoRedoService = kendo.Observable.extend({\n                init: function(options) {\n                    kendo.Observable.fn.init.call(this, options);\n                    this.bind(this.events, options);\n                    this.stack = [];\n                    this.index = 0;\n                    this.capacity = 100;\n                },\n\n                events: [\"undone\", \"redone\"],\n\n                /**\n                 * Starts the collection of units. Add those with\n                 * the addCompositeItem method and call commit. Or cancel to forget about it.\n                 */\n                begin: function() {\n                    this.composite = new CompositeUnit();\n                },\n\n                /**\n                 * Cancels the collection process of unit started with 'begin'.\n                 */\n                cancel: function() {\n                    this.composite = undefined$1;\n                },\n\n                /**\n                 * Commits a batch of units.\n                 */\n                commit: function(execute) {\n                    if (this.composite.units.length > 0) {\n                        this._restart(this.composite, execute);\n                    }\n                    this.composite = undefined$1;\n                },\n\n                /**\n                 * Adds a unit as part of the begin-commit batch.\n                 * @param undoUnit\n                 */\n                addCompositeItem: function(undoUnit) {\n                    if (this.composite) {\n                        this.composite.add(undoUnit);\n                    } else {\n                        this.add(undoUnit);\n                    }\n                },\n\n                /**\n                 * Standard addition of a unit. See also the batch version; begin-addCompositeUnit-commit methods.\n                 * @param undoUnit The unit to be added.\n                 * @param execute If false, the unit will be added but not executed.\n                 */\n                add: function(undoUnit, execute) {\n                    this._restart(undoUnit, execute);\n                },\n\n                /**\n                 * Returns the number of undoable unit in the stack.\n                 * @returns {Number}\n                 */\n\n                pop: function() {\n                    if (this.index > 0) {\n                        this.stack.pop();\n                        this.index--;\n                    }\n                },\n\n                count: function() {\n                    return this.stack.length;\n                },\n\n                /**\n                 * Rollback of the unit on top of the stack.\n                 */\n                undo: function() {\n                    if (this.index > 0) {\n                        this.index--;\n                        this.stack[this.index].undo();\n                        this.trigger(\"undone\");\n                    }\n                },\n\n                /**\n                 * Redo of the last undone action.\n                 */\n                redo: function() {\n                    if (this.stack.length > 0 && this.index < this.stack.length) {\n                        this.stack[this.index].redo();\n                        this.index++;\n                        this.trigger(\"redone\");\n                    }\n                },\n\n                _restart: function(composite, execute) {\n                    // throw away anything beyond this point if this is a new branch\n                    this.stack.splice(this.index, this.stack.length - this.index);\n                    this.stack.push(composite);\n                    if (execute !== false) {\n                        this.redo();\n                    } else {\n                        this.index++;\n                    }\n                    // check the capacity\n                    if (this.stack.length > this.capacity) {\n                        this.stack.splice(0, this.stack.length - this.capacity);\n                        this.index = this.capacity; //points to the end of the stack\n                    }\n                },\n\n                /**\n                 * Clears the stack.\n                 */\n                clear: function() {\n                    this.stack = [];\n                    this.index = 0;\n                }\n            });\n\n    // Tools =========================================\n\n            var EmptyTool = Class.extend({\n                init: function(toolService) {\n                    this.toolService = toolService;\n                },\n                start: function() {\n                },\n                move: function() {\n                },\n                end: function() {\n                },\n                tryActivate: function() {\n                    return false;\n                },\n                getCursor: function() {\n                    return Cursors.arrow;\n                }\n            });\n\n            var ScrollerTool = EmptyTool.extend({\n                init: function(toolService) {\n                    var tool = this;\n                    var friction = kendo.support.mobileOS ? FRICTION_MOBILE : FRICTION;\n                    EmptyTool.fn.init.call(tool, toolService);\n\n                    var diagram = tool.toolService.diagram,\n                        canvas = diagram.canvas;\n\n                    var scroller = diagram.scroller = tool.scroller = $(diagram.scrollable).kendoMobileScroller({\n                        friction: friction,\n                        velocityMultiplier: VELOCITY_MULTIPLIER,\n                        mousewheelScrolling: false,\n                        zoom: false,\n                        scroll: tool._move.bind(tool)\n                    }).data(\"kendoMobileScroller\");\n\n                    if (canvas.translate) {\n                        tool.movableCanvas = new Movable(canvas.element);\n                    }\n\n                    var virtualScroll = function(dimension, min, max) {\n                        dimension.makeVirtual();\n                        dimension.virtualSize(min || SCROLL_MIN, max || SCROLL_MAX);\n                    };\n\n                    virtualScroll(scroller.dimensions.x);\n                    virtualScroll(scroller.dimensions.y);\n                    scroller.disable();\n                },\n\n                tryActivate: function(p, meta) {\n                    var toolService = this.toolService;\n                    var options = toolService.diagram.options.pannable;\n                    var enabled = meta.ctrlKey;\n\n                    if (defined(options.key)) {\n                        if (!options.key || options.key == \"none\") {\n                            enabled = noMeta(meta) && !defined(toolService.hoveredItem);\n                        } else {\n                            enabled = meta[options.key + \"Key\"];\n                        }\n                    }\n\n                    return options !== false && enabled && !defined(toolService.hoveredAdorner) && !defined(toolService._hoveredConnector);\n                },\n\n                start: function() {\n                    this.scroller.enable();\n                },\n                move: function() {\n                },//the tool itself should not handle the scrolling. Let kendo scroller take care of this part. Check _move\n                _move: function(args) {\n                    var tool = this,\n                        diagram = tool.toolService.diagram,\n                        canvas = diagram.canvas,\n                        scrollPos = new Point(args.scrollLeft, args.scrollTop);\n\n                    if (canvas.translate) {\n                        diagram._storePan(scrollPos.times(-1));\n                        tool.movableCanvas.moveTo(scrollPos);\n                        canvas.translate(scrollPos.x, scrollPos.y);\n                    } else {\n                        scrollPos = scrollPos.plus(diagram._pan.times(-1));\n                    }\n\n                    diagram.trigger(PAN, { pan: scrollPos });\n                },\n                end: function() {\n                    this.scroller.disable();\n                },\n                getCursor: function() {\n                    return Cursors.move;\n                }\n            });\n\n            /**\n             * The tool handling the transformations via the adorner.\n             * @type {*}\n             */\n            var PointerTool = Class.extend({\n                init: function(toolService) {\n                    this.toolService = toolService;\n                },\n                tryActivate: function() {\n                    return true; // the pointer tool is last and handles all others requests.\n                },\n                start: function(p, meta) {\n                    var toolService = this.toolService,\n                        diagram = toolService.diagram,\n                        hoveredItem = toolService.hoveredItem;\n\n                    if (hoveredItem) {\n                        toolService.selectSingle(hoveredItem, meta);\n                        if (hoveredItem.adorner) { //connection\n                            this.adorner = hoveredItem.adorner;\n                            this.handle = this.adorner._hitTest(p);\n                        }\n                    }\n\n                    if (!this.handle) {\n                        this.handle = diagram._resizingAdorner._hitTest(p);\n                        if (this.handle) {\n                            this.adorner = diagram._resizingAdorner;\n                        }\n                    }\n\n                    if (this.adorner) {\n                        if (!this.adorner.isDragHandle(this.handle) || !diagram.trigger(DRAG_START, { shapes: this.adorner.shapes, connections: [] })) {\n                            this.adorner.start(p);\n                        } else {\n                            toolService.startPoint = p;\n                            toolService.end(p);\n                        }\n                    }\n                },\n\n                move: function(p) {\n                    if (this.adorner) {\n                        this.adorner.move(this.handle, p);\n                        if (this.adorner.isDragHandle(this.handle)) {\n                            this.toolService.diagram.trigger(DRAG, { shapes: this.adorner.shapes, connections: [] });\n                        }\n                    }\n                },\n\n                end: function() {\n                    var diagram = this.toolService.diagram,\n                        adorner = this.adorner,\n                        unit;\n\n                    if (adorner) {\n                        if (!adorner.isDragHandle(this.handle) || !diagram.trigger(DRAG_END, { shapes: adorner.shapes, connections: [] })) {\n                            unit = adorner.stop();\n                            if (unit) {\n                                diagram.undoRedoService.add(unit, false);\n                            }\n                        } else {\n                            adorner.cancel();\n                        }\n                    }\n\n                    this.adorner = undefined$1;\n                    this.handle = undefined$1;\n                },\n                getCursor: function(p) {\n                    return this.toolService.hoveredItem ? this.toolService.hoveredItem._getCursor(p) : Cursors.arrow;\n                }\n            });\n\n            var SelectionTool = Class.extend({\n                init: function(toolService) {\n                    this.toolService = toolService;\n                },\n                tryActivate: function(p, meta) {\n                    var toolService = this.toolService;\n                    var selectable = toolService.diagram.options.selectable;\n                    var enabled = selectable && selectable.multiple !== false;\n\n                    if (enabled) {\n                        if (selectable.key && selectable.key != \"none\") {\n                            enabled = meta[selectable.key + \"Key\"];\n                        } else {\n                            enabled = noMeta(meta);\n                        }\n                    }\n\n                    return enabled && !defined(toolService.hoveredItem) && !defined(toolService.hoveredAdorner);\n                },\n                start: function(p) {\n                    var diagram = this.toolService.diagram;\n                    diagram.deselect();\n                    diagram.selector.start(p);\n                },\n                move: function(p) {\n                    var diagram = this.toolService.diagram;\n                    diagram.selector.move(p);\n                },\n                end: function(p, meta) {\n                    var diagram = this.toolService.diagram, hoveredItem = this.toolService.hoveredItem;\n                    var rect = diagram.selector.bounds();\n                    if ((!hoveredItem || !hoveredItem.isSelected) && !meta.ctrlKey) {\n                        diagram.deselect();\n                    }\n                    if (!rect.isEmpty()) {\n                        diagram.selectArea(rect);\n                    }\n                    diagram.selector.end();\n                },\n                getCursor: function() {\n                    return Cursors.arrow;\n                }\n            });\n\n            var ConnectionTool = Class.extend({\n                init: function(toolService) {\n                    this.toolService = toolService;\n                    this.type = \"ConnectionTool\";\n                },\n                tryActivate: function() {\n                    return this.toolService._hoveredConnector;\n                },\n                start: function(p, meta) {\n                    var toolService = this.toolService,\n                        diagram = toolService.diagram,\n                        connector = toolService._hoveredConnector,\n                        connection = diagram._createConnection({}, connector._c, p);\n\n                    if (canDrag(connection) && !diagram.trigger(DRAG_START, { shapes: [], connections: [connection], connectionHandle: TARGET }) && diagram._addConnection(connection)) {\n                        toolService._connectionManipulation(connection, connector._c.shape, true);\n                        toolService._removeHover();\n                        toolService.selectSingle(toolService.activeConnection, meta);\n                        if (meta.type == \"touchmove\") {\n                            diagram._cachedTouchTarget = connector.visual;\n                        }\n                    } else {\n                        connection.source(null);\n                        toolService.end(p);\n                    }\n                },\n\n                move: function(p) {\n                    var toolService = this.toolService;\n                    var connection = toolService.activeConnection;\n\n                    connection.target(p);\n                    toolService.diagram.trigger(DRAG, { shapes: [], connections: [connection], connectionHandle: TARGET });\n                    return true;\n                },\n\n                end: function(p) {\n                    var toolService = this.toolService,\n                        d = toolService.diagram,\n                        connection = toolService.activeConnection,\n                        hoveredItem = toolService.hoveredItem,\n                        connector = toolService._hoveredConnector,\n                        target,\n                        cachedTouchTarget = d._cachedTouchTarget;\n\n                    if (!connection) {\n                        return;\n                    }\n\n                    if (connector && connector._c != connection.sourceConnector) {\n                        target = connector._c;\n                    } else if (hoveredItem && hoveredItem instanceof diagram.Shape) {\n                        target = hoveredItem.getConnector(AUTO) || hoveredItem.getConnector(p);\n                    } else {\n                        target = p;\n                    }\n\n                    connection.target(target);\n\n                    if (!d.trigger(DRAG_END, { shapes: [], connections: [connection], connectionHandle: TARGET })) {\n                        connection.updateModel();\n                        d._syncConnectionChanges();\n                    } else {\n                        d.remove(connection, false);\n                        d.undoRedoService.pop();\n                    }\n                    toolService._connectionManipulation();\n\n                    if (cachedTouchTarget) {\n                        d._connectorsAdorner.visual.remove(cachedTouchTarget);\n                        d._cachedTouchTarget = null;\n                    }\n                },\n\n                getCursor: function() {\n                    return Cursors.arrow;\n                }\n            });\n\n            var ConnectionEditTool = Class.extend({\n                init: function(toolService) {\n                    this.toolService = toolService;\n                    this.type = \"ConnectionTool\";\n                },\n\n                tryActivate: function(p, meta) {\n                    var toolService = this.toolService,\n                        diagram = toolService.diagram,\n                        selectable = diagram.options.selectable,\n                        item = toolService.hoveredItem,\n                        isActive = selectable !== false &&\n                                   item && item.path && !(item.isSelected && meta.ctrlKey);\n\n                    if (isActive) {\n                        this._c = item;\n                    }\n\n                    return isActive;\n                },\n\n                start: function(p, meta) {\n                    var toolService = this.toolService;\n                    var connection = this._c;\n\n                    toolService.selectSingle(connection, meta);\n\n                    var adorner = connection.adorner;\n\n                    var handle, name;\n                    if (adorner) {\n                        handle = adorner._hitTest(p);\n                        name = HANDLE_NAMES[handle];\n                    }\n\n                    if (canDrag(connection) && adorner && !toolService.diagram.trigger(DRAG_START, { shapes: [], connections: [connection], connectionHandle: name })) {\n                        this.handle = handle;\n                        this.handleName = name;\n                        adorner.start(p);\n                    } else {\n                        toolService.startPoint = p;\n                        toolService.end(p);\n                    }\n                },\n\n                move: function(p) {\n                    var adorner = this._c.adorner;\n                    if (canDrag(this._c) && adorner) {\n                        adorner.move(this.handle, p);\n                        this.toolService.diagram.trigger(DRAG, { shapes: [], connections: [this._c], connectionHandle: this.handleName });\n\n                        return true;\n                    }\n                },\n\n                end: function(p) {\n                    var connection = this._c;\n                    var adorner = connection.adorner;\n                    var toolService = this.toolService;\n                    var diagram = toolService.diagram;\n\n                    if (adorner) {\n                        if (canDrag(connection)) {\n                            var unit = adorner.stop(p);\n                            if (!diagram.trigger(DRAG_END, { shapes: [], connections: [connection], connectionHandle: this.handleName })) {\n                                diagram.undoRedoService.add(unit, false);\n                                connection.updateModel();\n                                diagram._syncConnectionChanges();\n                            } else {\n                                unit.undo();\n                            }\n                        }\n                    }\n                },\n\n                getCursor: function() {\n                    return Cursors.move;\n                }\n            });\n\n            function testKey(key, str) {\n                return str.charCodeAt(0) == key || str.toUpperCase().charCodeAt(0) == key;\n            }\n\n            /**\n             * The service managing the tools.\n             * @type {*}\n             */\n            var ToolService = Class.extend({\n                init: function(diagram) {\n                    this.diagram = diagram;\n                    this.tools = [\n                        new ScrollerTool(this),\n                        new ConnectionEditTool(this),\n                        new ConnectionTool(this),\n                        new SelectionTool(this),\n                        new PointerTool(this)\n                    ]; // the order matters.\n\n                    this.activeTool = undefined$1;\n                },\n\n                start: function(p, meta) {\n                    meta = deepExtend({}, meta);\n                    if (this.activeTool) {\n                        this.activeTool.end(p, meta);\n                    }\n                    this._updateHoveredItem(p);\n                    this._activateTool(p, meta);\n                    this.activeTool.start(p, meta);\n                    this._updateCursor(p);\n                    this.diagram.focus();\n                    this.diagram.canvas.surface.suspendTracking();\n                    this.startPoint = p;\n                    return true;\n                },\n\n                move: function(p, meta) {\n                    meta = deepExtend({}, meta);\n                    var updateHovered = true;\n                    if (this.activeTool) {\n                        updateHovered = this.activeTool.move(p, meta);\n                    }\n                    if (updateHovered) {\n                        this._updateHoveredItem(p);\n                    }\n                    this._updateCursor(p);\n                    return true;\n                },\n\n                end: function(p, meta) {\n                    meta = deepExtend({}, meta);\n                    if (this.activeTool) {\n                        this.activeTool.end(p, meta);\n                    }\n                    this.diagram.canvas.surface.resumeTracking();\n                    this.activeTool = undefined$1;\n                    this._updateCursor(p);\n                    return true;\n                },\n\n                keyDown: function(key, meta) {\n                    var diagram = this.diagram;\n                    meta = deepExtend({ ctrlKey: false, metaKey: false, altKey: false }, meta);\n                    if ((meta.ctrlKey || meta.metaKey) && !meta.altKey) {// ctrl or option\n                        if (testKey(key, \"a\")) {// A: select all\n                            diagram.selectAll();\n                            diagram._destroyToolBar();\n                            return true;\n                        } else if (testKey(key, \"z\")) {// Z: undo\n                            diagram.undo();\n                            diagram._destroyToolBar();\n                            return true;\n                        } else if (testKey(key, \"y\")) {// y: redo\n                            diagram.redo();\n                            diagram._destroyToolBar();\n                            return true;\n                        } else if (testKey(key, \"c\")) {\n                            diagram.copy();\n                            diagram._destroyToolBar();\n                        } else if (testKey(key, \"x\")) {\n                            diagram.cut();\n                            diagram._destroyToolBar();\n                        } else if (testKey(key, \"v\")) {\n                            diagram.paste();\n                            diagram._destroyToolBar();\n                        } else if (testKey(key, \"l\")) {\n                            diagram.layout();\n                            diagram._destroyToolBar();\n                        } else if (testKey(key, \"d\")) {\n                            diagram._destroyToolBar();\n                            diagram.copy();\n                            diagram.paste();\n                        }\n                    } else if (key === 46 || key === 8) {// del: deletion\n                        var toRemove = this.diagram._triggerRemove(diagram.select());\n                        if (toRemove.length) {\n                            this.diagram.remove(toRemove, true);\n                            this.diagram._syncChanges();\n                            this.diagram._destroyToolBar();\n                        }\n\n                        return true;\n                    } else if (key === 27) {// ESC: stop any action\n                        this._discardNewConnection();\n                        diagram.deselect();\n                        diagram._destroyToolBar();\n                        return true;\n                    }\n\n                },\n                wheel: function(p, meta) {\n                    var diagram = this.diagram,\n                        delta = meta.delta,\n                        z = diagram.zoom(),\n                        options = diagram.options,\n                        zoomRate = options.zoomRate,\n                        zoomOptions = { point: p, meta: meta, zoom: z };\n\n                    if (diagram.trigger(ZOOM_START, zoomOptions)) {\n                        return;\n                    }\n\n                    if (delta < 0) {\n                        z += zoomRate;\n                    } else {\n                        z -= zoomRate;\n                    }\n\n                    z = kendo.drawing.util.round(Math.max(options.zoomMin, Math.min(options.zoomMax, z)), 2);\n                    zoomOptions.zoom = z;\n\n                    diagram.zoom(z, zoomOptions);\n                    diagram.trigger(ZOOM_END, zoomOptions);\n\n                    return true;\n                },\n                setTool: function(tool, index) {\n                    tool.toolService = this;\n                    this.tools[index] = tool;\n                },\n\n                selectSingle: function(item, meta) {\n                    var diagram = this.diagram;\n                    var selectable = diagram.options.selectable;\n                    if (selectable && !item.isSelected && item.options.selectable !== false) {\n                        var addToSelection = meta.ctrlKey && selectable.multiple !== false;\n                        diagram.select(item, { addToSelection: addToSelection });\n                    }\n                },\n\n                _discardNewConnection: function() {\n                    if (this.newConnection) {\n                        this.diagram.remove(this.newConnection);\n                        this.newConnection = undefined$1;\n                    }\n                },\n                _activateTool: function(p, meta) {\n                    for (var i = 0; i < this.tools.length; i++) {\n                        var tool = this.tools[i];\n                        if (tool.tryActivate(p, meta)) {\n                            this.activeTool = tool;\n                            break; // activating the first available tool in the loop.\n                        }\n                    }\n                },\n                _updateCursor: function(p) {\n                    var element = this.diagram.element;\n                    var cursor = this.activeTool ? this.activeTool.getCursor(p) : (this.hoveredAdorner ? this.hoveredAdorner._getCursor(p) : (this.hoveredItem ? this.hoveredItem._getCursor(p) : Cursors.arrow));\n\n                    element.css({ cursor: cursor });\n                },\n                _connectionManipulation: function(connection, disabledShape, isNew) {\n                    this.activeConnection = connection;\n                    this.disabledShape = disabledShape;\n                    if (isNew) {\n                        this.newConnection = this.activeConnection;\n                    } else {\n                        this.newConnection = undefined$1;\n                    }\n                },\n                _updateHoveredItem: function(p) {\n                    var hit = this._hitTest(p);\n                    var diagram = this.diagram;\n\n                    if (hit != this.hoveredItem && (!this.disabledShape || hit != this.disabledShape)) {\n                        if (this.hoveredItem) {\n                            diagram.trigger(MOUSE_LEAVE, { item: this.hoveredItem });\n                            this.hoveredItem._hover(false);\n                        }\n\n                        if (hit && hit.options.enable) {\n                            diagram.trigger(MOUSE_ENTER, { item: hit });\n\n                            this.hoveredItem = hit; // Shape, connection or connector\n                            this.hoveredItem._hover(true);\n                        } else {\n                            this.hoveredItem = undefined$1;\n                        }\n                    }\n                },\n                _removeHover: function() {\n                    if (this.hoveredItem) {\n                        this.hoveredItem._hover(false);\n                        this.hoveredItem = undefined$1;\n                    }\n                },\n                _hitTest: function(point) {\n                    var hit, d = this.diagram, item, i;\n\n                    // connectors\n                    if (this._hoveredConnector) {\n                        this._hoveredConnector._hover(false);\n                        this._hoveredConnector = undefined$1;\n                    }\n                    if (d._connectorsAdorner._visible) {\n                        hit = d._connectorsAdorner._hitTest(point);\n                        if (hit) {\n                            return hit;\n                        }\n                    }\n\n                    hit = this.diagram._resizingAdorner._hitTest(point);\n                    if (hit) {\n                        this.hoveredAdorner = d._resizingAdorner;\n                        if (hit.x !== 0 || hit.y !== 0) { // hit testing for resizers or rotator, otherwise if (0,0) than pass through.\n                            return;\n                        }\n                        hit = undefined$1;\n                    } else {\n                        this.hoveredAdorner = undefined$1;\n                    }\n\n                    if (!this.activeTool || this.activeTool.type !== \"ConnectionTool\") {\n                        var selectedConnections = []; // only the connections should have higher presence because the connection edit point is on top of connector.\n                        // TODO: This should be reworked. The connection adorner should be one for all selected connections and should be hit tested prior the connections and shapes itself.\n                        for (i = 0; i < d._selectedItems.length; i++) {\n                            item = d._selectedItems[i];\n                            if (item instanceof diagram.Connection) {\n                                selectedConnections.push(item);\n                            }\n                        }\n                        hit = this._hitTestItems(selectedConnections, point);\n                    }\n\n                    return hit || this._hitTestElements(point);\n                },\n\n                _hitTestElements: function(point) {\n                    var diagram = this.diagram;\n                    var shapeHit = this._hitTestItems(diagram.shapes, point);\n                    var connectionHit = this._hitTestItems(diagram.connections, point);\n                    var hit;\n\n                    if ((!this.activeTool || this.activeTool.type != \"ConnectionTool\") && shapeHit && connectionHit && !hitTestShapeConnectors(shapeHit, point)) {\n                        var mainLayer = diagram.mainLayer;\n                        var shapeIdx = inArray(shapeHit.visual, mainLayer.children);\n                        var connectionIdx = inArray(connectionHit.visual, mainLayer.children);\n                        hit = shapeIdx > connectionIdx ? shapeHit : connectionHit;\n                    }\n                    return hit || shapeHit || connectionHit;\n                },\n\n                _hitTestItems: function(array, point) {\n                    var i, item, hit;\n                    for (i = array.length - 1; i >= 0; i--) {\n                        item = array[i];\n                        hit = item._hitTest(point);\n                        if (hit) {\n                            return hit;\n                        }\n                    }\n                }\n            });\n\n    // Routing =========================================\n\n            /**\n             * Base class for connection routers.\n             */\n            var ConnectionRouterBase = kendo.Class.extend({\n                init: function() {\n                }\n                /*route: function (connection) {\n                 },\n                 hitTest: function (p) {\n\n                 },\n                 getBounds: function () {\n\n                 }*/\n            });\n\n            /**\n             * Base class for polyline and cascading routing.\n             */\n            var LinearConnectionRouter = ConnectionRouterBase.extend({\n                init: function(connection) {\n                    var that = this;\n                    ConnectionRouterBase.fn.init.call(that);\n                    this.connection = connection;\n                },\n                /**\n                 * Hit testing for polyline paths.\n                 */\n                hitTest: function(p) {\n                    var rec = this.getBounds().inflate(HIT_TEST_DISTANCE);\n                    if (!rec.contains(p)) {\n                        return false;\n                    }\n                    return diagram.Geometry.distanceToPolyline(p, this.connection.allPoints()) < HIT_TEST_DISTANCE;\n                },\n\n                /**\n                 * Bounds of a polyline.\n                 * @returns {kendo.dataviz.diagram.Rect}\n                 */\n                getBounds: function() {\n                    var points = this.connection.allPoints(),\n                        s = points[0],\n                        e = points[points.length - 1],\n                        right = Math.max(s.x, e.x),\n                        left = Math.min(s.x, e.x),\n                        top = Math.min(s.y, e.y),\n                        bottom = Math.max(s.y, e.y);\n\n                    for (var i = 1; i < points.length - 1; ++i) {\n                        right = Math.max(right, points[i].x);\n                        left = Math.min(left, points[i].x);\n                        top = Math.min(top, points[i].y);\n                        bottom = Math.max(bottom, points[i].y);\n                    }\n\n                    return new Rect(left, top, right - left, bottom - top);\n                }\n            });\n\n            /**\n             * A simple poly-linear routing which does not alter the intermediate points.\n             * Does hold the underlying hit, bounds....logic.\n             * @type {*|Object|void|extend|Zepto.extend|b.extend}\n             */\n            var PolylineRouter = LinearConnectionRouter.extend({\n                init: function(connection) {\n                    var that = this;\n                    LinearConnectionRouter.fn.init.call(that);\n                    this.connection = connection;\n                },\n                route: function() {\n                    // just keep the points as is\n                }\n            });\n\n            var CascadingRouter = LinearConnectionRouter.extend({\n                SAME_SIDE_DISTANCE_RATIO: 5,\n\n                init: function(connection) {\n                    var that = this;\n                    LinearConnectionRouter.fn.init.call(that);\n                    this.connection = connection;\n                },\n\n                routePoints: function(start, end, sourceConnector, targetConnector) {\n                    var result;\n\n                    if (sourceConnector && targetConnector) {\n                        result = this._connectorPoints(start, end, sourceConnector, targetConnector);\n                    } else {\n                        result = this._floatingPoints(start, end, sourceConnector);\n                    }\n                    return result;\n                },\n\n                route: function() {\n                    var sourceConnector = this.connection._resolvedSourceConnector;\n                    var targetConnector = this.connection._resolvedTargetConnector;\n                    var start = this.connection.sourcePoint();\n                    var end = this.connection.targetPoint();\n                    var points = this.routePoints(start, end, sourceConnector, targetConnector);\n                    this.connection.points(points);\n                },\n\n                _connectorSides: [{\n                    name: \"Top\",\n                    axis: \"y\",\n                    boundsPoint: \"topLeft\",\n                    secondarySign: 1\n                }, {\n                    name: \"Left\",\n                    axis: \"x\",\n                    boundsPoint: \"topLeft\",\n                    secondarySign: 1\n                }, {\n                    name: \"Bottom\",\n                    axis: \"y\",\n                    boundsPoint: \"bottomRight\",\n                    secondarySign: -1\n                }, {\n                    name: \"Right\",\n                    axis: \"x\",\n                    boundsPoint: \"bottomRight\",\n                    secondarySign: -1\n                }],\n\n                _connectorSide: function(connector, targetPoint) {\n                    var position = connector.position();\n                    var shapeBounds = connector.shape.bounds(ROTATED);\n                    var bounds = {\n                        topLeft: shapeBounds.topLeft(),\n                        bottomRight: shapeBounds.bottomRight()\n                    };\n                    var sides = this._connectorSides;\n                    var min = util.MAX_NUM;\n                    var sideDistance;\n                    var minSide;\n                    var axis;\n                    var side;\n                    for (var idx = 0; idx < sides.length; idx++) {\n                        side = sides[idx];\n                        axis = side.axis;\n                        sideDistance = Math.round(Math.abs(position[axis] - bounds[side.boundsPoint][axis]));\n                        if (sideDistance < min) {\n                            min = sideDistance;\n                            minSide = side;\n                        } else if (sideDistance === min &&\n                            (position[axis] - targetPoint[axis]) * side.secondarySign > (position[minSide.axis] - targetPoint[minSide.axis]) * minSide.secondarySign) {\n                            minSide = side;\n                        }\n                    }\n                    return minSide.name;\n                },\n\n                _sameSideDistance: function(connector) {\n                    var bounds = connector.shape.bounds(ROTATED);\n                    return Math.min(bounds.width, bounds.height) / this.SAME_SIDE_DISTANCE_RATIO;\n                },\n\n                _connectorPoints: function(start, end, sourceConnector, targetConnector) {\n                    var sourceConnectorSide = this._connectorSide(sourceConnector, end);\n                    var targetConnectorSide = this._connectorSide(targetConnector, start);\n                    var deltaX = end.x - start.x;\n                    var deltaY = end.y - start.y;\n                    var sameSideDistance = this._sameSideDistance(sourceConnector);\n                    var result = [];\n                    var pointX, pointY;\n\n                    if (sourceConnectorSide === TOP || sourceConnectorSide == BOTTOM) {\n                        if (targetConnectorSide == TOP || targetConnectorSide == BOTTOM) {\n                            if (sourceConnectorSide == targetConnectorSide) {\n                                if (sourceConnectorSide == TOP) {\n                                    pointY = Math.min(start.y, end.y) - sameSideDistance;\n                                } else {\n                                    pointY = Math.max(start.y, end.y) + sameSideDistance;\n                                }\n                                result = [new Point(start.x, pointY), new Point(end.x, pointY)];\n                            } else {\n                                result = [new Point(start.x, start.y + deltaY / 2), new Point(end.x, start.y + deltaY / 2)];\n                            }\n                        } else {\n                            result = [new Point(start.x, end.y)];\n                        }\n                    } else {\n                        if (targetConnectorSide == LEFT || targetConnectorSide == RIGHT) {\n                            if (sourceConnectorSide == targetConnectorSide) {\n                                if (sourceConnectorSide == LEFT) {\n                                    pointX = Math.min(start.x, end.x) - sameSideDistance;\n                                } else {\n                                    pointX = Math.max(start.x, end.x) + sameSideDistance;\n                                }\n                                result = [new Point(pointX, start.y), new Point(pointX, end.y)];\n                            } else {\n                                result = [new Point(start.x + deltaX / 2, start.y), new Point(start.x + deltaX / 2, start.y + deltaY)];\n                            }\n                        } else {\n                            result = [new Point(end.x, start.y)];\n                        }\n                    }\n                    return result;\n                },\n\n                _floatingPoints: function(start, end, sourceConnector) {\n                    var sourceConnectorSide = sourceConnector ? this._connectorSide(sourceConnector, end) : null;\n                    var cascadeStartHorizontal = this._startHorizontal(start, end, sourceConnectorSide);\n                    var points = [start, start, end, end];\n                    var deltaX = end.x - start.x;\n                    var deltaY = end.y - start.y;\n                    var length = points.length;\n                    var shiftX;\n                    var shiftY;\n\n                    // note that this is more generic than needed for only two intermediate points.\n                    for (var idx = 1; idx < length - 1; ++idx) {\n                        if (cascadeStartHorizontal) {\n                            if (idx % 2 !== 0) {\n                                shiftX = deltaX / (length / 2);\n                                shiftY = 0;\n                            }\n                            else {\n                                shiftX = 0;\n                                shiftY = deltaY / ((length - 1) / 2);\n                            }\n                        }\n                        else {\n                            if (idx % 2 !== 0) {\n                                shiftX = 0;\n                                shiftY = deltaY / (length / 2);\n                            }\n                            else {\n                                shiftX = deltaX / ((length - 1) / 2);\n                                shiftY = 0;\n                            }\n                        }\n                        points[idx] = new Point(points[idx - 1].x + shiftX, points[idx - 1].y + shiftY);\n                    }\n                    // need to fix the wrong 1.5 factor of the last intermediate point\n                    idx--;\n                    if ((cascadeStartHorizontal && (idx % 2 !== 0)) || (!cascadeStartHorizontal && (idx % 2 === 0))) {\n                        points[length - 2] = new Point(points[length - 1].x, points[length - 2].y);\n                    } else {\n                        points[length - 2] = new Point(points[length - 2].x, points[length - 1].y);\n                    }\n\n                    return [points[1], points[2]];\n                },\n\n                _startHorizontal: function(start, end, sourceSide) {\n                    var horizontal;\n                    if (sourceSide !== null && (sourceSide === RIGHT || sourceSide === LEFT)) {\n                        horizontal = true;\n                    } else {\n                        horizontal = Math.abs(start.x - end.x) > Math.abs(start.y - end.y);\n                    }\n\n                    return horizontal;\n                }\n            });\n\n    // Adorners =========================================\n\n            var AdornerBase = Class.extend({\n                init: function(diagram, options) {\n                    var that = this;\n                    that.diagram = diagram;\n                    that.options = deepExtend({}, that.options, options);\n                    that.visual = new Group();\n                    that.diagram._adorners.push(that);\n                },\n                refresh: function() {\n\n                }\n            });\n\n            var ConnectionEditAdorner = AdornerBase.extend({\n                init: function(connection, options) {\n                    var that = this, diagram;\n                    that.connection = connection;\n                    diagram = that.connection.diagram;\n                    that._ts = diagram.toolService;\n                    AdornerBase.fn.init.call(that, diagram, options);\n                    var sp = that.connection.sourcePoint();\n                    var tp = that.connection.targetPoint();\n                    that.spVisual = new Circle(deepExtend(that.options.handles, { center: sp }));\n                    that.epVisual = new Circle(deepExtend(that.options.handles, { center: tp }));\n                    that.visual.append(that.spVisual);\n                    that.visual.append(that.epVisual);\n                },\n\n                options: {\n                    handles: {}\n                },\n\n                _getCursor: function() {\n                    return Cursors.move;\n                },\n\n                start: function(p) {\n                    this.handle = this._hitTest(p);\n                    this.startPoint = p;\n                    this._initialSource = this.connection.source();\n                    this._initialTarget = this.connection.target();\n                    switch (this.handle) {\n                        case -1:\n                            if (this.connection.targetConnector) {\n                                this._ts._connectionManipulation(this.connection, this.connection.targetConnector.shape);\n                            }\n                            break;\n                        case 1:\n                            if (this.connection.sourceConnector) {\n                                this._ts._connectionManipulation(this.connection, this.connection.sourceConnector.shape);\n                            }\n                            break;\n                    }\n                },\n\n                move: function(handle, p) {\n                    switch (handle) {\n                        case -1:\n                            this.connection.source(p);\n                            break;\n                        case 1:\n                            this.connection.target(p);\n                            break;\n                        default:\n                            var delta = p.minus(this.startPoint);\n                            this.startPoint = p;\n                            if (!this.connection.sourceConnector) {\n                                this.connection.source(this.connection.sourcePoint().plus(delta));\n                            }\n                            if (!this.connection.targetConnector) {\n                                this.connection.target(this.connection.targetPoint().plus(delta));\n                            }\n                            break;\n                    }\n                    this.refresh();\n                    return true;\n                },\n\n                stop: function(p) {\n                    var ts = this.diagram.toolService, item = ts.hoveredItem, target;\n                    if (ts._hoveredConnector) {\n                        target = ts._hoveredConnector._c;\n                    } else if (item && item instanceof diagram.Shape) {\n                        target = item.getConnector(AUTO) || item.getConnector(p);\n                    } else {\n                        target = p;\n                    }\n\n                    if (this.handle === -1) {\n                        this.connection.source(target);\n                    } else if (this.handle === 1) {\n                        this.connection.target(target);\n                    }\n\n                    this.handle = undefined$1;\n                    this._ts._connectionManipulation();\n                    return new ConnectionEditUndoUnit(this.connection, this._initialSource, this._initialTarget);\n                },\n\n                _hitTest: function(point) {\n                    var sourcePoint = this.connection.sourcePoint();\n                    var targetPoint = this.connection.targetPoint();\n                    var radiusX = this.options.handles.width / 2 + HIT_TEST_DISTANCE;\n                    var radiusY = this.options.handles.height / 2 + HIT_TEST_DISTANCE;\n                    var sourcePointDistance = sourcePoint.distanceTo(point);\n                    var targetPointDistance = targetPoint.distanceTo(point);\n                    var sourceHandle = new Rect(sourcePoint.x, sourcePoint.y).inflate(radiusX, radiusY).contains(point);\n                    var targetHandle = new Rect(targetPoint.x, targetPoint.y).inflate(radiusX, radiusY).contains(point);\n                    var handle = 0;\n\n                    if (sourceHandle && (!targetHandle || sourcePointDistance < targetPointDistance)) {\n                        handle = -1;\n                    } else if (targetHandle && (!sourceHandle || targetPointDistance < sourcePointDistance)) {\n                        handle = 1;\n                    }\n\n                    return handle;\n                },\n\n                refresh: function() {\n                    this.spVisual.redraw({ center: this.diagram.modelToLayer(this.connection.sourcePoint()) });\n                    this.epVisual.redraw({ center: this.diagram.modelToLayer(this.connection.targetPoint()) });\n                }\n            });\n\n            var ConnectorsAdorner = AdornerBase.extend({\n                init: function(diagram, options) {\n                    var that = this;\n                    AdornerBase.fn.init.call(that, diagram, options);\n                    that._refreshHandler = function(e) {\n                        if (e.item == that.shape) {\n                            that.refresh();\n                        }\n                    };\n                },\n\n                show: function(shape) {\n                    var that = this, len, i, ctr;\n                    that._visible = true;\n                    that.shape = shape;\n                    that.diagram.bind(ITEMBOUNDSCHANGE, that._refreshHandler);\n                    len = shape.connectors.length;\n                    that.connectors = [];\n                    that._clearVisual();\n                    for (i = 0; i < len; i++) {\n                        ctr = new ConnectorVisual(shape.connectors[i]);\n                        that.connectors.push(ctr);\n                        that.visual.append(ctr.visual);\n                    }\n                    that.visual.visible(true);\n                    that.refresh();\n                },\n\n                _clearVisual: function() {\n                    var that = this;\n                    if (that.diagram._cachedTouchTarget) {\n                        that._keepCachedTouchTarget();\n                    } else {\n                        that.visual.clear();\n                    }\n                },\n\n                _keepCachedTouchTarget: function() {\n                    var that = this,\n                        visualChildren = that.visual.children;\n                    var childrenCount = visualChildren.length;\n                    var index = inArray(that.diagram._cachedTouchTarget, visualChildren);\n                    for (var i = childrenCount - 1; i >= 0; i--) {\n                        if (i == index) {\n                            continue;\n                        }\n                        that.visual.remove(visualChildren[i]);\n                    }\n                },\n\n                destroy: function() {\n                    var that = this;\n                    that.diagram.unbind(ITEMBOUNDSCHANGE, that._refreshHandler);\n                    that.shape = undefined$1;\n                    that._visible = undefined$1;\n                    that.visual.visible(false);\n                },\n\n                _hitTest: function(p) {\n                    var ctr, i;\n                    for (i = 0; i < this.connectors.length; i++) {\n                        ctr = this.connectors[i];\n                        if (ctr._hitTest(p)) {\n                            ctr._hover(true);\n                            this.diagram.toolService._hoveredConnector = ctr;\n                            break;\n                        }\n                    }\n                },\n\n                refresh: function() {\n                    if (this.shape) {\n                        var bounds = this.shape.bounds();\n                            bounds = this.diagram.modelToLayer(bounds);\n                        this.visual.position(bounds.topLeft());\n                        $.each(this.connectors, function() {\n                            this.refresh();\n                        });\n                    }\n                }\n            });\n\n            function hitToOppositeSide(hit, bounds) {\n                var result;\n\n                if (hit.x == -1 && hit.y == -1) {\n                    result = bounds.bottomRight();\n                } else if (hit.x == 1 && hit.y == 1) {\n                    result = bounds.topLeft();\n                } else if (hit.x == -1 && hit.y == 1) {\n                    result = bounds.topRight();\n                } else if (hit.x == 1 && hit.y == -1) {\n                    result = bounds.bottomLeft();\n                } else if (hit.x === 0 && hit.y == -1) {\n                    result = bounds.bottom();\n                } else if (hit.x === 0 && hit.y == 1) {\n                    result = bounds.top();\n                } else if (hit.x == 1 && hit.y === 0) {\n                    result = bounds.left();\n                } else if (hit.x == -1 && hit.y === 0) {\n                    result = bounds.right();\n                }\n\n                return result;\n            }\n\n            var ResizingAdorner = AdornerBase.extend({\n                init: function(diagram, options) {\n                    var that = this;\n                    AdornerBase.fn.init.call(that, diagram, options);\n                    that._manipulating = false;\n                    that.map = [];\n                    that.shapes = [];\n\n                    that._initSelection();\n                    that._createHandles();\n                    that.redraw();\n                    that.diagram.bind(\"select\", function(e) {\n                        that._initialize(e.selected);\n                    });\n\n                    that._refreshHandler = function() {\n                        if (!that._internalChange) {\n                            that.refreshBounds();\n                            that.refresh();\n                        }\n                    };\n\n                    that._rotatedHandler = function() {\n                        if (that.shapes.length == 1) {\n                            that._angle = that.shapes[0].rotate().angle;\n                        }\n                        that._refreshHandler();\n                    };\n\n                    that.diagram.bind(ITEMBOUNDSCHANGE, that._refreshHandler).bind(ITEMROTATE, that._rotatedHandler);\n                    that.refreshBounds();\n                    that.refresh();\n                },\n\n                options: {\n                    handles: {\n                        fill: {\n                            color: \"#fff\"\n                        },\n                        stroke: {\n                            color: \"#282828\"\n                        },\n                        height: 7,\n                        width: 7,\n                        hover: {\n                            fill: {\n                                color: \"#282828\"\n                            },\n                            stroke: {\n                                color: \"#282828\"\n                            }\n                        }\n                    },\n                    selectable: {\n                        stroke: {\n                            color: \"#778899\",\n                            width: 1,\n                            dashType: \"dash\"\n                        },\n                        fill: {\n                            color: TRANSPARENT\n                        }\n                    },\n                    offset: 10\n                },\n\n                _initSelection: function() {\n                    var that = this;\n                    var diagram = that.diagram;\n                    var selectable = diagram.options.selectable;\n                    var options = deepExtend({}, that.options.selectable, selectable);\n                    that.rect = new Rectangle(options);\n                    that.visual.append(that.rect);\n                },\n\n                _resizable: function() {\n                    return this.options.editable && this.options.editable.resize !== false;\n                },\n\n                _handleOptions: function() {\n                    return (this.options.editable.resize || {}).handles || this.options.handles;\n                },\n\n                _createHandles: function() {\n                    var handles, item, y, x;\n\n                    if (this._resizable()) {\n                        handles = this._handleOptions();\n                        for (x = -1; x <= 1; x++) {\n                            for (y = -1; y <= 1; y++) {\n                                if ((x !== 0) || (y !== 0)) { // (0, 0) element, (-1, -1) top-left, (+1, +1) bottom-right\n                                    item = new Rectangle(handles);\n                                    item.drawingElement._hover = this._hover.bind(this);\n                                    this.map.push({ x: x, y: y, visual: item });\n                                    this.visual.append(item);\n                                }\n                            }\n                        }\n                    }\n                },\n\n                bounds: function(value) {\n                    if (value) {\n                        this._innerBounds = value.clone();\n                        this._bounds = this.diagram.modelToLayer(value).inflate(this.options.offset, this.options.offset);\n                    } else {\n                        return this._bounds;\n                    }\n                },\n\n                _hitTest: function(p) {\n                    var tp = this.diagram.modelToLayer(p),\n                        i, hit, handleBounds, handlesCount = this.map.length, handle;\n\n                    if (this._angle) {\n                        tp = tp.clone().rotate(this._angle, this._bounds.center());\n                    }\n\n                    if (this._resizable()) {\n                        for (i = 0; i < handlesCount; i++) {\n                            handle = this.map[i];\n                            hit = new Point(handle.x, handle.y);\n                            handleBounds = this._getHandleBounds(hit); //local coordinates\n                            handleBounds.offset(this._bounds.x, this._bounds.y);\n                            if (handleBounds.contains(tp)) {\n                                return hit;\n                            }\n                        }\n                    }\n\n                    if (this._bounds.contains(tp)) {\n                        return new Point(0, 0);\n                    }\n                },\n\n                _getHandleBounds: function(p) {\n                    if (this._resizable()) {\n                        var handles = this._handleOptions(),\n                            w = handles.width,\n                            h = handles.height,\n                            r = new Rect(0, 0, w, h);\n\n                        if (p.x < 0) {\n                            r.x = - w / 2;\n                        } else if (p.x === 0) {\n                            r.x = Math.floor(this._bounds.width / 2) - w / 2;\n                        } else if (p.x > 0) {\n                            r.x = this._bounds.width + 1.0 - w / 2;\n                        }\n\n                        if (p.y < 0) {\n                            r.y = - h / 2;\n                        } else if (p.y === 0) {\n                            r.y = Math.floor(this._bounds.height / 2) - h / 2;\n                        } else if (p.y > 0) {\n                            r.y = this._bounds.height + 1.0 - h / 2;\n                        }\n\n                        return r;\n                    }\n                },\n\n                _getCursor: function(point) {\n                    var hit = this._hitTest(point);\n                    if (hit && (hit.x >= -1) && (hit.x <= 1) && (hit.y >= -1) && (hit.y <= 1) && this._resizable()) {\n                        var angle = this._angle;\n                        if (angle) {\n                            hit.rotate(angle, new Point(0, 0));\n                            hit = new Point(Math.round(hit.x), Math.round(hit.y));\n                        }\n\n                        if (hit.x == -1 && hit.y == -1) {\n                            return \"nw-resize\";\n                        }\n                        if (hit.x == 1 && hit.y == 1) {\n                            return \"se-resize\";\n                        }\n                        if (hit.x == -1 && hit.y == 1) {\n                            return \"sw-resize\";\n                        }\n                        if (hit.x == 1 && hit.y == -1) {\n                            return \"ne-resize\";\n                        }\n                        if (hit.x === 0 && hit.y == -1) {\n                            return \"n-resize\";\n                        }\n                        if (hit.x === 0 && hit.y == 1) {\n                            return \"s-resize\";\n                        }\n                        if (hit.x == 1 && hit.y === 0) {\n                            return \"e-resize\";\n                        }\n                        if (hit.x == -1 && hit.y === 0) {\n                            return \"w-resize\";\n                        }\n                    }\n                    return this._manipulating ? Cursors.move : Cursors.select;\n                },\n\n                _initialize: function() {\n                    var that = this, i, item,\n                        items = that.diagram.select();\n\n                    that.shapes = [];\n                    for (i = 0; i < items.length; i++) {\n                        item = items[i];\n                        if (item instanceof diagram.Shape) {\n                            that.shapes.push(item);\n                            item._rotationOffset = new Point();\n                        }\n                    }\n\n                    that._angle = that.shapes.length == 1 ? that.shapes[0].rotate().angle : 0;\n                    that._startAngle = that._angle;\n                    that._rotates();\n                    that._positions();\n                    that.refreshBounds();\n                    that.refresh();\n                    that.redraw();\n                },\n\n                _rotates: function() {\n                    var that = this, i, shape;\n                    that.initialRotates = [];\n                    for (i = 0; i < that.shapes.length; i++) {\n                        shape = that.shapes[i];\n                        that.initialRotates.push(shape.rotate().angle);\n                    }\n                },\n\n                _positions: function() {\n                    var that = this, i, shape;\n                    that.initialStates = [];\n                    for (i = 0; i < that.shapes.length; i++) {\n                        shape = that.shapes[i];\n                        that.initialStates.push(shape.bounds());\n                    }\n                },\n\n                _hover: function(value, element) {\n                    if (this._resizable()) {\n                        var handleOptions = this._handleOptions(),\n                            hover = handleOptions.hover,\n                            stroke = handleOptions.stroke,\n                            fill = handleOptions.fill;\n\n                        if (value && Utils.isDefined(hover.stroke)) {\n                            stroke = deepExtend({}, stroke, hover.stroke);\n                        }\n\n                        if (value && Utils.isDefined(hover.fill)) {\n                            fill = hover.fill;\n                        }\n                        element.stroke(stroke.color, stroke.width, stroke.opacity);\n                        element.fill(fill.color, fill.opacity);\n                    }\n                },\n\n                start: function(p) {\n                    this._sp = p;\n                    this._cp = p;\n                    this._lp = p;\n                    this._manipulating = true;\n                    this._internalChange = true;\n                    this.shapeStates = [];\n                    for (var i = 0; i < this.shapes.length; i++) {\n                        var shape = this.shapes[i];\n                        this.shapeStates.push(shape.bounds());\n                    }\n                },\n\n                redraw: function() {\n                    var i, handle,\n                        visibleHandles = this._resizable();\n\n                    for (i = 0; i < this.map.length; i++) {\n                        handle = this.map[i];\n                        handle.visual.visible(visibleHandles);\n                    }\n                },\n\n                angle: function(value) {\n                    if (defined(value)) {\n                        this._angle = value;\n                    }\n\n                    return this._angle;\n                },\n\n                rotate: function() {\n                    var center = this._innerBounds.center();\n                    var currentAngle = this.angle();\n                    this._internalChange = true;\n                    for (var i = 0; i < this.shapes.length; i++) {\n                        var shape = this.shapes[i];\n                        currentAngle = (currentAngle + this.initialRotates[i] - this._startAngle) % 360;\n                        shape.rotate(currentAngle, center);\n                    }\n                    this.refresh();\n                },\n\n                move: function(handle, p) {\n                    var delta, dragging,\n                        dtl = new Point(),\n                        dbr = new Point(),\n                        bounds, center, shape,\n                        i, angle, newBounds,\n                        changed = 0, staticPoint,\n                        scaleX, scaleY;\n\n                    if (handle.y === -2 && handle.x === -1) {\n                        center = this._innerBounds.center();\n                        this._angle = this._truncateAngle(Utils.findAngle(center, p));\n                        for (i = 0; i < this.shapes.length; i++) {\n                            shape = this.shapes[i];\n                            angle = (this._angle + this.initialRotates[i] - this._startAngle) % 360;\n                            shape.rotate(angle, center);\n                            if (shape.hasOwnProperty(\"layout\")) {\n                                shape.layout(shape);\n                            }\n                            this._rotating = true;\n                        }\n                        this.refresh();\n                    } else {\n                        if (this.shouldSnap()) {\n                            var thr = this._truncateDistance(p.minus(this._lp));\n                            // threshold\n                            if (thr.x === 0 && thr.y === 0) {\n                                this._cp = p;\n                                return;\n                            }\n                            delta = thr;\n                            this._lp = new Point(this._lp.x + thr.x, this._lp.y + thr.y);\n                        } else {\n                            delta = p.minus(this._cp);\n                        }\n\n                        if (this.isDragHandle(handle)) {\n                            dbr = dtl = delta; // dragging\n                            dragging = true;\n                        } else {\n                            if (this._angle) { // adjust the delta so that resizers resize in the correct direction after rotation.\n                                delta.rotate(this._angle, new Point(0, 0));\n                            }\n                            if (handle.x == -1) {\n                                dtl.x = delta.x;\n                            } else if (handle.x == 1) {\n                                dbr.x = delta.x;\n                            }\n                            if (handle.y == -1) {\n                                dtl.y = delta.y;\n                            } else if (handle.y == 1) {\n                                dbr.y = delta.y;\n                            }\n                        }\n\n                        if (!dragging) {\n                            staticPoint = hitToOppositeSide(handle, this._innerBounds);\n                            scaleX = (this._innerBounds.width + delta.x * handle.x) / this._innerBounds.width;\n                            scaleY = (this._innerBounds.height + delta.y * handle.y) / this._innerBounds.height;\n                        }\n\n                        for (i = 0; i < this.shapes.length; i++) {\n                            shape = this.shapes[i];\n                            bounds = shape.bounds();\n                            if (dragging) {\n                                if (!canDrag(shape)) {\n                                    continue;\n                                }\n                                newBounds = this._displaceBounds(bounds, dtl, dbr, dragging);\n                            } else {\n                                newBounds = bounds.clone();\n                                newBounds.scale(scaleX, scaleY, staticPoint, this._innerBounds.center(), shape.rotate().angle);\n                                var newCenter = newBounds.center(); // fixes the new rotation center.\n                                newCenter.rotate(-this._angle, bounds.center());\n                                newBounds = new Rect(newCenter.x - newBounds.width / 2, newCenter.y - newBounds.height / 2, newBounds.width, newBounds.height);\n                            }\n                            if (newBounds.width >= shape.options.minWidth && newBounds.height >= shape.options.minHeight) { // if we up-size very small shape\n                                var oldBounds = bounds;\n                                shape.bounds(newBounds);\n                                if (shape.hasOwnProperty(\"layout\")) {\n                                    shape.layout(shape, oldBounds, newBounds);\n                                }\n                                if (oldBounds.width !== newBounds.width || oldBounds.height !== newBounds.height) {\n                                    shape.rotate(shape.rotate().angle); // forces the rotation to update it's rotation center\n                                }\n                                changed += 1;\n                            }\n                        }\n\n                        if (changed) {\n                            if (changed == i) {\n                                newBounds = this._displaceBounds(this._innerBounds, dtl, dbr, dragging);\n                                this.bounds(newBounds);\n                            } else {\n                                this.refreshBounds();\n                            }\n                            this.refresh();\n                        }\n\n                        this._positions();\n                    }\n\n                    this._cp = p;\n                },\n\n                isDragHandle: function(handle) {\n                    return handle.x === 0 && handle.y === 0;\n                },\n\n                cancel: function() {\n                    var shapes = this.shapes;\n                    var states = this.shapeStates;\n                    for (var idx = 0; idx < shapes.length; idx++) {\n                        shapes[idx].bounds(states[idx]);\n                    }\n                    this.refreshBounds();\n                    this.refresh();\n                    this._manipulating = undefined$1;\n                    this._internalChange = undefined$1;\n                    this._rotating = undefined$1;\n                },\n\n                _truncatePositionToGuides: function(bounds) {\n                    if (this.diagram.ruler) {\n                        return this.diagram.ruler.truncatePositionToGuides(bounds);\n                    }\n                    return bounds;\n                },\n\n                _truncateSizeToGuides: function(bounds) {\n                    if (this.diagram.ruler) {\n                        return this.diagram.ruler.truncateSizeToGuides(bounds);\n                    }\n                    return bounds;\n                },\n\n                _truncateAngle: function(a) {\n                    var snap = this.snapOptions();\n                    var snapAngle = Math.max(snap.angle || DEFAULT_SNAP_ANGLE, MIN_SNAP_ANGLE);\n                    return snap ? Math.floor((a % 360) / snapAngle) * snapAngle : (a % 360);\n                },\n\n                _truncateDistance: function(d) {\n                    if (d instanceof diagram.Point) {\n                        return new diagram.Point(this._truncateDistance(d.x), this._truncateDistance(d.y));\n                    } else {\n                        var snap = this.snapOptions() || {};\n                        var snapSize = Math.max(snap.size || DEFAULT_SNAP_SIZE, MIN_SNAP_SIZE);\n                        return snap ? Math.floor(d / snapSize) * snapSize : d;\n                    }\n                },\n\n                snapOptions: function() {\n                    var editable = this.diagram.options.editable;\n                    var snap = ((editable || {}).drag || {}).snap || {};\n                    return snap;\n                },\n\n                shouldSnap: function() {\n                    var editable = this.diagram.options.editable;\n                    var drag = (editable || {}).drag;\n                    var snap = (drag || {}).snap;\n                    return editable !== false && drag !== false && snap !== false;\n                },\n\n                _displaceBounds: function(bounds, dtl, dbr, dragging) {\n                    var tl = bounds.topLeft().plus(dtl),\n                        br = bounds.bottomRight().plus(dbr),\n                        newBounds = Rect.fromPoints(tl, br),\n                        newCenter;\n                    if (!dragging) {\n                        newCenter = newBounds.center();\n                        newCenter.rotate(bounds.center(), -this._angle);\n                        newBounds = new Rect(newCenter.x - newBounds.width / 2, newCenter.y - newBounds.height / 2, newBounds.width, newBounds.height);\n                    }\n                    return newBounds;\n                },\n\n                stop: function() {\n                    var unit, i, shape;\n                    if (this._cp != this._sp) {\n                        if (this._rotating) {\n                            unit = new RotateUnit(this, this.shapes, this.initialRotates);\n                            this._rotating = false;\n                        } else if (this._diffStates()) {\n                            if (this.diagram.ruler) {\n                                for (i = 0; i < this.shapes.length; i++) {\n                                    shape = this.shapes[i];\n                                    var bounds = shape.bounds();\n                                    bounds = this._truncateSizeToGuides(this._truncatePositionToGuides(bounds));\n                                    shape.bounds(bounds);\n                                    this.refreshBounds();\n                                    this.refresh();\n                                }\n                            }\n                            for (i = 0; i < this.shapes.length; i++) {\n                                shape = this.shapes[i];\n                                shape.updateModel();\n                            }\n                            unit = new TransformUnit(this.shapes, this.shapeStates, this);\n                            this.diagram._syncShapeChanges();\n                        }\n                    }\n\n                    this._manipulating = undefined$1;\n                    this._internalChange = undefined$1;\n                    this._rotating = undefined$1;\n                    return unit;\n                },\n\n                _diffStates: function() {\n                    var shapes = this.shapes;\n                    var states = this.shapeStates;\n                    for (var idx = 0; idx < shapes.length; idx++) {\n                        if (!shapes[idx].bounds().equals(states[idx])) {\n                            return true;\n                        }\n                    }\n                    return false;\n                },\n\n                refreshBounds: function() {\n                    var bounds = this.shapes.length == 1 ?\n                        this.shapes[0].bounds().clone() :\n                        this.diagram.boundingBox(this.shapes, true);\n\n                    this.bounds(bounds);\n                },\n\n                refresh: function() {\n                    var that = this, b, bounds;\n                    if (this.shapes.length > 0) {\n                        bounds = this.bounds();\n                        this.visual.visible(true);\n                        this.visual.position(bounds.topLeft());\n                        $.each(this.map, function() {\n                            b = that._getHandleBounds(new Point(this.x, this.y));\n                            this.visual.position(b.topLeft());\n                        });\n                        this.visual.position(bounds.topLeft());\n\n                        var center = new Point(bounds.width / 2, bounds.height / 2);\n                        this.visual.rotate(this._angle, center);\n                        this.rect.redraw({ width: bounds.width, height: bounds.height });\n                        if (this.rotationThumb) {\n                            var thumb = this.options.editable.rotate.thumb;\n                            this._rotationThumbBounds = new Rect(bounds.center().x, bounds.y + thumb.y, 0, 0).inflate(thumb.width);\n                            this.rotationThumb.redraw({ x: bounds.width / 2 - thumb.width / 2 });\n                        }\n                    } else {\n                        this.visual.visible(false);\n                    }\n                }\n            });\n\n            var Selector = Class.extend({\n                init: function(diagram) {\n                    var selectable = diagram.options.selectable;\n                    this.options = deepExtend({}, this.options, selectable);\n\n                    this.visual = new Rectangle(this.options);\n                    this.diagram = diagram;\n                },\n                options: {\n                    stroke: {\n                        color: \"#778899\",\n                        width: 1,\n                        dashType: \"dash\"\n                    },\n                    fill: {\n                        color: TRANSPARENT\n                    }\n                },\n                start: function(p) {\n                    this._sp = this._ep = p;\n                    this.refresh();\n                    this.diagram._adorn(this, true);\n                },\n                end: function() {\n                    this._sp = this._ep = undefined$1;\n                    this.diagram._adorn(this, false);\n                },\n                bounds: function(value) {\n                    if (value) {\n                        this._bounds = value;\n                    }\n                    return this._bounds;\n                },\n                move: function(p) {\n                    this._ep = p;\n                    this.refresh();\n                },\n                refresh: function() {\n                    if (this._sp) {\n                        var visualBounds = Rect.fromPoints(this.diagram.modelToLayer(this._sp), this.diagram.modelToLayer(this._ep));\n                        this.bounds(Rect.fromPoints(this._sp, this._ep));\n                        this.visual.position(visualBounds.topLeft());\n                        this.visual.redraw({ height: visualBounds.height + 1, width: visualBounds.width + 1 });\n                    }\n                }\n            });\n\n            var ConnectorVisual = Class.extend({\n                init: function(connector) {\n                    this.options = deepExtend({}, connector.options);\n                    this._c = connector;\n                    this.visual = new Circle(this.options);\n                    this.refresh();\n                },\n                _hover: function(value) {\n                    var options = this.options,\n                        hover = options.hover,\n                        stroke = options.stroke,\n                        fill = options.fill;\n\n                    if (value && Utils.isDefined(hover.stroke)) {\n                        stroke = deepExtend({}, stroke, hover.stroke);\n                    }\n\n                    if (value && Utils.isDefined(hover.fill)) {\n                        fill = hover.fill;\n                    }\n\n                    this.visual.redraw({\n                        stroke: stroke,\n                        fill: fill\n                    });\n                },\n                refresh: function() {\n                    var p = this._c.shape.diagram.modelToView(this._c.position()),\n                        relative = p.minus(this._c.shape.bounds(\"transformed\").topLeft()),\n                        value = new Rect(p.x, p.y, 0, 0);\n                    value.inflate(this.options.width / 2, this.options.height / 2);\n                    this._visualBounds = value;\n                    this.visual.redraw({ center: new Point(relative.x, relative.y) });\n                },\n                _hitTest: function(p) {\n                    var tp = this._c.shape.diagram.modelToView(p);\n                    return this._visualBounds.contains(tp);\n                }\n            });\n\n            function canDrag(element) {\n                var editable = element.options.editable;\n                return editable && editable.drag !== false;\n            }\n\n            function hitTestShapeConnectors(shape, point) {\n                var connector, position, rect;\n                for (var idx = 0; idx < shape.connectors.length; idx++) {\n                    connector = shape.connectors[idx];\n                    position = connector.position();\n                    rect = new Rect(position.x, position.y);\n                    rect.inflate(HIT_TEST_DISTANCE, HIT_TEST_DISTANCE);\n                    if (rect.contains(point)) {\n                        return connector;\n                    }\n                }\n            }\n\n            function noMeta(meta) {\n                return meta.ctrlKey === false && meta.altKey === false && meta.shiftKey === false;\n            }\n\n            deepExtend(diagram, {\n                CompositeUnit: CompositeUnit,\n                TransformUnit: TransformUnit,\n                PanUndoUnit: PanUndoUnit,\n                AddShapeUnit: AddShapeUnit,\n                AddConnectionUnit: AddConnectionUnit,\n                DeleteShapeUnit: DeleteShapeUnit,\n                DeleteConnectionUnit: DeleteConnectionUnit,\n                ConnectionEditAdorner: ConnectionEditAdorner,\n                ConnectionTool: ConnectionTool,\n                ConnectorVisual: ConnectorVisual,\n                UndoRedoService: UndoRedoService,\n                ResizingAdorner: ResizingAdorner,\n                Selector: Selector,\n                ToolService: ToolService,\n                ConnectorsAdorner: ConnectorsAdorner,\n                LayoutUndoUnit: LayoutUndoUnit,\n                ConnectionEditUnit: ConnectionEditUnit,\n                ToFrontUnit: ToFrontUnit,\n                ToBackUnit: ToBackUnit,\n                ConnectionRouterBase: ConnectionRouterBase,\n                PolylineRouter: PolylineRouter,\n                CascadingRouter: CascadingRouter,\n                SelectionTool: SelectionTool,\n                ScrollerTool: ScrollerTool,\n                PointerTool: PointerTool,\n                ConnectionEditTool: ConnectionEditTool,\n                RotateUnit: RotateUnit\n            });\n    })(window.kendo.jQuery);\n\n    (function($, undefined$1) {\n        var kendo = window.kendo,\n            diagram = kendo.dataviz.diagram,\n            Graph = diagram.Graph,\n            Node = diagram.Node,\n            Link = diagram.Link,\n            deepExtend = kendo.deepExtend,\n            Size = diagram.Size,\n            Rect = diagram.Rect,\n            Dictionary = diagram.Dictionary,\n            Set = diagram.Set,\n            HyperTree = diagram.Graph,\n            Utils = diagram.Utils,\n            Point = diagram.Point,\n            EPSILON = 1e-06,\n            DEG_TO_RAD = Math.PI / 180,\n            contains = Utils.contains,\n            grep = $.grep;\n\n        /**\n         * Base class for layout algorithms.\n         * @type {*}\n         */\n        var LayoutBase = kendo.Class.extend({\n            defaultOptions: {\n                type: \"Tree\",\n                subtype: \"Down\",\n                roots: null,\n                animate: false,\n                //-------------------------------------------------------------------\n                /**\n                 * Force-directed option: whether the motion of the nodes should be limited by the boundaries of the diagram surface.\n                 */\n                limitToView: false,\n                /**\n                 * Force-directed option: the amount of friction applied to the motion of the nodes.\n                 */\n                friction: 0.9,\n                /**\n                 * Force-directed option: the optimal distance between nodes (minimum energy).\n                 */\n                nodeDistance: 50,\n                /**\n                 * Force-directed option: the number of time things are being calculated.\n                 */\n                iterations: 300,\n                //-------------------------------------------------------------------\n                /**\n                 * Tree option: the separation in one direction (depends on the subtype what direction this is).\n                 */\n                horizontalSeparation: 90,\n                /**\n                 * Tree option: the separation in the complementary direction (depends on the subtype what direction this is).\n                 */\n                verticalSeparation: 50,\n\n                //-------------------------------------------------------------------\n                /**\n                 * Tip-over tree option: children-to-parent vertical distance.\n                 */\n                underneathVerticalTopOffset: 15,\n                /**\n                 * Tip-over tree option: children-to-parent horizontal distance.\n                 */\n                underneathHorizontalOffset: 15,\n                /**\n                 * Tip-over tree option: leaf-to-next-branch vertical distance.\n                 */\n                underneathVerticalSeparation: 15,\n                //-------------------------------------------------------------------\n                /**\n                 * Settings object to organize the different components of the diagram in a grid layout structure\n                 */\n                grid: {\n                    /**\n                     * The width of the grid in which components are arranged. Beyond this width a component will be on the next row.\n                     */\n                    width: 1500,\n                    /**\n                     * The left offset of the grid.\n                     */\n                    offsetX: 50,\n                    /**\n                     * The top offset of the grid.\n                     */\n                    offsetY: 50,\n                    /**\n                     * The horizontal padding within a cell of the grid where a single component resides.\n                     */\n                    componentSpacingX: 20,\n                    /**\n                     * The vertical padding within a cell of the grid where a single component resides.\n                     */\n                    componentSpacingY: 20\n                },\n\n                //-------------------------------------------------------------------\n                /**\n                 * Layered option: the separation height/width between the layers.\n                 */\n                layerSeparation: 50,\n                /**\n                 * Layered option: how many rounds of shifting and fine-tuning.\n                 */\n                layeredIterations: 2,\n                /**\n                 * Tree-radial option: the angle at which the layout starts.\n                 */\n                startRadialAngle: 0,\n                /**\n                 * Tree-radial option: the angle at which the layout starts.\n                 */\n                endRadialAngle: 360,\n                /**\n                 * Tree-radial option: the separation between levels.\n                 */\n                radialSeparation: 150,\n                /**\n                 * Tree-radial option: the separation between the root and the first level.\n                 */\n                radialFirstLevelSeparation: 200,\n                /**\n                 * Tree-radial option: whether a virtual roots bing the components in one radial layout.\n                 */\n                keepComponentsInOneRadialLayout: false,\n                //-------------------------------------------------------------------\n\n                // TODO: ensure to change this to false when containers are around\n                ignoreContainers: true,\n                layoutContainerChildren: false,\n                ignoreInvisible: true,\n                animateTransitions: false\n            },\n            init: function() {\n            },\n\n            /**\n             * Organizes the components in a grid.\n             * Returns the final set of nodes (not the Graph).\n             * @param components\n             */\n            gridLayoutComponents: function(components) {\n                if (!components) {\n                    throw \"No components supplied.\";\n                }\n\n                // calculate and cache the bounds of the components\n                Utils.forEach(components, function(c) {\n                    c.calcBounds();\n                });\n\n                // order by decreasing width\n                components.sort(function(a, b) {\n                    return b.bounds.width - a.bounds.width;\n                });\n\n                var maxWidth = this.options.grid.width,\n                    offsetX = this.options.grid.componentSpacingX,\n                    offsetY = this.options.grid.componentSpacingY,\n                    height = 0,\n                    startX = this.options.grid.offsetX,\n                    startY = this.options.grid.offsetY,\n                    x = startX,\n                    y = startY,\n                    i,\n                    resultLinkSet = [],\n                    resultNodeSet = [];\n\n                while (components.length > 0) {\n                    if (x >= maxWidth) {\n                        // start a new row\n                        x = startX;\n                        y += height + offsetY;\n                        // reset the row height\n                        height = 0;\n                    }\n                    var component = components.pop();\n                    this.moveToOffset(component, new Point(x, y));\n                    for (i = 0; i < component.nodes.length; i++) {\n                        resultNodeSet.push(component.nodes[i]); // to be returned in the end\n                    }\n                    for (i = 0; i < component.links.length; i++) {\n                        resultLinkSet.push(component.links[i]);\n                    }\n                    var boundingRect = component.bounds;\n                    var currentHeight = boundingRect.height;\n                    if (currentHeight <= 0 || isNaN(currentHeight)) {\n                        currentHeight = 0;\n                    }\n                    var currentWidth = boundingRect.width;\n                    if (currentWidth <= 0 || isNaN(currentWidth)) {\n                        currentWidth = 0;\n                    }\n\n                    if (currentHeight >= height) {\n                        height = currentHeight;\n                    }\n                    x += currentWidth + offsetX;\n                }\n\n                return {\n                    nodes: resultNodeSet,\n                    links: resultLinkSet\n                };\n            },\n\n            moveToOffset: function(component, p) {\n                var i, j,\n                    bounds = component.bounds,\n                    deltax = p.x - bounds.x,\n                    deltay = p.y - bounds.y;\n\n                for (i = 0; i < component.nodes.length; i++) {\n                    var node = component.nodes[i];\n                    var nodeBounds = node.bounds();\n                    if (nodeBounds.width === 0 && nodeBounds.height === 0 && nodeBounds.x === 0 && nodeBounds.y === 0) {\n                        nodeBounds = new Rect(0, 0, 0, 0);\n                    }\n                    nodeBounds.x += deltax;\n                    nodeBounds.y += deltay;\n                    node.bounds(nodeBounds);\n                }\n                for (i = 0; i < component.links.length; i++) {\n                    var link = component.links[i];\n                    if (link.points) {\n                        var newpoints = [];\n                        var points = link.points;\n                        for (j = 0; j < points.length; j++) {\n                            var pt = points[j];\n                            pt.x += deltax;\n                            pt.y += deltay;\n                            newpoints.push(pt);\n                        }\n                        link.points = newpoints;\n                    }\n                }\n                this.currentHorizontalOffset += bounds.width + this.options.grid.offsetX;\n                return new Point(deltax, deltay);\n            },\n\n            transferOptions: function(options) {\n\n                // Size options lead to stackoverflow and need special handling\n\n                this.options = kendo.deepExtend({}, this.defaultOptions);\n                if (Utils.isUndefined(options)) {\n                    return;\n                }\n\n                this.options = kendo.deepExtend(this.options, options || {});\n            }\n        });\n\n        /**\n         * The data bucket a hypertree holds in its nodes.     *\n         * @type {*}\n         */\n        /* var ContainerGraph = kendo.Class.extend({\n         init: function (diagram) {\n         this.diagram = diagram;\n         this.graph = new Graph(diagram);\n         this.container = null;\n         this.containerNode = null;\n         }\n\n         });*/\n\n        /**\n         * Adapter between the diagram control and the graph representation. It converts shape and connections to nodes and edges taking into the containers and their collapsef state,\n         * the visibility of items and more. If the layoutContainerChildren is true a hypertree is constructed which holds the hierarchy of containers and many conditions are analyzed\n         * to investigate how the effective graph structure looks like and how the layout has to be performed.\n         * @type {*}\n         */\n        var DiagramToHyperTreeAdapter = kendo.Class.extend({\n            init: function(diagram) {\n\n                /**\n                 * The mapping to/from the original nodes.\n                 * @type {Dictionary}\n                 */\n                this.nodeMap = new Dictionary();\n\n                /**\n                 * Gets the mapping of a shape to a container in case the shape sits in a collapsed container.\n                 * @type {Dictionary}\n                 */\n                this.shapeMap = new Dictionary();\n\n                /**\n                 * The nodes being mapped.\n                 * @type {Dictionary}\n                 */\n                this.nodes = [];\n\n                /**\n                 * The connections being mapped.\n                 * @type {Dictionary}\n                 */\n                this.edges = [];\n\n                // the mapping from an edge to all the connections it represents, this can be both because of multiple connections between\n                // two shapes or because a container holds multiple connections to another shape or container.\n                this.edgeMap = new Dictionary();\n\n                /**\n                 * The resulting set of Nodes when the analysis has finished.\n                 * @type {Array}\n                 */\n                this.finalNodes = [];\n\n                /**\n                 * The resulting set of Links when the analysis has finished.\n                 * @type {Array}\n                 */\n                this.finalLinks = [];\n\n                /**\n                 * The items being omitted because of multigraph edges.\n                 * @type {Array}\n                 */\n                this.ignoredConnections = [];\n\n                /**\n                 * The items being omitted because of containers, visibility and other factors.\n                 * @type {Array}\n                 */\n                this.ignoredShapes = [];\n\n                /**\n                 * The map from a node to the partition/hypernode in which it sits. This hyperMap is null if 'options.layoutContainerChildren' is false.\n                 * @type {Dictionary}\n                 */\n                this.hyperMap = new Dictionary();\n\n                /**\n                 * The hypertree contains the hierarchy defined by the containers.\n                 * It's in essence a Graph of Graphs with a tree structure defined by the hierarchy of containers.\n                 * @type {HyperTree}\n                 */\n                this.hyperTree = new Graph();\n\n                /**\n                 * The resulting graph after conversion. Note that this does not supply the information contained in the\n                 * ignored connection and shape collections.\n                 * @type {null}\n                 */\n                this.finalGraph = null;\n\n                this.diagram = diagram;\n            },\n\n            /**\n             * The hyperTree is used when the 'options.layoutContainerChildren' is true. It contains the hierarchy of containers whereby each node is a ContainerGraph.\n             * This type of node has a Container reference to the container which holds the Graph items. There are three possible situations during the conversion process:\n             *  - Ignore the containers: the container are non-existent and only normal shapes are mapped. If a shape has a connection to a container it will be ignored as well\n             *    since there is no node mapped for the container.\n             *  - Do not ignore the containers and leave the content of the containers untouched: the top-level elements are being mapped and the children within a container are not altered.\n             *  - Do not ignore the containers and organize the content of the containers as well: the hypertree is constructed and there is a partitioning of all nodes and connections into the hypertree.\n             *    The only reason a connection or node is not being mapped might be due to the visibility, which includes the visibility change through a collapsed parent container.\n             * @param options\n             */\n            convert: function(options) {\n\n                if (Utils.isUndefined(this.diagram)) {\n                    throw \"No diagram to convert.\";\n                }\n\n                this.options = kendo.deepExtend({\n                        ignoreInvisible: true,\n                        ignoreContainers: true,\n                        layoutContainerChildren: false\n                    },\n                    options || {}\n                );\n\n                this.clear();\n                // create the nodes which participate effectively in the graph analysis\n                this._renormalizeShapes();\n\n                // recreate the incoming and outgoing collections of each and every node\n                this._renormalizeConnections();\n\n                // export the resulting graph\n                this.finalNodes = new Dictionary(this.nodes);\n                this.finalLinks = new Dictionary(this.edges);\n\n                this.finalGraph = new Graph();\n                this.finalNodes.forEach(function(n) {\n                    this.finalGraph.addNode(n);\n                }, this);\n                this.finalLinks.forEach(function(l) {\n                    this.finalGraph.addExistingLink(l);\n                }, this);\n                return this.finalGraph;\n            },\n\n            /**\n             * Maps the specified connection to an edge of the graph deduced from the given diagram.\n             * @param connection\n             * @returns {*}\n             */\n            mapConnection: function(connection) {\n                return this.edgeMap.get(connection.id);\n            },\n\n            /**\n             * Maps the specified shape to a node of the graph deduced from the given diagram.\n             * @param shape\n             * @returns {*}\n             */\n            mapShape: function(shape) {\n                return this.nodeMap.get(shape.id);\n            },\n\n            /**\n             * Gets the edge, if any, between the given nodes.\n             * @param a\n             * @param b\n             */\n            getEdge: function(a, b) {\n                return Utils.first(a.links, function(link) {\n                    return link.getComplement(a) === b;\n                });\n            },\n\n            /**\n             * Clears all the collections used by the conversion process.\n             */\n            clear: function() {\n                this.finalGraph = null;\n                this.hyperTree = (!this.options.ignoreContainers && this.options.layoutContainerChildren) ? new HyperTree() : null;\n                this.hyperMap = (!this.options.ignoreContainers && this.options.layoutContainerChildren) ? new Dictionary() : null;\n                this.nodeMap = new Dictionary();\n                this.shapeMap = new Dictionary();\n                this.nodes = [];\n                this.edges = [];\n                this.edgeMap = new Dictionary();\n                this.ignoredConnections = [];\n                this.ignoredShapes = [];\n                this.finalNodes = [];\n                this.finalLinks = [];\n            },\n\n            /**\n             * The path from a given ContainerGraph to the root (container).\n             * @param containerGraph\n             * @returns {Array}\n             */\n            listToRoot: function(containerGraph) {\n                var list = [];\n                var s = containerGraph.container;\n                if (!s) {\n                    return list;\n                }\n                list.push(s);\n                while (s.parentContainer) {\n                    s = s.parentContainer;\n                    list.push(s);\n                }\n                list.reverse();\n                return list;\n            },\n\n            firstNonIgnorableContainer: function(shape) {\n\n                if (shape.isContainer && !this._isIgnorableItem(shape)) {\n                    return shape;\n                }\n                return !shape.parentContainer ? null : this.firstNonIgnorableContainer(shape.parentContainer);\n            },\n            isContainerConnection: function(a, b) {\n                if (a.isContainer && this.isDescendantOf(a, b)) {\n                    return true;\n                }\n                return b.isContainer && this.isDescendantOf(b, a);\n            },\n\n            /**\n             * Returns true if the given shape is a direct child or a nested container child of the given container.\n             * If the given container and shape are the same this will return false since a shape cannot be its own child.\n             * @param scope\n             * @param a\n             * @returns {boolean}\n             */\n            isDescendantOf: function(scope, a) {\n                if (!scope.isContainer) {\n                    throw \"Expecting a container.\";\n                }\n                if (scope === a) {\n                    return false;\n                }\n                if (contains(scope.children, a)) {\n                    return true;\n                }\n                var containers = [];\n                for (var i = 0, len = scope.children.length; i < len; i++) {\n                    var c = scope.children[i];\n                    if (c.isContainer && this.isDescendantOf(c, a)) {\n                        containers.push(c);\n                    }\n                }\n\n                return containers.length > 0;\n            },\n            isIgnorableItem: function(shape) {\n                if (this.options.ignoreInvisible) {\n                    if (shape.isCollapsed && this._isVisible(shape)) {\n                        return false;\n                    }\n                    if (!shape.isCollapsed && this._isVisible(shape)) {\n                        return false;\n                    }\n                    return true;\n                }\n                else {\n                    return shape.isCollapsed && !this._isTop(shape);\n                }\n            },\n\n            /**\n             *  Determines whether the shape is or needs to be mapped to another shape. This occurs essentially when the shape sits in\n             * a collapsed container hierarchy and an external connection needs a node endpoint. This node then corresponds to the mapped shape and is\n             * necessarily a container in the parent hierarchy of the shape.\n             * @param shape\n             */\n            isShapeMapped: function(shape) {\n                return shape.isCollapsed && !this._isVisible(shape) && !this._isTop(shape);\n            },\n\n            leastCommonAncestor: function(a, b) {\n                if (!a) {\n                    throw \"Parameter should not be null.\";\n                }\n                if (!b) {\n                    throw \"Parameter should not be null.\";\n                }\n\n                if (!this.hyperTree) {\n                    throw \"No hypertree available.\";\n                }\n                var al = this.listToRoot(a);\n                var bl = this.listToRoot(b);\n                var found = null;\n                if (Utils.isEmpty(al) || Utils.isEmpty(bl)) {\n                    return this.hyperTree.root.data;\n                }\n                var xa = al[0];\n                var xb = bl[0];\n                var i = 0;\n                while (xa === xb) {\n                    found = al[i];\n                    i++;\n                    if (i >= al.length || i >= bl.length) {\n                        break;\n                    }\n                    xa = al[i];\n                    xb = bl[i];\n                }\n                if (!found) {\n                    return this.hyperTree.root.data;\n                }\n                else {\n                    return grep(this.hyperTree.nodes, function(n) {\n                        return n.data.container === found;\n                    });\n                }\n            },\n            /**\n             * Determines whether the specified item is a top-level shape or container.\n             * @param item\n             * @returns {boolean}\n             * @private\n             */\n            _isTop: function(item) {\n                return !item.parentContainer;\n            },\n\n            /**\n             * Determines iteratively (by walking up the container stack) whether the specified shape is visible.\n             * This does NOT tell whether the item is not visible due to an explicit Visibility change or due to a collapse state.\n             * @param shape\n             * @returns {*}\n             * @private\n             */\n            _isVisible: function(shape) {\n\n                if (!shape.visible()) {\n                    return false;\n                }\n                return !shape.parentContainer ? shape.visible() : this._isVisible(shape.parentContainer);\n            },\n\n            _isCollapsed: function(shape) {\n\n                if (shape.isContainer && shape.isCollapsed) {\n                    return true;\n                }\n                return shape.parentContainer && this._isCollapsed(shape.parentContainer);\n            },\n\n            /**\n             * First part of the graph creation; analyzing the shapes and containers and deciding whether they should be mapped to a Node.\n             * @private\n             */\n            _renormalizeShapes: function() {\n                // add the nodes, the adjacency structure will be reconstructed later on\n                if (this.options.ignoreContainers) {\n                    for (var i = 0, len = this.diagram.shapes.length; i < len; i++) {\n                        var shape = this.diagram.shapes[i];\n\n                        // if not visible (and ignoring the invisible ones) or a container we skip\n                        if ((this.options.ignoreInvisible && !this._isVisible(shape)) || shape.isContainer) {\n                            this.ignoredShapes.push(shape);\n                            continue;\n                        }\n                        var node = new Node(shape.id, shape);\n                        node.isVirtual = false;\n\n                        // the mapping will always contain singletons and the hyperTree will be null\n                        this.nodeMap.add(shape.id, node);\n                        this.nodes.push(node);\n                    }\n                }\n                else {\n                    throw \"Containers are not supported yet, but stay tuned.\";\n                }\n            },\n\n            /**\n             * Second part of the graph creation; analyzing the connections and deciding whether they should be mapped to an edge.\n             * @private\n             */\n            _renormalizeConnections: function() {\n                if (this.diagram.connections.length === 0) {\n                    return;\n                }\n                for (var i = 0, len = this.diagram.connections.length; i < len; i++) {\n                    var conn = this.diagram.connections[i];\n\n                    if (this.isIgnorableItem(conn)) {\n                        this.ignoredConnections.push(conn);\n                        continue;\n                    }\n\n                    var source = !conn.sourceConnector ? null : conn.sourceConnector.shape;\n                    var sink = !conn.targetConnector ? null : conn.targetConnector.shape;\n\n                    // no layout for floating connections\n                    if (!source || !sink) {\n                        this.ignoredConnections.push(conn);\n                        continue;\n                    }\n\n                    if (contains(this.ignoredShapes, source) && !this.shapeMap.containsKey(source)) {\n                        this.ignoredConnections.push(conn);\n                        continue;\n                    }\n                    if (contains(this.ignoredShapes, sink) && !this.shapeMap.containsKey(sink)) {\n                        this.ignoredConnections.push(conn);\n                        continue;\n                    }\n\n                    // if the endpoint sits in a collapsed container we need the container rather than the shape itself\n                    if (this.shapeMap.containsKey(source)) {\n                        source = this.shapeMap[source];\n                    }\n                    if (this.shapeMap.containsKey(sink)) {\n                        sink = this.shapeMap[sink];\n                    }\n\n                    var sourceNode = this.mapShape(source);\n                    var sinkNode = this.mapShape(sink);\n                    if ((sourceNode === sinkNode) || this.areConnectedAlready(sourceNode, sinkNode)) {\n                        this.ignoredConnections.push(conn);\n                        continue;\n                    }\n\n                    if (sourceNode === null || sinkNode === null) {\n                        throw \"A shape was not mapped to a node.\";\n                    }\n                    if (this.options.ignoreContainers) {\n                        // much like a floating connection here since at least one end is attached to a container\n                        if (sourceNode.isVirtual || sinkNode.isVirtual) {\n                            this.ignoredConnections.push(conn);\n                            continue;\n                        }\n                        var newEdge = new Link(sourceNode, sinkNode, conn.id, conn);\n\n                        this.edgeMap.add(conn.id, newEdge);\n                        this.edges.push(newEdge);\n                    }\n                    else {\n                        throw \"Containers are not supported yet, but stay tuned.\";\n                    }\n                }\n            },\n\n            areConnectedAlready: function(n, m) {\n                return Utils.any(this.edges, function(l) {\n                    return l.source === n && l.target === m || l.source === m && l.target === n;\n                });\n            }\n\n            /**\n             * Depth-first traversal of the given container.\n             * @param container\n             * @param action\n             * @param includeStart\n             * @private\n             */\n            /* _visitContainer: function (container, action, includeStart) {\n\n             *//*if (container == null) throw new ArgumentNullException(\"container\");\n             if (action == null) throw new ArgumentNullException(\"action\");\n             if (includeStart) action(container);\n             if (container.children.isEmpty()) return;\n             foreach(\n             var item\n             in\n             container.children.OfType < IShape > ()\n             )\n             {\n             var childContainer = item\n             as\n             IContainerShape;\n             if (childContainer != null) this.VisitContainer(childContainer, action);\n             else action(item);\n             }*//*\n             }*/\n\n\n        });\n\n        /**\n         * The classic spring-embedder (aka force-directed, Fruchterman-Rheingold, barycentric) algorithm.\n         * http://en.wikipedia.org/wiki/Force-directed_graph_drawing\n         *  - Chapter 12 of Tamassia et al. \"Handbook of graph drawing and visualization\".\n         *  - Kobourov on preprint arXiv; http://arxiv.org/pdf/1201.3011.pdf\n         *  - Fruchterman and Rheingold in SOFTWARE-PRACTICE AND EXPERIENCE, VOL. 21(1 1), 1129-1164 (NOVEMBER 1991)\n         * @type {*}\n         */\n        var SpringLayout = LayoutBase.extend({\n            init: function(diagram) {\n                var that = this;\n                LayoutBase.fn.init.call(that);\n                if (Utils.isUndefined(diagram)) {\n                    throw \"Diagram is not specified.\";\n                }\n                this.diagram = diagram;\n            },\n\n            layout: function(options) {\n\n                this.transferOptions(options);\n\n                var adapter = new DiagramToHyperTreeAdapter(this.diagram);\n                var graph = adapter.convert(options);\n                if (graph.isEmpty()) {\n                    return;\n                }\n                // split into connected components\n                var components = graph.getConnectedComponents();\n                if (Utils.isEmpty(components)) {\n                    return;\n                }\n                for (var i = 0; i < components.length; i++) {\n                    var component = components[i];\n                    this.layoutGraph(component, options);\n                }\n                var finalNodeSet = this.gridLayoutComponents(components);\n                return new diagram.LayoutState(this.diagram, finalNodeSet);\n            },\n\n            layoutGraph: function(graph, options) {\n\n                if (Utils.isDefined(options)) {\n                    this.transferOptions(options);\n                }\n                this.graph = graph;\n\n                var initialTemperature = this.options.nodeDistance * 9;\n                this.temperature = initialTemperature;\n\n                var guessBounds = this._expectedBounds();\n                this.width = guessBounds.width;\n                this.height = guessBounds.height;\n\n                for (var step = 0; step < this.options.iterations; step++) {\n                    this.refineStage = step >= this.options.iterations * 5 / 6;\n                    this.tick();\n                    // exponential cooldown\n                    this.temperature = this.refineStage ?\n                        initialTemperature / 30 :\n                        initialTemperature * (1 - step / (2 * this.options.iterations ));\n                }\n            },\n\n            /**\n             * Single iteration of the simulation.\n             */\n            tick: function() {\n                var i;\n                // collect the repulsive forces on each node\n                for (i = 0; i < this.graph.nodes.length; i++) {\n                    this._repulsion(this.graph.nodes[i]);\n                }\n\n                // collect the attractive forces on each node\n                for (i = 0; i < this.graph.links.length; i++) {\n                    this._attraction(this.graph.links[i]);\n                }\n                // update the positions\n                for (i = 0; i < this.graph.nodes.length; i++) {\n                    var node = this.graph.nodes[i];\n                    var offset = Math.sqrt(node.dx * node.dx + node.dy * node.dy);\n                    if (offset === 0) {\n                        return;\n                    }\n                    node.x += Math.min(offset, this.temperature) * node.dx / offset;\n                    node.y += Math.min(offset, this.temperature) * node.dy / offset;\n                    if (this.options.limitToView) {\n                        node.x = Math.min(this.width, Math.max(node.width / 2, node.x));\n                        node.y = Math.min(this.height, Math.max(node.height / 2, node.y));\n                    }\n                }\n            },\n\n            /**\n             * Shakes the node away from its current position to escape the deadlock.\n             * @param node A Node.\n             * @private\n             */\n            _shake: function(node) {\n                // just a simple polar neighborhood\n                var rho = Math.random() * this.options.nodeDistance / 4;\n                var alpha = Math.random() * 2 * Math.PI;\n                node.x += rho * Math.cos(alpha);\n                node.y -= rho * Math.sin(alpha);\n            },\n\n            /**\n             * The typical Coulomb-Newton force law F=k/r^2\n             * @remark This only works in dimensions less than three.\n             * @param d\n             * @param n A Node.\n             * @param m Another Node.\n             * @returns {number}\n             * @private\n             */\n            _InverseSquareForce: function(d, n, m) {\n                var force;\n                if (!this.refineStage) {\n                    force = Math.pow(d, 2) / Math.pow(this.options.nodeDistance, 2);\n                }\n                else {\n                    var deltax = n.x - m.x;\n                    var deltay = n.y - m.y;\n\n                    var wn = n.width / 2;\n                    var hn = n.height / 2;\n                    var wm = m.width / 2;\n                    var hm = m.height / 2;\n\n                    force = (Math.pow(deltax, 2) / Math.pow(wn + wm + this.options.nodeDistance, 2)) + (Math.pow(deltay, 2) / Math.pow(hn + hm + this.options.nodeDistance, 2));\n                }\n                return force * 4 / 3;\n            },\n\n            /**\n             * The typical Hooke force law F=kr^2\n             * @param d\n             * @param n\n             * @param m\n             * @returns {number}\n             * @private\n             */\n            _SquareForce: function(d, n, m) {\n                return 1 / this._InverseSquareForce(d, n, m);\n            },\n\n            _repulsion: function(n) {\n                n.dx = 0;\n                n.dy = 0;\n                Utils.forEach(this.graph.nodes, function(m) {\n                    if (m === n) {\n                        return;\n                    }\n                    while (n.x === m.x && n.y === m.y) {\n                        this._shake(m);\n                    }\n                    var vx = n.x - m.x;\n                    var vy = n.y - m.y;\n                    var distance = Math.sqrt(vx * vx + vy * vy);\n                    var r = this._SquareForce(distance, n, m) * 2;\n                    n.dx += (vx / distance) * r;\n                    n.dy += (vy / distance) * r;\n                }, this);\n            },\n            _attraction: function(link) {\n                var t = link.target;\n                var s = link.source;\n                if (s === t) {\n                    // loops induce endless shakes\n                    return;\n                }\n                while (s.x === t.x && s.y === t.y) {\n                    this._shake(t);\n                }\n\n                var vx = s.x - t.x;\n                var vy = s.y - t.y;\n                var distance = Math.sqrt(vx * vx + vy * vy);\n\n                var a = this._InverseSquareForce(distance, s, t) * 5;\n                var dx = (vx / distance) * a;\n                var dy = (vy / distance) * a;\n                t.dx += dx;\n                t.dy += dy;\n                s.dx -= dx;\n                s.dy -= dy;\n            },\n\n            /**\n             * Calculates the expected bounds after layout.\n             * @returns {*}\n             * @private\n             */\n            _expectedBounds: function() {\n\n                var size, N = this.graph.nodes.length, /*golden ration optimal?*/ ratio = 1.5, multiplier = 4;\n                if (N === 0) {\n                    return size;\n                }\n                size = Utils.fold(this.graph.nodes, function(s, node) {\n                    var area = node.width * node.height;\n                    if (area > 0) {\n                        s += Math.sqrt(area);\n                        return s;\n                    }\n                    return 0;\n                }, 0, this);\n                var av = size / N;\n                var squareSize = av * Math.ceil(Math.sqrt(N));\n                var width = squareSize * Math.sqrt(ratio);\n                var height = squareSize / Math.sqrt(ratio);\n                return { width: width * multiplier, height: height * multiplier };\n            }\n\n        });\n\n        var TreeLayoutProcessor = kendo.Class.extend({\n\n            init: function(options) {\n                this.center = null;\n                this.options = options;\n            },\n            layout: function(treeGraph, root) {\n                this.graph = treeGraph;\n                if (!this.graph.nodes || this.graph.nodes.length === 0) {\n                    return;\n                }\n\n                if (!contains(this.graph.nodes, root)) {\n                    throw \"The given root is not in the graph.\";\n                }\n\n                this.center = root;\n                this.graph.cacheRelationships();\n                /* var nonull = this.graph.nodes.where(function (n) {\n                 return n.associatedShape != null;\n                 });*/\n\n                // transfer the rects\n                /*nonull.forEach(function (n) {\n                 n.Location = n.associatedShape.Position;\n                 n.NodeSize = n.associatedShape.ActualBounds.ToSize();\n                 }\n\n                 );*/\n\n                // caching the children\n                /* nonull.forEach(function (n) {\n                 n.children = n.getChildren();\n                 });*/\n\n                this.layoutSwitch();\n\n                // apply the layout to the actual visuals\n                // nonull.ForEach(n => n.associatedShape.Position = n.Location);\n            },\n\n            layoutLeft: function(left) {\n                this.setChildrenDirection(this.center, \"Left\", false);\n                this.setChildrenLayout(this.center, \"Default\", false);\n                var h = 0, w = 0, y, i, node;\n                for (i = 0; i < left.length; i++) {\n                    node = left[i];\n                    node.TreeDirection = \"Left\";\n                    var s = this.measure(node, Size.Empty);\n                    w = Math.max(w, s.Width);\n                    h += s.height + this.options.verticalSeparation;\n                }\n\n                h -= this.options.verticalSeparation;\n                var x = this.center.x - this.options.horizontalSeparation;\n                y = this.center.y + ((this.center.height - h) / 2);\n                for (i = 0; i < left.length; i++) {\n                    node = left[i];\n                    var p = new Point(x - node.Size.width, y);\n\n                    this.arrange(node, p);\n                    y += node.Size.height + this.options.verticalSeparation;\n                }\n            },\n\n            layoutRight: function(right) {\n                this.setChildrenDirection(this.center, \"Right\", false);\n                this.setChildrenLayout(this.center, \"Default\", false);\n                var h = 0, w = 0, y, i, node;\n                for (i = 0; i < right.length; i++) {\n                    node = right[i];\n                    node.TreeDirection = \"Right\";\n                    var s = this.measure(node, Size.Empty);\n                    w = Math.max(w, s.Width);\n                    h += s.height + this.options.verticalSeparation;\n                }\n\n                h -= this.options.verticalSeparation;\n                var x = this.center.x + this.options.horizontalSeparation + this.center.width;\n                y = this.center.y + ((this.center.height - h) / 2);\n                for (i = 0; i < right.length; i++) {\n                    node = right[i];\n                    var p = new Point(x, y);\n                    this.arrange(node, p);\n                    y += node.Size.height + this.options.verticalSeparation;\n                }\n            },\n\n            layoutUp: function(up) {\n                this.setChildrenDirection(this.center, \"Up\", false);\n                this.setChildrenLayout(this.center, \"Default\", false);\n                var w = 0, y, node, i;\n                for (i = 0; i < up.length; i++) {\n                    node = up[i];\n                    node.TreeDirection = \"Up\";\n                    var s = this.measure(node, Size.Empty);\n                    w += s.width + this.options.horizontalSeparation;\n                }\n\n                w -= this.options.horizontalSeparation;\n                var x = this.center.x + (this.center.width / 2) - (w / 2);\n\n                // y = this.center.y -verticalSeparation -this.center.height/2 - h;\n                for (i = 0; i < up.length; i++) {\n                    node = up[i];\n                    y = this.center.y - this.options.verticalSeparation - node.Size.height;\n                    var p = new Point(x, y);\n                    this.arrange(node, p);\n                    x += node.Size.width + this.options.horizontalSeparation;\n                }\n            },\n\n            layoutDown: function(down) {\n                var node, i;\n                this.setChildrenDirection(this.center, \"Down\", false);\n                this.setChildrenLayout(this.center, \"Default\", false);\n                var w = 0, y;\n                for (i = 0; i < down.length; i++) {\n                    node = down[i];\n                    node.treeDirection = \"Down\";\n                    var s = this.measure(node, Size.Empty);\n                    w += s.width + this.options.horizontalSeparation;\n                }\n\n                w -= this.options.horizontalSeparation;\n                var x = this.center.x + (this.center.width / 2) - (w / 2);\n                y = this.center.y + this.options.verticalSeparation + this.center.height;\n                for (i = 0; i < down.length; i++) {\n                    node = down[i];\n                    var p = new Point(x, y);\n                    this.arrange(node, p);\n                    x += node.Size.width + this.options.horizontalSeparation;\n                }\n            },\n\n            layoutRadialTree: function() {\n                // var rmax = children.Aggregate(0D, (current, node) => Math.max(node.SectorAngle, current));\n                this.setChildrenDirection(this.center, \"Radial\", false);\n                this.setChildrenLayout(this.center, \"Default\", false);\n                this.previousRoot = null;\n                var startAngle = this.options.startRadialAngle * DEG_TO_RAD;\n                var endAngle = this.options.endRadialAngle * DEG_TO_RAD;\n                if (endAngle <= startAngle) {\n                    throw \"Final angle should not be less than the start angle.\";\n                }\n\n                this.maxDepth = 0;\n                this.origin = new Point(this.center.x, this.center.y);\n                this.calculateAngularWidth(this.center, 0);\n\n                // perform the layout\n                if (this.maxDepth > 0) {\n                    this.radialLayout(this.center, this.options.radialFirstLevelSeparation, startAngle, endAngle);\n                }\n\n                // update properties of the root node\n                this.center.Angle = endAngle - startAngle;\n            },\n\n            tipOverTree: function(down, startFromLevel) {\n                if (Utils.isUndefined(startFromLevel)) {\n                    startFromLevel = 0;\n                }\n\n                this.setChildrenDirection(this.center, \"Down\", false);\n                this.setChildrenLayout(this.center, \"Default\", false);\n                this.setChildrenLayout(this.center, \"Underneath\", false, startFromLevel);\n                var w = 0, y, node, i;\n                for (i = 0; i < down.length; i++) {\n                    node = down[i];\n\n                    // if (node.IsSpecial) continue;\n                    node.TreeDirection = \"Down\";\n                    var s = this.measure(node, Size.Empty);\n                    w += s.width + this.options.horizontalSeparation;\n                }\n\n                w -= this.options.horizontalSeparation;\n\n                // putting the root in the center with respect to the whole diagram is not a nice result, let's put it with respect to the first level only\n                w -= down[down.length - 1].width;\n                w += down[down.length - 1].associatedShape.bounds().width;\n\n                var x = this.center.x + (this.center.width / 2) - (w / 2);\n                y = this.center.y + this.options.verticalSeparation + this.center.height;\n                for (i = 0; i < down.length; i++) {\n                    node = down[i];\n                    // if (node.IsSpecial) continue;\n                    var p = new Point(x, y);\n                    this.arrange(node, p);\n                    x += node.Size.width + this.options.horizontalSeparation;\n                }\n\n                /*//let's place the special node, assuming there is only one\n                 if (down.Count(n => n.IsSpecial) > 0)\n                 {\n                 var special = (from n in down where n.IsSpecial select n).First();\n                 if (special.Children.Count > 0)\n                 throw new DiagramException(\"The 'special' element should not have children.\");\n                 special.Data.Location = new Point(Center.Data.Location.X + Center.AssociatedShape.BoundingRectangle.Width + this.options.HorizontalSeparation, Center.Data.Location.Y);\n                 }*/\n            },\n            calculateAngularWidth: function(n, d) {\n                if (d > this.maxDepth) {\n                    this.maxDepth = d;\n                }\n\n                var aw = 0, w = 1000, h = 1000, diameter = d === 0 ? 0 : Math.sqrt((w * w) + (h * h)) / d;\n\n                if (n.children.length > 0) {\n                    // eventually with n.IsExpanded\n                    for (var i = 0, len = n.children.length; i < len; i++) {\n                        var child = n.children[i];\n                        aw += this.calculateAngularWidth(child, d + 1);\n                    }\n                    aw = Math.max(diameter, aw);\n                }\n                else {\n                    aw = diameter;\n                }\n\n                n.sectorAngle = aw;\n                return aw;\n            },\n            sortChildren: function(n) {\n                var basevalue = 0, i;\n\n                // update basevalue angle for node ordering\n                if (n.parents.length > 1) {\n                    throw \"Node is not part of a tree.\";\n                }\n                var p = n.parents[0];\n                if (p) {\n                    var pl = new Point(p.x, p.y);\n                    var nl = new Point(n.x, n.y);\n                    basevalue = this.normalizeAngle(Math.atan2(pl.y - nl.y, pl.x - nl.x));\n                }\n\n                var count = n.children.length;\n                if (count === 0) {\n                    return null;\n                }\n\n                var angle = [];\n                var idx = [];\n\n                for (i = 0; i < count; ++i) {\n                    var c = n.children[i];\n                    var l = new Point(c.x, c.y);\n                    idx[i] = i;\n                    angle[i] = this.normalizeAngle(-basevalue + Math.atan2(l.y - l.y, l.x - l.x));\n                }\n\n                Utils.bisort(angle, idx);\n                var col = []; // list of nodes\n                var children = n.children;\n                for (i = 0; i < count; ++i) {\n                    col.push(children[idx[i]]);\n                }\n\n                return col;\n            },\n\n            normalizeAngle: function(angle) {\n                while (angle > Math.PI * 2) {\n                    angle -= 2 * Math.PI;\n                }\n                while (angle < 0) {\n                    angle += Math.PI * 2;\n                }\n                return angle;\n            },\n            radialLayout: function(node, radius, startAngle, endAngle) {\n                var deltaTheta = endAngle - startAngle;\n                var deltaThetaHalf = deltaTheta / 2.0;\n                var parentSector = node.sectorAngle;\n                var fraction = 0;\n                var sorted = this.sortChildren(node);\n                for (var i = 0, len = sorted.length; i < len; i++) {\n                    var childNode = sorted[i];\n                    var cp = childNode;\n                    var childAngleFraction = cp.sectorAngle / parentSector;\n                    if (childNode.children.length > 0) {\n                        this.radialLayout(childNode,\n                            radius + this.options.radialSeparation,\n                            startAngle + (fraction * deltaTheta),\n                            startAngle + ((fraction + childAngleFraction) * deltaTheta));\n                    }\n\n                    this.setPolarLocation(childNode, radius, startAngle + (fraction * deltaTheta) + (childAngleFraction * deltaThetaHalf));\n                    cp.angle = childAngleFraction * deltaTheta;\n                    fraction += childAngleFraction;\n                }\n            },\n            setPolarLocation: function(node, radius, angle) {\n                node.x = this.origin.x + (radius * Math.cos(angle));\n                node.y = this.origin.y + (radius * Math.sin(angle));\n                node.BoundingRectangle = new Rect(node.x, node.y, node.width, node.height);\n            },\n\n            /**\n             * Sets the children direction recursively.\n             * @param node\n             * @param direction\n             * @param includeStart\n             */\n            setChildrenDirection: function(node, direction, includeStart) {\n                var rootDirection = node.treeDirection;\n                this.graph.depthFirstTraversal(node, function(n) {\n                    n.treeDirection = direction;\n                });\n                if (!includeStart) {\n                    node.treeDirection = rootDirection;\n                }\n            },\n\n            /**\n             * Sets the children layout recursively.\n             * @param node\n             * @param layout\n             * @param includeStart\n             * @param startFromLevel\n             */\n            setChildrenLayout: function(node, layout, includeStart, startFromLevel) {\n                if (Utils.isUndefined(startFromLevel)) {\n                    startFromLevel = 0;\n                }\n                var rootLayout = node.childrenLayout;\n                if (startFromLevel > 0) {\n                    // assign levels to the Node.Level property\n                    this.graph.assignLevels(node);\n\n                    // assign the layout on the condition that the level is at least the 'startFromLevel'\n                    this.graph.depthFirstTraversal(\n                        node, function(s) {\n                            if (s.level >= startFromLevel + 1) {\n                                s.childrenLayout = layout;\n                            }\n                        }\n                    );\n                }\n                else {\n                    this.graph.depthFirstTraversal(node, function(s) {\n                        s.childrenLayout = layout;\n                    });\n\n                    // if the start should not be affected we put the state back\n                    if (!includeStart) {\n                        node.childrenLayout = rootLayout;\n                    }\n                }\n            },\n\n            /**\n             * Returns the actual size of the node. The given size is the allowed space wherein the node can lay out itself.\n             * @param node\n             * @param givenSize\n             * @returns {Size}\n             */\n            measure: function(node, givenSize) {\n                var w = 0, h = 0, s;\n                var result = new Size(0, 0);\n                if (!node) {\n                    throw \"\";\n                }\n                var b = node.associatedShape.bounds();\n                var shapeWidth = b.width;\n                var shapeHeight = b.height;\n                if (node.parents.length !== 1) {\n                    throw \"Node not in a spanning tree.\";\n                }\n\n                var parent = node.parents[0];\n                if (node.treeDirection === \"Undefined\") {\n                    node.treeDirection = parent.treeDirection;\n                }\n\n                if (Utils.isEmpty(node.children)) {\n                    result = new Size(\n                        Math.abs(shapeWidth) < EPSILON ? 50 : shapeWidth,\n                        Math.abs(shapeHeight) < EPSILON ? 25 : shapeHeight);\n                }\n                else if (node.children.length === 1) {\n                    switch (node.treeDirection) {\n                        case \"Radial\":\n                            s = this.measure(node.children[0], givenSize); // child size\n                            w = shapeWidth + (this.options.radialSeparation * Math.cos(node.AngleToParent)) + s.width;\n                            h = shapeHeight + Math.abs(this.options.radialSeparation * Math.sin(node.AngleToParent)) + s.height;\n                            break;\n                        case \"Left\":\n                        case \"Right\":\n                            switch (node.childrenLayout) {\n\n                                case \"TopAlignedWithParent\":\n                                    break;\n\n                                case \"BottomAlignedWithParent\":\n                                    break;\n\n                                case \"Underneath\":\n                                    s = this.measure(node.children[0], givenSize);\n                                    w = shapeWidth + s.width + this.options.underneathHorizontalOffset;\n                                    h = shapeHeight + this.options.underneathVerticalTopOffset + s.height;\n                                    break;\n\n                                case \"Default\":\n                                    s = this.measure(node.children[0], givenSize);\n                                    w = shapeWidth + this.options.horizontalSeparation + s.width;\n                                    h = Math.max(shapeHeight, s.height);\n                                    break;\n\n                                default:\n                                    throw \"Unhandled TreeDirection in the Radial layout measuring.\";\n                            }\n                            break;\n                        case \"Up\":\n                        case \"Down\":\n                            switch (node.childrenLayout) {\n\n                                case \"TopAlignedWithParent\":\n                                case \"BottomAlignedWithParent\":\n                                    break;\n\n                                case \"Underneath\":\n                                    s = this.measure(node.children[0], givenSize);\n                                    w = Math.max(shapeWidth, s.width + this.options.underneathHorizontalOffset);\n                                    h = shapeHeight + this.options.underneathVerticalTopOffset + s.height;\n                                    break;\n\n                                case \"Default\":\n                                    s = this.measure(node.children[0], givenSize);\n                                    h = shapeHeight + this.options.verticalSeparation + s.height;\n                                    w = Math.max(shapeWidth, s.width);\n                                    break;\n\n                                default:\n                                    throw \"Unhandled TreeDirection in the Down layout measuring.\";\n                            }\n                            break;\n                        default:\n                            throw \"Unhandled TreeDirection in the layout measuring.\";\n                    }\n\n                    result = new Size(w, h);\n                }\n                else {\n                    var i, childNode;\n                    switch (node.treeDirection) {\n                        case \"Left\":\n                        case \"Right\":\n                            switch (node.childrenLayout) {\n\n                                case \"TopAlignedWithParent\":\n                                case \"BottomAlignedWithParent\":\n                                    break;\n\n                                case \"Underneath\":\n                                    w = shapeWidth;\n                                    h = shapeHeight + this.options.underneathVerticalTopOffset;\n                                    for (i = 0; i < node.children.length; i++) {\n                                        childNode = node.children[i];\n                                        s = this.measure(childNode, givenSize);\n                                        w = Math.max(w, s.width + this.options.underneathHorizontalOffset);\n                                        h += s.height + this.options.underneathVerticalSeparation;\n                                    }\n\n                                    h -= this.options.underneathVerticalSeparation;\n                                    break;\n\n                                case \"Default\":\n                                    w = shapeWidth;\n                                    h = 0;\n                                    for (i = 0; i < node.children.length; i++) {\n                                        childNode = node.children[i];\n                                        s = this.measure(childNode, givenSize);\n                                        w = Math.max(w, shapeWidth + this.options.horizontalSeparation + s.width);\n                                        h += s.height + this.options.verticalSeparation;\n                                    }\n                                    h -= this.options.verticalSeparation;\n                                    break;\n\n                                default:\n                                    throw \"Unhandled TreeDirection in the Right layout measuring.\";\n                            }\n\n                            break;\n                        case \"Up\":\n                        case \"Down\":\n\n                            switch (node.childrenLayout) {\n\n                                case \"TopAlignedWithParent\":\n                                case \"BottomAlignedWithParent\":\n                                    break;\n\n                                case \"Underneath\":\n                                    w = shapeWidth;\n                                    h = shapeHeight + this.options.underneathVerticalTopOffset;\n                                    for (i = 0; i < node.children.length; i++) {\n                                        childNode = node.children[i];\n                                        s = this.measure(childNode, givenSize);\n                                        w = Math.max(w, s.width + this.options.underneathHorizontalOffset);\n                                        h += s.height + this.options.underneathVerticalSeparation;\n                                    }\n\n                                    h -= this.options.underneathVerticalSeparation;\n                                    break;\n\n                                case \"Default\":\n                                    w = 0;\n                                    h = 0;\n                                    for (i = 0; i < node.children.length; i++) {\n                                        childNode = node.children[i];\n                                        s = this.measure(childNode, givenSize);\n                                        w += s.width + this.options.horizontalSeparation;\n                                        h = Math.max(h, s.height + this.options.verticalSeparation + shapeHeight);\n                                    }\n\n                                    w -= this.options.horizontalSeparation;\n                                    break;\n\n                                default:\n                                    throw \"Unhandled TreeDirection in the Down layout measuring.\";\n                            }\n\n                            break;\n                        default:\n                            throw \"Unhandled TreeDirection in the layout measuring.\";\n                    }\n\n                    result = new Size(w, h);\n                }\n\n                node.SectorAngle = Math.sqrt((w * w / 4) + (h * h / 4));\n                node.Size = result;\n                return result;\n            },\n            arrange: function(n, p) {\n                var i, pp, child, node, childrenwidth, b = n.associatedShape.bounds();\n                var shapeWidth = b.width;\n                var shapeHeight = b.height;\n                if (Utils.isEmpty(n.children)) {\n                    n.x = p.x;\n                    n.y = p.y;\n                    n.BoundingRectangle = new Rect(p.x, p.y, shapeWidth, shapeHeight);\n                }\n                else {\n                    var x, y;\n                    var selfLocation;\n                    switch (n.treeDirection) {\n                        case \"Left\":\n                            switch (n.childrenLayout) {\n                                case \"TopAlignedWithParent\":\n                                case \"BottomAlignedWithParent\":\n                                    break;\n\n                                case \"Underneath\":\n                                    selfLocation = p;\n                                    n.x = selfLocation.x;\n                                    n.y = selfLocation.y;\n                                    n.BoundingRectangle = new Rect(n.x, n.y, n.width, n.height);\n                                    y = p.y + shapeHeight + this.options.underneathVerticalTopOffset;\n                                    for (i = 0; i < node.children.length; i++) {\n                                        node = node.children[i];\n                                        x = selfLocation.x - node.associatedShape.width - this.options.underneathHorizontalOffset;\n                                        pp = new Point(x, y);\n                                        this.arrange(node, pp);\n                                        y += node.Size.height + this.options.underneathVerticalSeparation;\n                                    }\n                                    break;\n\n                                case \"Default\":\n                                    selfLocation = new Point(p.x + n.Size.width - shapeWidth, p.y + ((n.Size.height - shapeHeight) / 2));\n                                    n.x = selfLocation.x;\n                                    n.y = selfLocation.y;\n                                    n.BoundingRectangle = new Rect(n.x, n.y, n.width, n.height);\n                                    x = selfLocation.x - this.options.horizontalSeparation; // alignment of children\n                                    y = p.y;\n                                    for (i = 0; i < n.children.length; i++) {\n                                        node = n.children[i];\n                                        pp = new Point(x - node.Size.width, y);\n                                        this.arrange(node, pp);\n                                        y += node.Size.height + this.options.verticalSeparation;\n                                    }\n                                    break;\n\n                                default:\n                                    throw \"Unsupported TreeDirection\";\n                            }\n\n                            break;\n                        case \"Right\":\n                            switch (n.childrenLayout) {\n                                case \"TopAlignedWithParent\":\n                                case \"BottomAlignedWithParent\":\n                                    break;\n\n                                case \"Underneath\":\n                                    selfLocation = p;\n                                    n.x = selfLocation.x;\n                                    n.y = selfLocation.y;\n                                    n.BoundingRectangle = new Rect(n.x, n.y, n.width, n.height);\n                                    x = p.x + shapeWidth + this.options.underneathHorizontalOffset;\n\n                                    // alignment of children left-underneath the parent\n                                    y = p.y + shapeHeight + this.options.underneathVerticalTopOffset;\n                                    for (i = 0; i < n.children.length; i++) {\n                                        node = n.children[i];\n                                        pp = new Point(x, y);\n                                        this.arrange(node, pp);\n                                        y += node.Size.height + this.options.underneathVerticalSeparation;\n                                    }\n\n                                    break;\n\n                                case \"Default\":\n                                    selfLocation = new Point(p.x, p.y + ((n.Size.height - shapeHeight) / 2));\n                                    n.x = selfLocation.x;\n                                    n.y = selfLocation.y;\n                                    n.BoundingRectangle = new Rect(n.x, n.y, n.width, n.height);\n                                    x = p.x + shapeWidth + this.options.horizontalSeparation; // alignment of children\n                                    y = p.y;\n                                    for (i = 0; i < n.children.length; i++) {\n                                        node = n.children[i];\n                                        pp = new Point(x, y);\n                                        this.arrange(node, pp);\n                                        y += node.Size.height + this.options.verticalSeparation;\n                                    }\n                                    break;\n\n                                default:\n                                    throw \"Unsupported TreeDirection\";\n                            }\n\n                            break;\n                        case \"Up\":\n                            selfLocation = new Point(p.x + ((n.Size.width - shapeWidth) / 2), p.y + n.Size.height - shapeHeight);\n                            n.x = selfLocation.x;\n                            n.y = selfLocation.y;\n                            n.BoundingRectangle = new Rect(n.x, n.y, n.width, n.height);\n                            if (Math.abs(selfLocation.x - p.x) < EPSILON) {\n                                childrenwidth = 0;\n                                // means there is an aberration due to the oversized Element with respect to the children\n                                for (i = 0; i < n.children.length; i++) {\n                                    child = n.children[i];\n                                    childrenwidth += child.Size.width + this.options.horizontalSeparation;\n                                }\n                                childrenwidth -= this.options.horizontalSeparation;\n                                x = p.x + ((shapeWidth - childrenwidth) / 2);\n                            }\n                            else {\n                                x = p.x;\n                            }\n\n                            for (i = 0; i < n.children.length; i++) {\n                                node = n.children[i];\n                                y = selfLocation.y - this.options.verticalSeparation - node.Size.height;\n                                pp = new Point(x, y);\n                                this.arrange(node, pp);\n                                x += node.Size.width + this.options.horizontalSeparation;\n                            }\n                            break;\n\n                        case \"Down\":\n\n                            switch (n.childrenLayout) {\n                                case \"TopAlignedWithParent\":\n                                case \"BottomAlignedWithParent\":\n                                    break;\n                                case \"Underneath\":\n                                    selfLocation = p;\n                                    n.x = selfLocation.x;\n                                    n.y = selfLocation.y;\n                                    n.BoundingRectangle = new Rect(n.x, n.y, n.width, n.height);\n                                    x = p.x + this.options.underneathHorizontalOffset; // alignment of children left-underneath the parent\n                                    y = p.y + shapeHeight + this.options.underneathVerticalTopOffset;\n                                    for (i = 0; i < n.children.length; i++) {\n                                        node = n.children[i];\n                                        pp = new Point(x, y);\n                                        this.arrange(node, pp);\n                                        y += node.Size.height + this.options.underneathVerticalSeparation;\n                                    }\n                                    break;\n\n                                case \"Default\":\n                                    selfLocation = new Point(p.x + ((n.Size.width - shapeWidth) / 2), p.y);\n                                    n.x = selfLocation.x;\n                                    n.y = selfLocation.y;\n                                    n.BoundingRectangle = new Rect(n.x, n.y, n.width, n.height);\n                                    if (Math.abs(selfLocation.x - p.x) < EPSILON) {\n                                        childrenwidth = 0;\n                                        // means there is an aberration due to the oversized Element with respect to the children\n                                        for (i = 0; i < n.children.length; i++) {\n                                            child = n.children[i];\n                                            childrenwidth += child.Size.width + this.options.horizontalSeparation;\n                                        }\n\n                                        childrenwidth -= this.options.horizontalSeparation;\n                                        x = p.x + ((shapeWidth - childrenwidth) / 2);\n                                    }\n                                    else {\n                                        x = p.x;\n                                    }\n\n                                    for (i = 0; i < n.children.length; i++) {\n                                        node = n.children[i];\n                                        y = selfLocation.y + this.options.verticalSeparation + shapeHeight;\n                                        pp = new Point(x, y);\n                                        this.arrange(node, pp);\n                                        x += node.Size.width + this.options.horizontalSeparation;\n                                    }\n                                    break;\n\n                                default:\n                                    throw \"Unsupported TreeDirection\";\n                            }\n                            break;\n\n                        case \"None\":\n                            break;\n\n                        default:\n                            throw \"Unsupported TreeDirection\";\n                    }\n                }\n            },\n            layoutSwitch: function() {\n                if (!this.center) {\n                    return;\n                }\n\n                if (Utils.isEmpty(this.center.children)) {\n                    return;\n                }\n\n                var type = this.options.subtype;\n                if (Utils.isUndefined(type)) {\n                    type = \"Down\";\n                }\n                var single, male, female, leftcount;\n                var children = this.center.children;\n                switch (type.toLowerCase()) {\n                    case \"radial\":\n                    case \"radialtree\":\n                        this.layoutRadialTree();\n                        break;\n\n                    case \"mindmaphorizontal\":\n                    case \"mindmap\":\n                        single = this.center.children;\n\n                        if (this.center.children.length === 1) {\n                            this.layoutRight(single);\n                        }\n                        else {\n                            // odd number will give one more at the right\n                            leftcount = children.length / 2;\n                            male = grep(this.center.children, function(n) {\n                                return Utils.indexOf(children, n) < leftcount;\n                            });\n                            female = grep(this.center.children, function(n) {\n                                return Utils.indexOf(children, n) >= leftcount;\n                            });\n\n                            this.layoutLeft(male);\n                            this.layoutRight(female);\n                        }\n                        break;\n\n                    case \"mindmapvertical\":\n                        single = this.center.children;\n\n                        if (this.center.children.length === 1) {\n                            this.layoutDown(single);\n                        }\n                        else {\n                            // odd number will give one more at the right\n                            leftcount = children.length / 2;\n                            male = grep(this.center.children, function(n) {\n                                return Utils.indexOf(children, n) < leftcount;\n                            });\n                            female = grep(this.center.children, function(n) {\n                                return Utils.indexOf(children, n) >= leftcount;\n                            });\n                            this.layoutUp(male);\n                            this.layoutDown(female);\n                        }\n                        break;\n\n                    case \"right\":\n                        this.layoutRight(this.center.children);\n                        break;\n\n                    case \"left\":\n                        this.layoutLeft(this.center.children);\n                        break;\n\n                    case \"up\":\n                    case \"bottom\":\n                        this.layoutUp(this.center.children);\n                        break;\n\n                    case \"down\":\n                    case \"top\":\n                        this.layoutDown(this.center.children);\n                        break;\n\n                    case \"tipover\":\n                    case \"tipovertree\":\n                        if (this.options.tipOverTreeStartLevel < 0) {\n                            throw \"The tip-over level should be a positive integer.\";\n                        }\n                        this.tipOverTree(this.center.children, this.options.tipOverTreeStartLevel);\n                        break;\n\n                    case \"undefined\":\n                    case \"none\":\n                        break;\n                }\n            }\n        });\n\n        /**\n         * The various tree layout algorithms.\n         * @type {*}\n         */\n        var TreeLayout = LayoutBase.extend({\n            init: function(diagram) {\n                var that = this;\n                LayoutBase.fn.init.call(that);\n                if (Utils.isUndefined(diagram)) {\n                    throw \"No diagram specified.\";\n                }\n                this.diagram = diagram;\n            },\n\n            /**\n             * Arranges the diagram in a tree-layout with the specified options and tree subtype.\n             */\n            layout: function(options) {\n\n                this.transferOptions(options);\n\n                // transform the diagram into a Graph\n                var adapter = new DiagramToHyperTreeAdapter(this.diagram);\n\n                /**\n                 * The Graph reduction from the given diagram.\n                 * @type {*}\n                 */\n                this.graph = adapter.convert();\n\n                var finalNodeSet = this.layoutComponents();\n\n                // note that the graph contains the original data and\n                // the components are another instance of nodes referring to the same set of shapes\n                return new diagram.LayoutState(this.diagram, finalNodeSet);\n            },\n\n            layoutComponents: function() {\n                if (this.graph.isEmpty()) {\n                    return;\n                }\n\n                // split into connected components\n                var components = this.graph.getConnectedComponents();\n                if (Utils.isEmpty(components)) {\n                    return;\n                }\n\n                var layout = new TreeLayoutProcessor(this.options);\n                var trees = [];\n                // find a spanning tree for each component\n                for (var i = 0; i < components.length; i++) {\n                    var component = components[i];\n\n                    var treeGraph = this.getTree(component);\n                    if (!treeGraph) {\n                        throw \"Failed to find a spanning tree for the component.\";\n                    }\n                    var root = treeGraph.root;\n                    var tree = treeGraph.tree;\n                    layout.layout(tree, root);\n\n                    trees.push(tree);\n                }\n\n                return this.gridLayoutComponents(trees);\n\n            },\n\n            /**\n             * Gets a spanning tree (and root) for the given graph.\n             * Ensure that the given graph is connected!\n             * @param graph\n             * @returns {*} A literal object consisting of the found root and the spanning tree.\n             */\n            getTree: function(graph) {\n                var root = null;\n                if (this.options.roots && this.options.roots.length > 0) {\n                    for (var i = 0, len = graph.nodes.length; i < len; i++) {\n                        var node = graph.nodes[i];\n                        for (var j = 0; j < this.options.roots.length; j++) {\n                            var givenRootShape = this.options.roots[j];\n                            if (givenRootShape === node.associatedShape) {\n                                root = node;\n                                break;\n                            }\n                        }\n                    }\n                }\n                if (!root) {\n                    // finds the most probable root on the basis of the longest path in the component\n                    root = graph.root();\n                    // should not happen really\n                    if (!root) {\n                        throw \"Unable to find a root for the tree.\";\n                    }\n                }\n                return this.getTreeForRoot(graph, root);\n            },\n\n            getTreeForRoot: function(graph, root) {\n\n                var tree = graph.getSpanningTree(root);\n                if (Utils.isUndefined(tree) || tree.isEmpty()) {\n                    return null;\n                }\n                return {\n                    tree: tree,\n                    root: tree.root\n                };\n            }\n\n        });\n\n        /**\n         * The Sugiyama aka layered layout algorithm.\n         * @type {*}\n         */\n        var LayeredLayout = LayoutBase.extend({\n            init: function(diagram) {\n                var that = this;\n                LayoutBase.fn.init.call(that);\n                if (Utils.isUndefined(diagram)) {\n                    throw \"Diagram is not specified.\";\n                }\n                this.diagram = diagram;\n            },\n\n            layout: function(options) {\n\n                this.transferOptions(options);\n\n                var adapter = new DiagramToHyperTreeAdapter(this.diagram);\n                var graph = adapter.convert(options);\n                if (graph.isEmpty()) {\n                    return;\n                }\n                // split into connected components\n                var components = graph.getConnectedComponents();\n                if (Utils.isEmpty(components)) {\n                    return;\n                }\n                for (var i = 0; i < components.length; i++) {\n                    var component = components[i];\n                    this.layoutGraph(component, options);\n                }\n                var finalNodeSet = this.gridLayoutComponents(components);\n                return new diagram.LayoutState(this.diagram, finalNodeSet);\n\n            },\n\n            /**\n             * Initializes the runtime data properties of the layout.\n             * @private\n             */\n            _initRuntimeProperties: function() {\n                for (var k = 0; k < this.graph.nodes.length; k++) {\n                    var node = this.graph.nodes[k];\n                    node.layer = -1;\n                    node.downstreamLinkCount = 0;\n                    node.upstreamLinkCount = 0;\n\n                    node.isVirtual = false;\n\n                    node.uBaryCenter = 0.0;\n                    node.dBaryCenter = 0.0;\n\n                    node.upstreamPriority = 0;\n                    node.downstreamPriority = 0;\n\n                    node.gridPosition = 0;\n                }\n            },\n            _prepare: function(graph) {\n                var current = [], i, l, link;\n\n                // defines a mapping of a node to the layer index\n                var layerMap = new Dictionary();\n                var layerCount = 0;\n                var targetLayer, next, target;\n\n                Utils.forEach(graph.nodes, function(node) {\n                    if (node.incoming.length === 0) {\n                        layerMap.set(node, 0);\n                        current.push(node);\n                    }\n                });\n\n                while (current.length > 0) {\n                    next = current.shift();\n                    for (i = 0; i < next.outgoing.length; i++) {\n                        link = next.outgoing[i];\n                        target = link.target;\n\n                        if (layerMap.containsKey(target)) {\n                            targetLayer = Math.max(layerMap.get(next) + 1, layerMap.get(target));\n                        } else {\n                            targetLayer = layerMap.get(next) + 1;\n                        }\n                        layerMap.set(target, targetLayer);\n                        if (targetLayer > layerCount) {\n                            layerCount = targetLayer;\n                        }\n\n                        if (!contains(current, target)) {\n                            current.push(target);\n                        }\n                    }\n                }\n\n                var sortedNodes = layerMap.keys();\n\n                sortedNodes.sort(function(o1, o2) {\n                    var o1layer = layerMap.get(o1);\n                    var o2layer = layerMap.get(o2);\n                    return Utils.sign(o2layer - o1layer);\n                });\n\n                for (var n = 0; n < sortedNodes.length; ++n) {\n                    var node = sortedNodes[n];\n                    var minLayer = Number.MAX_VALUE;\n\n                    if (node.outgoing.length === 0) {\n                        continue;\n                    }\n\n                    for (l = 0; l < node.outgoing.length; ++l) {\n                        link = node.outgoing[l];\n                        minLayer = Math.min(minLayer, layerMap.get(link.target));\n                    }\n\n                    if (minLayer > 1) {\n                        layerMap.set(node, minLayer - 1);\n                    }\n                }\n\n                this.layers = [];\n                var layer;\n                for (i = 0; i < layerCount + 1; i++) {\n                    layer = [];\n                    layer.linksTo = {};\n                    this.layers.push(layer);\n                }\n\n                layerMap.forEach(function(node, layer) {\n                    node.layer = layer;\n                    this.layers[layer].push(node);\n                }, this);\n\n                // set initial grid positions\n                for (l = 0; l < this.layers.length; l++) {\n                    layer = this.layers[l];\n                    for (i = 0; i < layer.length; i++) {\n                        layer[i].gridPosition = i;\n                    }\n                }\n            },\n            /**\n             * Performs the layout of a single component.\n             */\n            layoutGraph: function(graph, options) {\n                if (Utils.isUndefined(graph)) {\n                    throw \"No graph given or graph analysis of the diagram failed.\";\n                }\n                if (Utils.isDefined(options)) {\n                    this.transferOptions(options);\n                }\n                this.graph = graph;\n\n                // sets unique indices on the nodes\n                graph.setItemIndices();\n\n                // ensures no cycles present for this layout\n                var reversedEdges = graph.makeAcyclic();\n\n                // define the runtime props being used by the layout algorithm\n                this._initRuntimeProperties();\n\n                this._prepare(graph, options);\n\n                this._dummify();\n\n                this._optimizeCrossings();\n\n                this._swapPairs();\n\n                this.arrangeNodes();\n\n                this._moveThingsAround();\n\n                this._dedummify();\n\n                // re-reverse the links which were switched earlier\n                Utils.forEach(reversedEdges, function(e) {\n                    if (e.points) {\n                        e.points.reverse();\n                    }\n                });\n            },\n\n            setMinDist: function(m, n, minDist) {\n                var l = m.layer;\n                var i = m.layerIndex;\n                this.minDistances[l][i] = minDist;\n            },\n\n            getMinDist: function(m, n) {\n                var dist = 0,\n                    i1 = m.layerIndex,\n                    i2 = n.layerIndex,\n                    l = m.layer,\n                    min = Math.min(i1, i2),\n                    max = Math.max(i1, i2);\n                // use Sum()?\n                for (var k = min; k < max; ++k) {\n                    dist += this.minDistances[l][k];\n                }\n                return dist;\n            },\n\n            placeLeftToRight: function(leftClasses) {\n                var leftPos = new Dictionary(), n, node;\n                for (var c = 0; c < this.layers.length; ++c) {\n                    var classNodes = leftClasses[c];\n                    if (!classNodes) {\n                        continue;\n                    }\n\n                    for (n = 0; n < classNodes.length; n++) {\n                        node = classNodes[n];\n                        if (!leftPos.containsKey(node)) {\n                            this.placeLeft(node, leftPos, c);\n                        }\n                    }\n\n                    // adjust class\n                    var d = Number.POSITIVE_INFINITY;\n                    for (n = 0; n < classNodes.length; n++) {\n                        node = classNodes[n];\n                        var rightSibling = this.rightSibling(node);\n                        if (rightSibling && this.nodeLeftClass.get(rightSibling) !== c) {\n                            d = Math.min(d, leftPos.get(rightSibling) - leftPos.get(node) - this.getMinDist(node, rightSibling));\n                        }\n                    }\n                    if (d === Number.POSITIVE_INFINITY) {\n                        var D = [];\n                        for (n = 0; n < classNodes.length; n++) {\n                            node = classNodes[n];\n                            var neighbors = [];\n                            Utils.addRange(neighbors, this.upNodes.get(node));\n                            Utils.addRange(neighbors, this.downNodes.get(node));\n\n                            for (var e = 0; e < neighbors.length; e++) {\n                                var neighbor = neighbors[e];\n                                if (this.nodeLeftClass.get(neighbor) < c) {\n                                    D.push(leftPos.get(neighbor) - leftPos.get(node));\n                                }\n                            }\n                        }\n                        D.sort();\n                        if (D.length === 0) {\n                            d = 0;\n                        }\n                        else if (D.length % 2 === 1) {\n                            d = D[this.intDiv(D.length, 2)];\n                        }\n                        else {\n                            d = (D[this.intDiv(D.length, 2) - 1] + D[this.intDiv(D.length, 2)]) / 2;\n                        }\n                    }\n                    for (n = 0; n < classNodes.length; n++) {\n                        node = classNodes[n];\n                        leftPos.set(node, leftPos.get(node) + d);\n                    }\n                }\n                return leftPos;\n            },\n\n            placeRightToLeft: function(rightClasses) {\n                var rightPos = new Dictionary(), n, node;\n                for (var c = 0; c < this.layers.length; ++c) {\n                    var classNodes = rightClasses[c];\n                    if (!classNodes) {\n                        continue;\n                    }\n\n                    for (n = 0; n < classNodes.length; n++) {\n                        node = classNodes[n];\n                        if (!rightPos.containsKey(node)) {\n                            this.placeRight(node, rightPos, c);\n                        }\n                    }\n\n                    // adjust class\n                    var d = Number.NEGATIVE_INFINITY;\n                    for (n = 0; n < classNodes.length; n++) {\n                        node = classNodes[n];\n                        var leftSibling = this.leftSibling(node);\n                        if (leftSibling && this.nodeRightClass.get(leftSibling) !== c) {\n                            d = Math.max(d, rightPos.get(leftSibling) - rightPos.get(node) + this.getMinDist(leftSibling, node));\n                        }\n                    }\n                    if (d === Number.NEGATIVE_INFINITY) {\n                        var D = [];\n                        for (n = 0; n < classNodes.length; n++) {\n                            node = classNodes[n];\n                            var neighbors = [];\n                            Utils.addRange(neighbors, this.upNodes.get(node));\n                            Utils.addRange(neighbors, this.downNodes.get(node));\n\n                            for (var e = 0; e < neighbors.length; e++) {\n                                var neighbor = neighbors[e];\n                                if (this.nodeRightClass.get(neighbor) < c) {\n                                    D.push(rightPos.get(node) - rightPos.get(neighbor));\n                                }\n                            }\n                        }\n                        D.sort();\n                        if (D.length === 0) {\n                            d = 0;\n                        }\n                        else if (D.length % 2 === 1) {\n                            d = D[this.intDiv(D.length, 2)];\n                        }\n                        else {\n                            d = (D[this.intDiv(D.length, 2) - 1] + D[this.intDiv(D.length, 2)]) / 2;\n                        }\n                    }\n                    for (n = 0; n < classNodes.length; n++) {\n                        node = classNodes[n];\n                        rightPos.set(node, rightPos.get(node) + d);\n                    }\n                }\n                return rightPos;\n            },\n\n            _getLeftWing: function() {\n                var leftWing = { value: null };\n                var result = this.computeClasses(leftWing, 1);\n                this.nodeLeftClass = leftWing.value;\n                return result;\n            },\n\n            _getRightWing: function() {\n                var rightWing = { value: null };\n                var result = this.computeClasses(rightWing, -1);\n                this.nodeRightClass = rightWing.value;\n                return result;\n            },\n\n            computeClasses: function(wingPair, d) {\n                var currentWing = 0,\n                    wing = wingPair.value = new Dictionary();\n\n                for (var l = 0; l < this.layers.length; ++l) {\n                    currentWing = l;\n\n                    var layer = this.layers[l];\n                    for (var n = d === 1 ? 0 : layer.length - 1; n >= 0 && n < layer.length; n += d) {\n                        var node = layer[n];\n                        if (!wing.containsKey(node)) {\n                            wing.set(node, currentWing);\n                            if (node.isVirtual) {\n                                var ndsinl = this._nodesInLink(node);\n                                for (var kk = 0; kk < ndsinl.length; kk++) {\n                                    var vnode = ndsinl[kk];\n                                    wing.set(vnode, currentWing);\n                                }\n                            }\n                        }\n                        else {\n                            currentWing = wing.get(node);\n                        }\n                    }\n                }\n\n                var wings = [];\n                for (var i = 0; i < this.layers.length; i++) {\n                    wings.push(null);\n                }\n                wing.forEach(function(node, classIndex) {\n                    if (wings[classIndex] === null) {\n                        wings[classIndex] = [];\n                    }\n                    wings[classIndex].push(node);\n                });\n\n                return wings;\n            },\n            _isVerticalLayout: function() {\n                return this.options.subtype.toLowerCase() === \"up\" || this.options.subtype.toLowerCase() === \"down\" || this.options.subtype.toLowerCase() === \"vertical\";\n            },\n\n            _isHorizontalLayout: function() {\n                return this.options.subtype.toLowerCase() === \"right\" || this.options.subtype.toLowerCase() === \"left\" || this.options.subtype.toLowerCase() === \"horizontal\";\n            },\n            _isIncreasingLayout: function() {\n                // meaning that the visiting of the layers goes in the natural order of increasing layer index\n                return this.options.subtype.toLowerCase() === \"right\" || this.options.subtype.toLowerCase() === \"down\";\n            },\n            _moveThingsAround: function() {\n                var i, l, node, layer, n, w;\n                // sort the layers by their grid position\n                for (l = 0; l < this.layers.length; ++l) {\n                    layer = this.layers[l];\n                    layer.sort(this._gridPositionComparer);\n                }\n\n                this.minDistances = [];\n                for (l = 0; l < this.layers.length; ++l) {\n                    layer = this.layers[l];\n                    this.minDistances[l] = [];\n                    for (n = 0; n < layer.length; ++n) {\n                        node = layer[n];\n                        node.layerIndex = n;\n                        this.minDistances[l][n] = this.options.nodeDistance;\n                        if (n < layer.length - 1) {\n                            if (this._isVerticalLayout()) {\n                                this.minDistances[l][n] += (node.width + layer[n + 1].width) / 2;\n                            }\n                            else {\n                                this.minDistances[l][n] += (node.height + layer[n + 1].height) / 2;\n                            }\n                        }\n                    }\n                }\n\n                this.downNodes = new Dictionary();\n                this.upNodes = new Dictionary();\n                Utils.forEach(this.graph.nodes, function(node) {\n                    this.downNodes.set(node, []);\n                    this.upNodes.set(node, []);\n                }, this);\n                Utils.forEach(this.graph.links, function(link) {\n                    var origin = link.source;\n                    var dest = link.target;\n                    var down = null, up = null;\n                    if (origin.layer > dest.layer) {\n                        down = link.source;\n                        up = link.target;\n                    }\n                    else {\n                        up = link.source;\n                        down = link.target;\n                    }\n                    this.downNodes.get(up).push(down);\n                    this.upNodes.get(down).push(up);\n                }, this);\n                this.downNodes.forEachValue(function(list) {\n                    list.sort(this._gridPositionComparer);\n                }, this);\n                this.upNodes.forEachValue(function(list) {\n                    list.sort(this._gridPositionComparer);\n                }, this);\n\n                for (l = 0; l < this.layers.length - 1; ++l) {\n                    layer = this.layers[l];\n                    for (w = 0; w < layer.length - 1; w++) {\n                        var currentNode = layer[w];\n                        if (!currentNode.isVirtual) {\n                            continue;\n                        }\n\n                        var currDown = this.downNodes.get(currentNode)[0];\n                        if (!currDown.isVirtual) {\n                            continue;\n                        }\n\n                        for (n = w + 1; n < layer.length; ++n) {\n                            node = layer[n];\n                            if (!node.isVirtual) {\n                                continue;\n                            }\n\n                            var downNode = this.downNodes.get(node)[0];\n                            if (!downNode.isVirtual) {\n                                continue;\n                            }\n\n                            if (currDown.gridPosition > downNode.gridPosition) {\n                                var pos = currDown.gridPosition;\n                                currDown.gridPosition = downNode.gridPosition;\n                                downNode.gridPosition = pos;\n                                var i1 = currDown.layerIndex;\n                                var i2 = downNode.layerIndex;\n                                this.layers[l + 1][i1] = downNode;\n                                this.layers[l + 1][i2] = currDown;\n                                currDown.layerIndex = i2;\n                                downNode.layerIndex = i1;\n                            }\n                        }\n                    }\n                }\n\n\n                var leftClasses = this._getLeftWing();\n                var rightClasses = this._getRightWing();\n\n\n                var leftPos = this.placeLeftToRight(leftClasses);\n                var rightPos = this.placeRightToLeft(rightClasses);\n                var x = new Dictionary();\n                Utils.forEach(this.graph.nodes, function(node) {\n                    x.set(node, (leftPos.get(node) + rightPos.get(node)) / 2);\n                });\n\n\n                var order = new Dictionary();\n                var placed = new Dictionary();\n                for (l = 0; l < this.layers.length; ++l) {\n                    layer = this.layers[l];\n                    var sequenceStart = -1, sequenceEnd = -1;\n                    for (n = 0; n < layer.length; ++n) {\n                        node = layer[n];\n                        order.set(node, 0);\n                        placed.set(node, false);\n                        if (node.isVirtual) {\n                            if (sequenceStart === -1) {\n                                sequenceStart = n;\n                            }\n                            else if (sequenceStart === n - 1) {\n                                sequenceStart = n;\n                            }\n                            else {\n                                sequenceEnd = n;\n                                order.set(layer[sequenceStart], 0);\n                                if (x.get(node) - x.get(layer[sequenceStart]) === this.getMinDist(layer[sequenceStart], node)) {\n                                    placed.set(layer[sequenceStart], true);\n                                }\n                                else {\n                                    placed.set(layer[sequenceStart], false);\n                                }\n                                sequenceStart = n;\n                            }\n                        }\n                    }\n                }\n                var directions = [1, -1];\n                Utils.forEach(directions, function(d) {\n                    var start = d === 1 ? 0 : this.layers.length - 1;\n                    for (var l = start; l >= 0 && l < this.layers.length; l += d) {\n                        var layer = this.layers[l];\n                        var virtualStartIndex = this._firstVirtualNode(layer);\n                        var virtualStart = null;\n                        var sequence = null;\n                        if (virtualStartIndex !== -1) {\n                            virtualStart = layer[virtualStartIndex];\n                            sequence = [];\n                            for (i = 0; i < virtualStartIndex; i++) {\n                                sequence.push(layer[i]);\n                            }\n                        }\n                        else {\n                            virtualStart = null;\n                            sequence = layer;\n                        }\n                        if (sequence.length > 0) {\n                            this._sequencer(x, null, virtualStart, d, sequence);\n                            for (i = 0; i < sequence.length - 1; ++i) {\n                                this.setMinDist(sequence[i], sequence[i + 1], x.get(sequence[i + 1]) - x.get(sequence[i]));\n                            }\n                            if (virtualStart) {\n                                this.setMinDist(sequence[sequence.length - 1], virtualStart, x.get(virtualStart) - x.get(sequence[sequence.length - 1]));\n                            }\n                        }\n\n                        while (virtualStart) {\n                            var virtualEnd = this.nextVirtualNode(layer, virtualStart);\n                            if (!virtualEnd) {\n                                virtualStartIndex = virtualStart.layerIndex;\n                                sequence = [];\n                                for (i = virtualStartIndex + 1; i < layer.length; i++) {\n                                    sequence.push(layer[i]);\n                                }\n                                if (sequence.length > 0) {\n                                    this._sequencer(x, virtualStart, null, d, sequence);\n                                    for (i = 0; i < sequence.length - 1; ++i) {\n                                        this.setMinDist(sequence[i], sequence[i + 1], x.get(sequence[i + 1]) - x.get(sequence[i]));\n                                    }\n                                    this.setMinDist(virtualStart, sequence[0], x.get(sequence[0]) - x.get(virtualStart));\n                                }\n                            }\n                            else if (order.get(virtualStart) === d) {\n                                virtualStartIndex = virtualStart.layerIndex;\n                                var virtualEndIndex = virtualEnd.layerIndex;\n                                sequence = [];\n                                for (i = virtualStartIndex + 1; i < virtualEndIndex; i++) {\n                                    sequence.push(layer[i]);\n                                }\n                                if (sequence.length > 0) {\n                                    this._sequencer(x, virtualStart, virtualEnd, d, sequence);\n                                }\n                                placed.set(virtualStart, true);\n                            }\n                            virtualStart = virtualEnd;\n                        }\n                        this.adjustDirections(l, d, order, placed);\n                    }\n                }, this);\n\n\n                var fromLayerIndex = this._isIncreasingLayout() ? 0 : this.layers.length - 1;\n                var reachedFinalLayerIndex = function(k, ctx) {\n                    if (ctx._isIncreasingLayout()) {\n                        return k < ctx.layers.length;\n                    }\n                    else {\n                        return k >= 0;\n                    }\n                };\n                var layerIncrement = this._isIncreasingLayout() ? +1 : -1, offset = 0;\n\n                /**\n                 * Calcs the max height of the given layer.\n                 */\n                function maximumHeight(layer, ctx) {\n                    var height = Number.MIN_VALUE;\n                    for (var n = 0; n < layer.length; ++n) {\n                        var node = layer[n];\n                        if (ctx._isVerticalLayout()) {\n                            height = Math.max(height, node.height);\n                        }\n                        else {\n                            height = Math.max(height, node.width);\n                        }\n                    }\n                    return height;\n                }\n\n                for (i = fromLayerIndex; reachedFinalLayerIndex(i, this); i += layerIncrement) {\n                    layer = this.layers[i];\n                    var height = maximumHeight(layer, this);\n\n                    for (n = 0; n < layer.length; ++n) {\n                        node = layer[n];\n                        if (this._isVerticalLayout()) {\n                            node.x = x.get(node);\n                            node.y = offset + height / 2;\n                        }\n                        else {\n                            node.x = offset + height / 2;\n                            node.y = x.get(node);\n                        }\n                    }\n\n                    offset += this.options.layerSeparation + height;\n                }\n            },\n\n            adjustDirections: function(l, d, order, placed) {\n                if (l + d < 0 || l + d >= this.layers.length) {\n                    return;\n                }\n\n                var prevBridge = null, prevBridgeTarget = null;\n                var layer = this.layers[l + d];\n                for (var n = 0; n < layer.length; ++n) {\n                    var nextBridge = layer[n];\n                    if (nextBridge.isVirtual) {\n                        var nextBridgeTarget = this.getNeighborOnLayer(nextBridge, l);\n                        if (nextBridgeTarget.isVirtual) {\n                            if (prevBridge) {\n                                var p = placed.get(prevBridgeTarget);\n                                var clayer = this.layers[l];\n                                var i1 = prevBridgeTarget.layerIndex;\n                                var i2 = nextBridgeTarget.layerIndex;\n                                for (var i = i1 + 1; i < i2; ++i) {\n                                    if (clayer[i].isVirtual) {\n                                        p = p && placed.get(clayer[i]);\n                                    }\n                                }\n                                if (p) {\n                                    order.set(prevBridge, d);\n                                    var j1 = prevBridge.layerIndex;\n                                    var j2 = nextBridge.layerIndex;\n                                    for (var j = j1 + 1; j < j2; ++j) {\n                                        if (layer[j].isVirtual) {\n                                            order.set(layer[j], d);\n                                        }\n                                    }\n                                }\n                            }\n                            prevBridge = nextBridge;\n                            prevBridgeTarget = nextBridgeTarget;\n                        }\n                    }\n                }\n            },\n\n            getNeighborOnLayer: function(node, l) {\n                var neighbor = this.upNodes.get(node)[0];\n                if (neighbor.layer === l) {\n                    return neighbor;\n                }\n                neighbor = this.downNodes.get(node)[0];\n                if (neighbor.layer === l) {\n                    return neighbor;\n                }\n                return null;\n            },\n\n            _sequencer: function(x, virtualStart, virtualEnd, dir, sequence) {\n                if (sequence.length === 1) {\n                    this._sequenceSingle(x, virtualStart, virtualEnd, dir, sequence[0]);\n                }\n\n                if (sequence.length > 1) {\n                    var r = sequence.length, t = this.intDiv(r, 2);\n                    this._sequencer(x, virtualStart, virtualEnd, dir, sequence.slice(0, t));\n                    this._sequencer(x, virtualStart, virtualEnd, dir, sequence.slice(t));\n                    this.combineSequences(x, virtualStart, virtualEnd, dir, sequence);\n                }\n            },\n\n            _sequenceSingle: function(x, virtualStart, virtualEnd, dir, node) {\n                var neighbors = dir === -1 ? this.downNodes.get(node) : this.upNodes.get(node);\n\n                var n = neighbors.length;\n                if (n !== 0) {\n                    if (n % 2 === 1) {\n                        x.set(node, x.get(neighbors[this.intDiv(n, 2)]));\n                    }\n                    else {\n                        x.set(node, (x.get(neighbors[this.intDiv(n, 2) - 1]) + x.get(neighbors[this.intDiv(n, 2)])) / 2);\n                    }\n\n                    if (virtualStart) {\n                        x.set(node, Math.max(x.get(node), x.get(virtualStart) + this.getMinDist(virtualStart, node)));\n                    }\n                    if (virtualEnd) {\n                        x.set(node, Math.min(x.get(node), x.get(virtualEnd) - this.getMinDist(node, virtualEnd)));\n                    }\n                }\n            },\n\n            combineSequences: function(x, virtualStart, virtualEnd, dir, sequence) {\n                var r = sequence.length, t = this.intDiv(r, 2);\n\n                // collect left changes\n                var leftHeap = [], i, c, n, neighbors, neighbor, pair;\n                for (i = 0; i < t; ++i) {\n                    c = 0;\n                    neighbors = dir === -1 ? this.downNodes.get(sequence[i]) : this.upNodes.get(sequence[i]);\n                    for (n = 0; n < neighbors.length; ++n) {\n                        neighbor = neighbors[n];\n                        if (x.get(neighbor) >= x.get(sequence[i])) {\n                            c++;\n                        }\n                        else {\n                            c--;\n                            leftHeap.push({ k: x.get(neighbor) + this.getMinDist(sequence[i], sequence[t - 1]), v: 2 });\n                        }\n                    }\n                    leftHeap.push({ k: x.get(sequence[i]) + this.getMinDist(sequence[i], sequence[t - 1]), v: c });\n                }\n                if (virtualStart) {\n                    leftHeap.push({ k: x.get(virtualStart) + this.getMinDist(virtualStart, sequence[t - 1]), v: Number.MAX_VALUE });\n                }\n                leftHeap.sort(this._positionDescendingComparer);\n\n                // collect right changes\n                var rightHeap = [];\n                for (i = t; i < r; ++i) {\n                    c = 0;\n                    neighbors = dir === -1 ? this.downNodes.get(sequence[i]) : this.upNodes.get(sequence[i]);\n                    for (n = 0; n < neighbors.length; ++n) {\n                        neighbor = neighbors[n];\n                        if (x.get(neighbor) <= x.get(sequence[i])) {\n                            c++;\n                        }\n                        else {\n                            c--;\n                            rightHeap.push({ k: x.get(neighbor) - this.getMinDist(sequence[i], sequence[t]), v: 2 });\n                        }\n                    }\n                    rightHeap.push({ k: x.get(sequence[i]) - this.getMinDist(sequence[i], sequence[t]), v: c });\n                }\n                if (virtualEnd) {\n                    rightHeap.push({ k: x.get(virtualEnd) - this.getMinDist(virtualEnd, sequence[t]), v: Number.MAX_VALUE });\n                }\n                rightHeap.sort(this._positionAscendingComparer);\n\n                var leftRes = 0, rightRes = 0;\n                var m = this.getMinDist(sequence[t - 1], sequence[t]);\n                while (x.get(sequence[t]) - x.get(sequence[t - 1]) < m) {\n                    if (leftRes < rightRes) {\n                        if (leftHeap.length === 0) {\n                            x.set(sequence[t - 1], x.get(sequence[t]) - m);\n                            break;\n                        }\n                        else {\n                            pair = leftHeap.shift();\n                            leftRes = leftRes + pair.v;\n                            x.set(sequence[t - 1], pair.k);\n                            x.set(sequence[t - 1], Math.max(x.get(sequence[t - 1]), x.get(sequence[t]) - m));\n                        }\n                    }\n                    else {\n                        if (rightHeap.length === 0) {\n                            x.set(sequence[t], x.get(sequence[t - 1]) + m);\n                            break;\n                        }\n                        else {\n                            pair = rightHeap.shift();\n                            rightRes = rightRes + pair.v;\n                            x.set(sequence[t], pair.k);\n                            x.set(sequence[t], Math.min(x.get(sequence[t]), x.get(sequence[t - 1]) + m));\n                        }\n                    }\n                }\n                for (i = t - 2; i >= 0; i--) {\n                    x.set(sequence[i], Math.min(x.get(sequence[i]), x.get(sequence[t - 1]) - this.getMinDist(sequence[i], sequence[t - 1])));\n                }\n                for (i = t + 1; i < r; i++) {\n                    x.set(sequence[i], Math.max(x.get(sequence[i]), x.get(sequence[t]) + this.getMinDist(sequence[i], sequence[t])));\n                }\n            },\n\n            placeLeft: function(node, leftPos, leftClass) {\n                var pos = Number.NEGATIVE_INFINITY;\n                Utils.forEach(this._getComposite(node), function(v) {\n                    var leftSibling = this.leftSibling(v);\n                    if (leftSibling && this.nodeLeftClass.get(leftSibling) === this.nodeLeftClass.get(v)) {\n                        if (!leftPos.containsKey(leftSibling)) {\n                            this.placeLeft(leftSibling, leftPos, leftClass);\n                        }\n                        pos = Math.max(pos, leftPos.get(leftSibling) + this.getMinDist(leftSibling, v));\n                    }\n                }, this);\n                if (pos === Number.NEGATIVE_INFINITY) {\n                    pos = 0;\n                }\n                Utils.forEach(this._getComposite(node), function(v) {\n                    leftPos.set(v, pos);\n                });\n            },\n\n            placeRight: function(node, rightPos, rightClass) {\n                var pos = Number.POSITIVE_INFINITY;\n                Utils.forEach(this._getComposite(node), function(v) {\n                    var rightSibling = this.rightSibling(v);\n                    if (rightSibling && this.nodeRightClass.get(rightSibling) === this.nodeRightClass.get(v)) {\n                        if (!rightPos.containsKey(rightSibling)) {\n                            this.placeRight(rightSibling, rightPos, rightClass);\n                        }\n                        pos = Math.min(pos, rightPos.get(rightSibling) - this.getMinDist(v, rightSibling));\n                    }\n                }, this);\n                if (pos === Number.POSITIVE_INFINITY) {\n                    pos = 0;\n                }\n                Utils.forEach(this._getComposite(node), function(v) {\n                    rightPos.set(v, pos);\n                });\n            },\n\n            leftSibling: function(node) {\n                var layer = this.layers[node.layer],\n                    layerIndex = node.layerIndex;\n                return layerIndex === 0 ? null : layer[layerIndex - 1];\n            },\n\n            rightSibling: function(node) {\n                var layer = this.layers[node.layer];\n                var layerIndex = node.layerIndex;\n                return layerIndex === layer.length - 1 ? null : layer[layerIndex + 1];\n\n            },\n\n            _getComposite: function(node) {\n                return node.isVirtual ? this._nodesInLink(node) : [node];\n            },\n\n            arrangeNodes: function() {\n                var i, l, ni, layer, node;\n                // Initialize node's base priority\n                for (l = 0; l < this.layers.length; l++) {\n                    layer = this.layers[l];\n\n                    for (ni = 0; ni < layer.length; ni++) {\n                        node = layer[ni];\n                        node.upstreamPriority = node.upstreamLinkCount;\n                        node.downstreamPriority = node.downstreamLinkCount;\n                    }\n                }\n\n                // Layout is invoked after MinimizeCrossings\n                // so we may assume node's barycenters are initially correct\n\n                var maxLayoutIterations = 2;\n                for (var it = 0; it < maxLayoutIterations; it++) {\n                    for (i = this.layers.length - 1; i >= 1; i--) {\n                        this.layoutLayer(false, i);\n                    }\n\n                    for (i = 0; i < this.layers.length - 1; i++) {\n                        this.layoutLayer(true, i);\n                    }\n                }\n\n                // Offset the whole structure so that there are no gridPositions < 0\n                var gridPos = Number.MAX_VALUE;\n                for (l = 0; l < this.layers.length; l++) {\n                    layer = this.layers[l];\n\n                    for (ni = 0; ni < layer.length; ni++) {\n                        node = layer[ni];\n                        gridPos = Math.min(gridPos, node.gridPosition);\n                    }\n                }\n\n                if (gridPos < 0) {\n                    for (l = 0; l < this.layers.length; l++) {\n                        layer = this.layers[l];\n\n                        for (ni = 0; ni < layer.length; ni++) {\n                            node = layer[ni];\n                            node.gridPosition = node.gridPosition - gridPos;\n                        }\n                    }\n                }\n            },\n\n            /// <summary>\n            /// Layout of a single layer.\n            /// </summary>\n            /// <param name=\"layerIndex\">The layer to organize.</param>\n            /// <param name=\"movingDownwards\">If set to <c>true</c> we move down in the layer stack.</param>\n            /// <seealso cref=\"OptimizeCrossings()\"/>\n            layoutLayer: function(down, layer) {\n                var iconsidered;\n                var considered;\n\n                if (down) {\n                    considered = this.layers[iconsidered = layer + 1];\n                }\n                else {\n                    considered = this.layers[iconsidered = layer - 1];\n                }\n\n                // list containing the nodes in the considered layer sorted by priority\n                var sorted = [];\n                for (var n = 0; n < considered.length; n++) {\n                    sorted.push(considered[n]);\n                }\n                sorted.sort(function(n1, n2) {\n                    var n1Priority = (n1.upstreamPriority + n1.downstreamPriority) / 2;\n                    var n2Priority = (n2.upstreamPriority + n2.downstreamPriority) / 2;\n\n                    if (Math.abs(n1Priority - n2Priority) < 0.0001) {\n                        return 0;\n                    }\n                    if (n1Priority < n2Priority) {\n                        return 1;\n                    }\n                    return -1;\n                });\n\n                // each node strives for its barycenter; high priority nodes start first\n                Utils.forEach(sorted, function(node) {\n                    var nodeGridPos = node.gridPosition;\n                    var nodeBaryCenter = this.calcBaryCenter(node);\n                    var nodePriority = (node.upstreamPriority + node.downstreamPriority) / 2;\n\n                    if (Math.abs(nodeGridPos - nodeBaryCenter) < 0.0001) {\n                        // This node is exactly at its barycenter -> perfect\n                        return;\n                    }\n\n                    if (Math.abs(nodeGridPos - nodeBaryCenter) < 0.25 + 0.0001) {\n                        // This node is close enough to the barycenter -> should work\n                        return;\n                    }\n\n                    if (nodeGridPos < nodeBaryCenter) {\n                        // Try to move the node to the right in an\n                        // attempt to reach its barycenter\n                        while (nodeGridPos < nodeBaryCenter) {\n                            if (!this.moveRight(node, considered, nodePriority)) {\n                                break;\n                            }\n\n                            nodeGridPos = node.gridPosition;\n                        }\n                    }\n                    else {\n                        // Try to move the node to the left in an\n                        // attempt to reach its barycenter\n                        while (nodeGridPos > nodeBaryCenter) {\n                            if (!this.moveLeft(node, considered, nodePriority)) {\n                                break;\n                            }\n\n                            nodeGridPos = node.gridPosition;\n                        }\n                    }\n                }, this);\n\n                // after the layer has been rearranged we need to recalculate the barycenters\n                // of the nodes in the surrounding layers\n                if (iconsidered > 0) {\n                    this.calcDownData(iconsidered - 1);\n                }\n                if (iconsidered < this.layers.length - 1) {\n                    this.calcUpData(iconsidered + 1);\n                }\n            },\n\n            /// <summary>\n            /// Moves the node to the right and returns <c>true</c> if this was possible.\n            /// </summary>\n            /// <param name=\"node\">The node.</param>\n            /// <param name=\"layer\">The layer.</param>\n            /// <returns>Returns <c>true</c> if the shift was possible, otherwise <c>false</c>.</returns>\n            moveRight: function(node, layer, priority) {\n                var index = Utils.indexOf(layer, node);\n                if (index === layer.length - 1) {\n                    // this is the last node in the layer, so we can move to the right without troubles\n                    node.gridPosition = node.gridPosition + 0.5;\n                    return true;\n                }\n\n                var rightNode = layer[index + 1];\n                var rightNodePriority = (rightNode.upstreamPriority + rightNode.downstreamPriority) / 2;\n\n                // check if there is space between the right and the current node\n                if (rightNode.gridPosition > node.gridPosition + 1) {\n                    node.gridPosition = node.gridPosition + 0.5;\n                    return true;\n                }\n\n                // we have reached a node with higher priority; no movement is allowed\n                if (rightNodePriority > priority ||\n                    Math.abs(rightNodePriority - priority) < 0.0001) {\n                    return false;\n                }\n\n                // the right node has lower priority - try to move it\n                if (this.moveRight(rightNode, layer, priority)) {\n                    node.gridPosition = node.gridPosition + 0.5;\n                    return true;\n                }\n\n                return false;\n            },\n\n            /// <summary>\n            /// Moves the node to the left and returns <c>true</c> if this was possible.\n            /// </summary>\n            /// <param name=\"node\">The node.</param>\n            /// <param name=\"layer\">The layer.</param>\n            /// <returns>Returns <c>true</c> if the shift was possible, otherwise <c>false</c>.</returns>\n            moveLeft: function(node, layer, priority) {\n                var index = Utils.indexOf(layer, node);\n                if (index === 0) {\n                    // this is the last node in the layer, so we can move to the left without troubles\n                    node.gridPosition = node.gridPosition - 0.5;\n                    return true;\n                }\n\n                var leftNode = layer[index - 1];\n                var leftNodePriority = (leftNode.upstreamPriority + leftNode.downstreamPriority) / 2;\n\n                // check if there is space between the left and the current node\n                if (leftNode.gridPosition < node.gridPosition - 1) {\n                    node.gridPosition = node.gridPosition - 0.5;\n                    return true;\n                }\n\n                // we have reached a node with higher priority; no movement is allowed\n                if (leftNodePriority > priority ||\n                    Math.abs(leftNodePriority - priority) < 0.0001) {\n                    return false;\n                }\n\n                // The left node has lower priority - try to move it\n                if (this.moveLeft(leftNode, layer, priority)) {\n                    node.gridPosition = node.gridPosition - 0.5;\n                    return true;\n                }\n\n                return false;\n            },\n\n            mapVirtualNode: function(node, link) {\n                this.nodeToLinkMap.set(node, link);\n                if (!this.linkToNodeMap.containsKey(link)) {\n                    this.linkToNodeMap.set(link, []);\n                }\n                this.linkToNodeMap.get(link).push(node);\n            },\n\n            _nodesInLink: function(node) {\n                return this.linkToNodeMap.get(this.nodeToLinkMap.get(node));\n            },\n\n            /// <summary>\n            /// Inserts dummy nodes to break long links.\n            /// </summary>\n            _dummify: function() {\n                this.linkToNodeMap = new Dictionary();\n                this.nodeToLinkMap = new Dictionary();\n\n                var layer, pos, newNode, node, r, newLink, i, l, links = this.graph.links.slice(0);\n                var layers = this.layers;\n\n                var addLinkBetweenLayers = function(upLayer, downLayer, link) {\n                    layers[upLayer].linksTo[downLayer] = layers[upLayer].linksTo[downLayer] || [];\n                    layers[upLayer].linksTo[downLayer].push(link);\n                };\n\n                for (l = 0; l < links.length; l++) {\n                    var link = links[l];\n                    var o = link.source;\n                    var d = link.target;\n\n                    var oLayer = o.layer;\n                    var dLayer = d.layer;\n                    var oPos = o.gridPosition;\n                    var dPos = d.gridPosition;\n\n                    var step = (dPos - oPos) / Math.abs(dLayer - oLayer);\n\n                    var p = o;\n                    if (oLayer - dLayer > 1) {\n                        for (i = oLayer - 1; i > dLayer; i--) {\n                            newNode = new Node();\n                            newNode.x = o.x;\n                            newNode.y = o.y;\n                            newNode.width = o.width / 100;\n                            newNode.height = o.height / 100;\n\n                            layer = layers[i];\n                            pos = (i - dLayer) * step + oPos;\n                            if (pos > layer.length) {\n                                pos = layer.length;\n                            }\n\n                            // check if origin and dest are both last\n                            if (oPos >= layers[oLayer].length - 1 &&\n                                dPos >= layers[dLayer].length - 1) {\n                                pos = layer.length;\n                            }\n\n                            // check if origin and destination are both first\n                            else if (oPos === 0 && dPos === 0) {\n                                pos = 0;\n                            }\n\n                            newNode.layer = i;\n                            newNode.uBaryCenter = 0.0;\n                            newNode.dBaryCenter = 0.0;\n                            newNode.upstreamLinkCount = 0;\n                            newNode.downstreamLinkCount = 0;\n                            newNode.gridPosition = pos;\n                            newNode.isVirtual = true;\n\n                            Utils.insert(layer, newNode, pos);\n\n                            // translate rightwards nodes' positions\n                            for (r = pos + 1; r < layer.length; r++) {\n                                node = layer[r];\n                                node.gridPosition = node.gridPosition + 1;\n                            }\n\n                            newLink = new Link(p, newNode);\n                            newLink.depthOfDumminess = 0;\n\n                            addLinkBetweenLayers(i - 1, i, newLink);\n\n                            p = newNode;\n\n                            // add the new node and the new link to the graph\n                            this.graph._addNode(newNode);\n                            this.graph.addLink(newLink);\n\n                            newNode.index = this.graph.nodes.length - 1;\n                            this.mapVirtualNode(newNode, link);\n                        }\n\n                        // set the origin of the real arrow to the last dummy\n                        addLinkBetweenLayers(dLayer - 1, dLayer, newLink);\n                        link.changeSource(p);\n                        link.depthOfDumminess = oLayer - dLayer - 1;\n                    } else if (oLayer - dLayer < -1) {\n                        for (i = oLayer + 1; i < dLayer; i++) {\n                            newNode = new Node();\n                            newNode.x = o.x;\n                            newNode.y = o.y;\n                            newNode.width = o.width / 100;\n                            newNode.height = o.height / 100;\n\n                            layer = layers[i];\n                            pos = (i - oLayer) * step + oPos;\n                            if (pos > layer.length) {\n                                pos = layer.length;\n                            }\n\n                            // check if origin and dest are both last\n                            if (oPos >= layers[oLayer].length - 1 &&\n                                dPos >= layers[dLayer].length - 1) {\n                                pos = layer.length;\n                            }\n\n                            // check if origin and destination are both first\n                            else if (oPos === 0 && dPos === 0) {\n                                pos = 0;\n                            }\n\n                            newNode.layer = i;\n                            newNode.uBaryCenter = 0.0;\n                            newNode.dBaryCenter = 0.0;\n                            newNode.upstreamLinkCount = 0;\n                            newNode.downstreamLinkCount = 0;\n                            newNode.gridPosition = pos;\n                            newNode.isVirtual = true;\n\n                            pos &= pos; // truncates to int\n                            Utils.insert(layer, newNode, pos);\n\n                            // translate rightwards nodes' positions\n                            for (r = pos + 1; r < layer.length; r++) {\n                                node = layer[r];\n                                node.gridPosition = node.gridPosition + 1;\n                            }\n\n                            newLink = new Link(p, newNode);\n                            newLink.depthOfDumminess = 0;\n                            addLinkBetweenLayers(i - 1, i, newLink);\n\n                            p = newNode;\n\n                            // add the new node and the new link to the graph\n                            this.graph._addNode(newNode);\n                            this.graph.addLink(newLink);\n\n                            newNode.index = this.graph.nodes.length - 1;\n                            this.mapVirtualNode(newNode, link);\n                        }\n                        addLinkBetweenLayers(dLayer - 1, dLayer, link);\n\n                        // Set the origin of the real arrow to the last dummy\n                        link.changeSource(p);\n                        link.depthOfDumminess = dLayer - oLayer - 1;\n                    } else {\n                        addLinkBetweenLayers(oLayer, dLayer, link);\n                    }\n                }\n            },\n\n            /// <summary>\n            /// Removes the dummy nodes inserted earlier to break long links.\n            /// </summary>\n            /// <remarks>The virtual nodes are effectively turned into intermediate connection points.</remarks>\n            _dedummify: function() {\n                var dedum = true;\n                while (dedum) {\n                    dedum = false;\n\n                    for (var l = 0; l < this.graph.links.length; l++) {\n                        var link = this.graph.links[l];\n                        if (!link.depthOfDumminess) {\n                            continue;\n                        }\n\n                        var points = [];\n\n                        // add points in reverse order\n                        points.unshift({ x: link.target.x, y: link.target.y });\n                        points.unshift({ x: link.source.x, y: link.source.y });\n\n                        // _dedummify the link\n                        var temp = link;\n                        var depthOfDumminess = link.depthOfDumminess;\n                        for (var d = 0; d < depthOfDumminess; d++) {\n                            var node = temp.source;\n                            var prevLink = node.incoming[0];\n\n                            points.unshift({ x: prevLink.source.x, y: prevLink.source.y });\n\n                            temp = prevLink;\n                        }\n\n                        // restore the original link origin\n                        link.changeSource(temp.source);\n\n                        // reset dummification flag\n                        link.depthOfDumminess = 0;\n\n                        // note that we only need the intermediate points, floating links have been dropped in the analysis\n                        if (points.length > 2) {\n                            // first and last are the endpoints\n                            points.splice(0, 1);\n                            points.splice(points.length - 1);\n                            link.points = points;\n                        }\n                        else {\n                            link.points = [];\n                        }\n\n                        // we are not going to delete the dummy elements;\n                        // they won't be needed anymore anyway.\n\n                        dedum = true;\n                        break;\n                    }\n                }\n            },\n\n            /// <summary>\n            /// Optimizes/reduces the crossings between the layers by turning the crossing problem into a (combinatorial) number ordering problem.\n            /// </summary>\n            _optimizeCrossings: function() {\n                var moves = -1, i;\n                var maxIterations = 3;\n                var iter = 0;\n\n                while (moves !== 0) {\n                    if (iter++ > maxIterations) {\n                        break;\n                    }\n\n                    moves = 0;\n\n                    for (i = this.layers.length - 1; i >= 1; i--) {\n                        moves += this.optimizeLayerCrossings(false, i);\n                    }\n\n                    for (i = 0; i < this.layers.length - 1; i++) {\n                        moves += this.optimizeLayerCrossings(true, i);\n                    }\n                }\n            },\n\n            calcUpData: function(layer) {\n                if (layer === 0) {\n                    return;\n                }\n\n                var considered = this.layers[layer], i, l, link;\n                var upLayer = new Set();\n                var temp = this.layers[layer - 1];\n                for (i = 0; i < temp.length; i++) {\n                    upLayer.add(temp[i]);\n                }\n\n                for (i = 0; i < considered.length; i++) {\n                    var node = considered[i];\n\n                    // calculate barycenter\n                    var sum = 0;\n                    var total = 0;\n\n                    for (l = 0; l < node.incoming.length; l++) {\n                        link = node.incoming[l];\n                        if (upLayer.contains(link.source)) {\n                            total++;\n                            sum += link.source.gridPosition;\n                        }\n                    }\n\n                    for (l = 0; l < node.outgoing.length; l++) {\n                        link = node.outgoing[l];\n                        if (upLayer.contains(link.target)) {\n                            total++;\n                            sum += link.target.gridPosition;\n                        }\n                    }\n\n                    if (total > 0) {\n                        node.uBaryCenter = sum / total;\n                        node.upstreamLinkCount = total;\n                    }\n                    else {\n                        node.uBaryCenter = i;\n                        node.upstreamLinkCount = 0;\n                    }\n                }\n            },\n\n            calcDownData: function(layer) {\n                if (layer === this.layers.length - 1) {\n                    return;\n                }\n\n                var considered = this.layers[layer], i , l, link;\n                var downLayer = new Set();\n                var temp = this.layers[layer + 1];\n                for (i = 0; i < temp.length; i++) {\n                    downLayer.add(temp[i]);\n                }\n\n                for (i = 0; i < considered.length; i++) {\n                    var node = considered[i];\n\n                    // calculate barycenter\n                    var sum = 0;\n                    var total = 0;\n\n                    for (l = 0; l < node.incoming.length; l++) {\n                        link = node.incoming[l];\n                        if (downLayer.contains(link.source)) {\n                            total++;\n                            sum += link.source.gridPosition;\n                        }\n                    }\n\n                    for (l = 0; l < node.outgoing.length; l++) {\n                        link = node.outgoing[l];\n                        if (downLayer.contains(link.target)) {\n                            total++;\n                            sum += link.target.gridPosition;\n                        }\n                    }\n\n                    if (total > 0) {\n                        node.dBaryCenter = sum / total;\n                        node.downstreamLinkCount = total;\n                    }\n                    else {\n                        node.dBaryCenter = i;\n                        node.downstreamLinkCount = 0;\n                    }\n                }\n            },\n\n            /// <summary>\n            /// Optimizes the crossings.\n            /// </summary>\n            /// <remarks>The big trick here is the usage of weights or values attached to connected nodes which turn a problem of crossing links\n            /// to an a problem of ordering numbers.</remarks>\n            /// <param name=\"layerIndex\">The layer index.</param>\n            /// <param name=\"movingDownwards\">If set to <c>true</c> we move down in the layer stack.</param>\n            /// <returns>The number of nodes having moved, i.e. the number of crossings reduced.</returns>\n            optimizeLayerCrossings: function(down, layer) {\n                var iconsidered;\n                var considered;\n\n                if (down) {\n                    considered = this.layers[iconsidered = layer + 1];\n                }\n                else {\n                    considered = this.layers[iconsidered = layer - 1];\n                }\n\n                // remember what it was\n                var presorted = considered.slice(0);\n\n                // calculate barycenters for all nodes in the considered layer\n                if (down) {\n                    this.calcUpData(iconsidered);\n                }\n                else {\n                    this.calcDownData(iconsidered);\n                }\n\n                var that = this;\n                // sort nodes within this layer according to the barycenters\n                considered.sort(function(n1, n2) {\n                    var n1BaryCenter = that.calcBaryCenter(n1),\n                        n2BaryCenter = that.calcBaryCenter(n2);\n                    if (Math.abs(n1BaryCenter - n2BaryCenter) < 0.0001) {\n                        // in case of coinciding barycenters compare by the count of in/out links\n                        if (n1.degree() === n2.degree()) {\n                            return that.compareByIndex(n1, n2);\n                        }\n                        else if (n1.degree() < n2.degree()) {\n                            return 1;\n                        }\n                        return -1;\n                    }\n                    var compareValue = (n2BaryCenter - n1BaryCenter) * 1000;\n                    if (compareValue > 0) {\n                        return -1;\n                    }\n                    else if (compareValue < 0) {\n                        return 1;\n                    }\n                    return that.compareByIndex(n1, n2);\n                });\n\n                // count relocations\n                var i, moves = 0;\n                for (i = 0; i < considered.length; i++) {\n                    if (considered[i] !== presorted[i]) {\n                        moves++;\n                    }\n                }\n\n                if (moves > 0) {\n                    // now that the boxes have been arranged, update their grid positions\n                    var inode = 0;\n                    for (i = 0; i < considered.length; i++) {\n                        var node = considered[i];\n                        node.gridPosition = inode++;\n                    }\n                }\n\n                return moves;\n            },\n\n            /// <summary>\n            /// Swaps a pair of nodes in a layer.\n            /// </summary>\n            /// <param name=\"layerIndex\">Index of the layer.</param>\n            /// <param name=\"n\">The Nth node in the layer.</param>\n            _swapPairs: function() {\n                var maxIterations = this.options.layeredIterations;\n                var iter = 0;\n\n                while (true) {\n                    if (iter++ > maxIterations) {\n                        break;\n                    }\n\n                    var downwards = (iter % 4 <= 1);\n                    var secondPass = (iter % 4 === 1);\n\n                    for (var l = (downwards ? 0 : this.layers.length - 1);\n                         downwards ? l <= this.layers.length - 1 : l >= 0; l += (downwards ? 1 : -1)) {\n                        var layer = this.layers[l];\n                        var hasSwapped = false;\n\n                        // there is no need to recalculate crossings if they were calculated\n                        // on the previous step and nothing has changed\n                        var calcCrossings = true;\n                        var memCrossings = 0;\n\n                        for (var n = 0; n < layer.length - 1; n++) {\n                            // count crossings\n                            var up = 0;\n                            var down = 0;\n                            var crossBefore = 0;\n\n                            if (calcCrossings) {\n                                if (l !== 0) {\n                                    up = this.countLinksCrossingBetweenTwoLayers(l - 1, l);\n                                }\n                                if (l !== this.layers.length - 1) {\n                                    down = this.countLinksCrossingBetweenTwoLayers(l, l + 1);\n                                }\n                                if (downwards) {\n                                    up *= 2;\n                                }\n                                else {\n                                    down *= 2;\n                                }\n\n                                crossBefore = up + down;\n                            }\n                            else {\n                                crossBefore = memCrossings;\n                            }\n\n                            if (crossBefore === 0) {\n                                continue;\n                            }\n\n                            // Swap nodes\n                            var node1 = layer[n];\n                            var node2 = layer[n + 1];\n\n                            var node1GridPos = node1.gridPosition;\n                            var node2GridPos = node2.gridPosition;\n                            layer[n] = node2;\n                            layer[n + 1] = node1;\n                            node1.gridPosition = node2GridPos;\n                            node2.gridPosition = node1GridPos;\n\n                            // count crossings again and if worse than before, restore swapping\n                            up = 0;\n                            if (l !== 0) {\n                                up = this.countLinksCrossingBetweenTwoLayers(l - 1, l);\n                            }\n                            down = 0;\n                            if (l !== this.layers.length - 1) {\n                                down = this.countLinksCrossingBetweenTwoLayers(l, l + 1);\n                            }\n                            if (downwards) {\n                                up *= 2;\n                            }\n                            else {\n                                down *= 2;\n                            }\n                            var crossAfter = up + down;\n\n                            var revert = false;\n                            if (secondPass) {\n                                revert = crossAfter >= crossBefore;\n                            }\n                            else {\n                                revert = crossAfter > crossBefore;\n                            }\n\n                            if (revert) {\n                                node1 = layer[n];\n                                node2 = layer[n + 1];\n\n                                node1GridPos = node1.gridPosition;\n                                node2GridPos = node2.gridPosition;\n                                layer[n] = node2;\n                                layer[n + 1] = node1;\n                                node1.gridPosition = node2GridPos;\n                                node2.gridPosition = node1GridPos;\n\n                                // nothing has changed, remember the crossings so that\n                                // they are not calculated again on the next step\n                                memCrossings = crossBefore;\n                                calcCrossings = false;\n                            }\n                            else {\n                                hasSwapped = true;\n                                calcCrossings = true;\n                            }\n                        }\n\n                        if (hasSwapped) {\n                            if (l !== this.layers.length - 1) {\n                                this.calcUpData(l + 1);\n                            }\n                            if (l !== 0) {\n                                this.calcDownData(l - 1);\n                            }\n                        }\n                    }\n                }\n            },\n\n            /// <summary>\n            /// Counts the number of links crossing between two layers.\n            /// </summary>\n            /// <param name=\"layerIndex1\">The layer index.</param>\n            /// <param name=\"layerIndex2\">Another layer index.</param>\n            /// <returns></returns>\n            countLinksCrossingBetweenTwoLayers: function(ulayer, dlayer) {\n                var links = this.layers[ulayer].linksTo[dlayer];\n                var link1, link2, n11, n12, n21, n22, l1, l2;\n                var crossings = 0;\n                var length = links.length;\n\n                for (l1 = 0; l1 < length; l1++) {\n                    link1 = links[l1];\n                    for (l2 = l1 + 1; l2 < length; l2++) {\n\n                        link2 = links[l2];\n\n                        if (link1.target.layer === dlayer) {\n                            n11 = link1.source;\n                            n12 = link1.target;\n                        }\n                        else {\n                            n11 = link1.target;\n                            n12 = link1.source;\n                        }\n\n                        if (link2.target.layer === dlayer) {\n                            n21 = link2.source;\n                            n22 = link2.target;\n                        }\n                        else {\n                            n21 = link2.target;\n                            n22 = link2.source;\n                        }\n\n                        var n11gp = n11.gridPosition;\n                        var n12gp = n12.gridPosition;\n                        var n21gp = n21.gridPosition;\n                        var n22gp = n22.gridPosition;\n\n                        if ((n11gp - n21gp) * (n12gp - n22gp) < 0) {\n                            crossings++;\n                        }\n                    }\n                }\n\n                return crossings;\n            },\n\n            calcBaryCenter: function(node) {\n                var upstreamLinkCount = node.upstreamLinkCount;\n                var downstreamLinkCount = node.downstreamLinkCount;\n                var uBaryCenter = node.uBaryCenter;\n                var dBaryCenter = node.dBaryCenter;\n\n                if (upstreamLinkCount > 0 && downstreamLinkCount > 0) {\n                    return (uBaryCenter + dBaryCenter) / 2;\n                }\n                if (upstreamLinkCount > 0) {\n                    return uBaryCenter;\n                }\n                if (downstreamLinkCount > 0) {\n                    return dBaryCenter;\n                }\n\n                return 0;\n            },\n\n            _gridPositionComparer: function(x, y) {\n                if (x.gridPosition < y.gridPosition) {\n                    return -1;\n                }\n                if (x.gridPosition > y.gridPosition) {\n                    return 1;\n                }\n                return 0;\n            },\n\n            _positionAscendingComparer: function(x, y) {\n                return x.k < y.k ? -1 : x.k > y.k ? 1 : 0;\n            },\n\n            _positionDescendingComparer: function(x, y) {\n                return x.k < y.k ? 1 : x.k > y.k ? -1 : 0;\n            },\n\n            _firstVirtualNode: function(layer) {\n                for (var c = 0; c < layer.length; c++) {\n                    if (layer[c].isVirtual) {\n                        return c;\n                    }\n                }\n                return -1;\n            },\n\n            compareByIndex: function(o1, o2) {\n                var i1 = o1.index;\n                var i2 = o2.index;\n\n                if (i1 < i2) {\n                    return 1;\n                }\n\n                if (i1 > i2) {\n                    return -1;\n                }\n\n                return 0;\n            },\n\n            intDiv: function(numerator, denominator) {\n                return (numerator - numerator % denominator) / denominator;\n            },\n\n            nextVirtualNode: function(layer, node) {\n                var nodeIndex = node.layerIndex;\n                for (var i = nodeIndex + 1; i < layer.length; ++i) {\n                    if (layer[i].isVirtual) {\n                        return layer[i];\n                    }\n                }\n                return null;\n            }\n\n        });\n\n        /**\n         * Captures the state of a diagram; node positions, link points and so on.\n         * @type {*}\n         */\n        var LayoutState = kendo.Class.extend({\n            init: function(diagram, graphOrNodes) {\n                if (Utils.isUndefined(diagram)) {\n                    throw \"No diagram given\";\n                }\n                this.diagram = diagram;\n                this.nodeMap = new Dictionary();\n                this.linkMap = new Dictionary();\n                this.capture(graphOrNodes ? graphOrNodes : diagram);\n            },\n\n            /**\n             * Will capture either\n             * - the state of the shapes and the intermediate points of the connections in the diagram\n             * - the bounds of the nodes contained in the Graph together with the intermediate points of the links in the Graph\n             * - the bounds of the nodes in the Array<Node>\n             * - the links points and node bounds in the literal object\n             * @param diagramOrGraphOrNodes\n             */\n            capture: function(diagramOrGraphOrNodes) {\n                var node,\n                    nodes,\n                    shape,\n                    i,\n                    conn,\n                    link,\n                    links;\n\n                if (diagramOrGraphOrNodes instanceof diagram.Graph) {\n\n                    for (i = 0; i < diagramOrGraphOrNodes.nodes.length; i++) {\n                        node = diagramOrGraphOrNodes.nodes[i];\n                        shape = node.associatedShape;\n                        //shape.bounds(new Rect(node.x, node.y, node.width, node.height));\n                        this.nodeMap.set(shape.visual.id, new Rect(node.x, node.y, node.width, node.height));\n                    }\n                    for (i = 0; i < diagramOrGraphOrNodes.links.length; i++) {\n                        link = diagramOrGraphOrNodes.links[i];\n                        conn = link.associatedConnection;\n                        this.linkMap.set(conn.visual.id, link.points());\n                    }\n                }\n                else if (diagramOrGraphOrNodes instanceof Array) {\n                    nodes = diagramOrGraphOrNodes;\n                    for (i = 0; i < nodes.length; i++) {\n                        node = nodes[i];\n                        shape = node.associatedShape;\n                        if (shape) {\n                            this.nodeMap.set(shape.visual.id, new Rect(node.x, node.y, node.width, node.height));\n                        }\n                    }\n                }\n                else if (diagramOrGraphOrNodes.hasOwnProperty(\"links\") && diagramOrGraphOrNodes.hasOwnProperty(\"nodes\")) {\n                    nodes = diagramOrGraphOrNodes.nodes;\n                    links = diagramOrGraphOrNodes.links;\n                    for (i = 0; i < nodes.length; i++) {\n                        node = nodes[i];\n                        shape = node.associatedShape;\n                        if (shape) {\n                            this.nodeMap.set(shape.visual.id, new Rect(node.x, node.y, node.width, node.height));\n                        }\n                    }\n                    for (i = 0; i < links.length; i++) {\n                        link = links[i];\n                        conn = link.associatedConnection;\n                        if (conn) {\n                            this.linkMap.set(conn.visual.id, link.points);\n                        }\n                    }\n                }\n                else { // capture the diagram\n                    var shapes = this.diagram.shapes;\n                    var connections = this.diagram.connections;\n                    for (i = 0; i < shapes.length; i++) {\n                        shape = shapes[i];\n                        this.nodeMap.set(shape.visual.id, shape.bounds());\n                    }\n                    for (i = 0; i < connections.length; i++) {\n                        conn = connections[i];\n                        this.linkMap.set(conn.visual.id, conn.points());\n                    }\n                }\n            }\n        });\n\n        deepExtend(diagram, {\n            init: function(element) {\n                kendo.init(element, diagram.ui);\n            },\n            SpringLayout: SpringLayout,\n            TreeLayout: TreeLayout,\n            GraphAdapter: DiagramToHyperTreeAdapter,\n            LayeredLayout: LayeredLayout,\n            LayoutBase: LayoutBase,\n            LayoutState: LayoutState\n        });\n    })(window.kendo.jQuery);\n\n    (function(undefined$1) {\n        const kendo = window.kendo;\n        const dataviz = kendo.dataviz;\n\n        const elementStyles = element => element.ownerDocument.defaultView.getComputedStyle(element);\n        const cache = {};\n\n        const toColor = (colorMix, element) => {\n            if (cache[colorMix]) {\n                return cache[colorMix];\n            }\n\n            const curColor = element.style.color;\n            element.style.color = colorMix;\n            const color = elementStyles(element).color;\n            element.style.color = curColor;\n\n            cache[colorMix] = color;\n\n            return color;\n        };\n\n        const getProp = (element, prop) => {\n            let value = elementStyles(element).getPropertyValue(prop);\n            if (/^color-mix/i.test(value)) {\n                value = toColor(value, element);\n            }\n            return value;\n        };\n\n        const diagramTheme = (element) => {\n            const primaryBg = getProp(element, \"--kendo-chart-primary-bg\");\n            const primaryContrast = getProp(element, \"--kendo-chart-primary-contrast\");\n            const normalTextColor = getProp(element, \"--kendo-chart-text\");\n            const normalBackground = getProp(element, \"--kendo-color-surface\");\n\n            return {\n                shapeDefaults: {\n                    fill: {\n                        color: primaryBg\n                    },\n                    content: {\n                        color: primaryContrast\n                    },\n                    connectorDefaults: {\n                        fill: {\n                            color: normalTextColor\n                        },\n                        stroke: {\n                            color: primaryContrast\n                        },\n                        hover: {\n                            fill: {\n                                color: primaryContrast\n                            },\n                            stroke: {\n                                color: normalTextColor\n                            }\n                        }\n                    }\n                },\n                editable: {\n                    resize: {\n                        handles: {\n                            stroke: {\n                                color: normalTextColor\n                            },\n                            fill: {\n                                color: normalBackground\n                            },\n                            hover: {\n                                stroke: {\n                                    color: normalTextColor\n                                },\n                                fill: {\n                                    color: normalTextColor\n                                }\n                            }\n                        }\n                    }\n                },\n                selectable: {\n                    stroke: {\n                        color: normalTextColor\n                    }\n                },\n                connectionDefaults: {\n                    stroke: {\n                        color: normalTextColor\n                    },\n                    content: {\n                        color: normalTextColor\n                    },\n                    selection: {\n                        handles: {\n                            fill: {\n                                color: primaryContrast\n                            },\n                            stroke: {\n                                color: normalTextColor\n                            },\n                            width: 8,\n                            height: 8\n                        },\n                        stroke: {\n                            color: normalTextColor\n                        }\n                    }\n                }\n            };\n        };\n\n        dataviz.diagramTheme = diagramTheme;\n    })();\n\n    (function($, undefined$1) {\n            // Imports ================================================================\n            var dataviz = kendo.dataviz,\n                draw = kendo.drawing,\n                geom = kendo.geometry,\n                diagram = dataviz.diagram,\n                Widget = kendo.ui.Widget,\n                Class = kendo.Class,\n                deepExtend = kendo.deepExtend,\n                outerWidth = kendo._outerWidth,\n                outerHeight = kendo._outerHeight,\n                extend = $.extend,\n                HierarchicalDataSource = kendo.data.HierarchicalDataSource,\n                Canvas = diagram.Canvas,\n                Group = diagram.Group,\n                Rectangle = diagram.Rectangle,\n                Circle = diagram.Circle,\n                CompositeTransform = diagram.CompositeTransform,\n                Rect = diagram.Rect,\n                Path = diagram.Path,\n                DeleteShapeUnit = diagram.DeleteShapeUnit,\n                DeleteConnectionUnit = diagram.DeleteConnectionUnit,\n                TextBlock = diagram.TextBlock,\n                Image = diagram.Image,\n                Point = diagram.Point,\n                Intersect = diagram.Intersect,\n                ConnectionEditAdorner = diagram.ConnectionEditAdorner,\n                UndoRedoService = diagram.UndoRedoService,\n                ToolService = diagram.ToolService,\n                Selector = diagram.Selector,\n                ResizingAdorner = diagram.ResizingAdorner,\n                ConnectorsAdorner = diagram.ConnectorsAdorner,\n                Cursors = diagram.Cursors,\n                Utils = diagram.Utils,\n                Observable = kendo.Observable,\n                ToBackUnit = diagram.ToBackUnit,\n                ToFrontUnit = diagram.ToFrontUnit,\n                PolylineRouter = diagram.PolylineRouter,\n                CascadingRouter = diagram.CascadingRouter,\n                isUndefined = Utils.isUndefined,\n                isDefined = Utils.isDefined,\n                defined = draw.util.defined,\n                isArray = Array.isArray,\n                isFunction = kendo.isFunction,\n                isString = Utils.isString,\n                isPlainObject = $.isPlainObject,\n\n                math = Math;\n\n            // Constants ==============================================================\n            var NS = \".kendoDiagram\",\n                CASCADING = \"cascading\",\n                ITEMBOUNDSCHANGE = \"itemBoundsChange\",\n                CHANGE = \"change\",\n                CLICK = \"click\",\n                DRAG = \"drag\",\n                DRAG_END = \"dragEnd\",\n                DRAG_START = \"dragStart\",\n                MOUSE_ENTER = \"mouseEnter\",\n                MOUSE_LEAVE = \"mouseLeave\",\n                ERROR = \"error\",\n                AUTO = \"Auto\",\n                TOP = \"Top\",\n                RIGHT = \"Right\",\n                LEFT = \"Left\",\n                BOTTOM = \"Bottom\",\n                MAXINT = 9007199254740992,\n                SELECT = \"select\",\n                ITEMROTATE = \"itemRotate\",\n                PAN = \"pan\",\n                ZOOM_START = \"zoomStart\",\n                ZOOM_END = \"zoomEnd\",\n                NONE = \"none\",\n                DEFAULT_CANVAS_WIDTH = 600,\n                DEFAULT_CANVAS_HEIGHT = 600,\n                DEFAULT_SHAPE_TYPE = \"rectangle\",\n                DEFAULT_SHAPE_WIDTH = 100,\n                DEFAULT_SHAPE_HEIGHT = 100,\n                DEFAULT_SHAPE_MINWIDTH = 20,\n                DEFAULT_SHAPE_MINHEIGHT = 20,\n                DEFAULT_SHAPE_POSITION = 0,\n                DEFAULT_CONNECTION_BACKGROUND = \"Yellow\",\n                MAX_VALUE = Number.MAX_VALUE,\n                MIN_VALUE = -Number.MAX_VALUE,\n                ABSOLUTE = \"absolute\",\n                TRANSFORMED = \"transformed\",\n                ROTATED = \"rotated\",\n                TRANSPARENT = \"transparent\",\n                WIDTH = \"width\",\n                HEIGHT = \"height\",\n                X = \"x\",\n                Y = \"y\",\n                MOUSEWHEEL_NS = \"DOMMouseScroll\" + NS + \" mousewheel\" + NS,\n                MOBILE_ZOOM_RATE = 0.05,\n                MOBILE_PAN_DISTANCE = 5,\n                BUTTON_TEMPLATE = ({ className, icon, themeColor, text }) =>\n                    kendo.html.renderButton(`<button class=\"${className}\" href=\"#\">${text}</button>`, {\n                        icon: icon,\n                        themeColor\n                    }),\n                CONNECTION_CONTENT_OFFSET = 5;\n\n            diagram.DefaultConnectors = [{\n                name: TOP\n            }, {\n                name: BOTTOM\n            }, {\n                name: LEFT\n            }, {\n                name: RIGHT\n            }, {\n                name: AUTO,\n                position: function(shape) {\n                    return shape.getPosition(\"center\");\n                }\n            }];\n\n            var defaultButtons = {\n                cancel: {\n                    text: \"Cancel\",\n                    icon: \"cancel-outline\",\n                    className: \"k-diagram-cancel\",\n                },\n                update: {\n                    text: \"Save\",\n                    imageClass: \"save\",\n                    className: \"k-diagram-update\",\n                    icon: \"save\",\n                    themeColor: \"primary\"\n                }\n            };\n\n            diagram.shapeDefaults = function(extra) {\n                var defaults = {\n                    type: DEFAULT_SHAPE_TYPE,\n                    path: \"\",\n                    autoSize: true,\n                    visual: null,\n                    x: DEFAULT_SHAPE_POSITION,\n                    y: DEFAULT_SHAPE_POSITION,\n                    minWidth: DEFAULT_SHAPE_MINWIDTH,\n                    minHeight: DEFAULT_SHAPE_MINHEIGHT,\n                    width: DEFAULT_SHAPE_WIDTH,\n                    height: DEFAULT_SHAPE_HEIGHT,\n                    hover: {},\n                    editable: {\n                        connect: true,\n                        tools: []\n                    },\n                    connectors: diagram.DefaultConnectors,\n                    rotation: {\n                        angle: 0\n                    }\n                };\n\n                Utils.simpleExtend(defaults, extra);\n\n                return defaults;\n            };\n\n            function mwDelta(e) {\n                var origEvent = e.originalEvent,\n                    delta = 0;\n\n                if (origEvent.wheelDelta) {\n                    delta = -origEvent.wheelDelta / 40;\n                    delta = delta > 0 ? math.ceil(delta) : math.floor(delta);\n                } else if (origEvent.detail) {\n                    delta = origEvent.detail;\n                }\n\n                return delta;\n            }\n\n            function isAutoConnector(connector) {\n                return connector.options.name.toLowerCase() === AUTO.toLowerCase();\n            }\n\n            function closestConnector(point, connectors) {\n                var minimumDistance = MAXINT, resCtr, connector;\n                for (var i = 0; i < connectors.length; i++) {\n                    connector = connectors[i];\n                    if (!isAutoConnector(connector)) {\n                        var dist = point.distanceTo(connector.position());\n                        if (dist < minimumDistance) {\n                            minimumDistance = dist;\n                            resCtr = connector;\n                        }\n                    }\n                }\n                return resCtr;\n            }\n\n            function indicesOfItems(group, visuals) {\n                var i, indices = [], visual;\n                var children = group.drawingContainer().children;\n                var length = children.length;\n                for (i = 0; i < visuals.length; i++) {\n                    visual = visuals[i];\n                    for (var j = 0; j < length; j++) {\n                        if (children[j] == visual.drawingContainer()) {\n                            indices.push(j);\n                            break;\n                        }\n                    }\n                }\n                return indices;\n            }\n\n            var DiagramElement = Observable.extend({\n                init: function(options) {\n                    var that = this;\n                    that.dataItem = (options || {}).dataItem;\n                    Observable.fn.init.call(that);\n                    that.options = deepExtend({ id: diagram.randomId() }, that.options, options);\n                    that.isSelected = false;\n                    that.visual = new Group({\n                        id: that.options.id,\n                        autoSize: that.options.autoSize\n                    });\n                    that.id = that.options.id;\n                    that._template();\n                },\n\n                options: {\n                    hover: {},\n                    cursor: Cursors.grip,\n                    content: {\n                        align: \"center middle\"\n                    },\n                    selectable: true,\n                    serializable: true,\n                    enable: true\n                },\n\n                _getCursor: function(point) {\n                    if (this.adorner) {\n                        return this.adorner._getCursor(point);\n                    }\n                    return this.options.cursor;\n                },\n\n                visible: function(value) {\n                    if (isUndefined(value)) {\n                        return this.visual.visible();\n                    } else {\n                        this.visual.visible(value);\n                    }\n                },\n\n                bounds: function() {\n                },\n\n                refresh: function() {\n                    this.visual.redraw();\n                },\n\n                position: function(point) {\n                    this.options.x = point.x;\n                    this.options.y = point.y;\n                    this.visual.position(point);\n                },\n\n                toString: function() {\n                    return this.options.id;\n                },\n\n                serialize: function() {\n                    // the options json object describes the shape perfectly. So this object can serve as shape serialization.\n                    var json = deepExtend({}, { options: this.options });\n                    if (this.dataItem) {\n                        json.dataItem = this.dataItem.toString();\n                    }\n                    return json;\n                },\n\n                _content: function(content) {\n                    if (content !== undefined$1) {\n                        var options = this.options;\n\n                        if (diagram.Utils.isString(content)) {\n                            options.content.text = content;\n                        } else {\n                            deepExtend(options.content, content);\n                        }\n\n                        var contentOptions = options.content;\n                        var contentVisual = this._contentVisual;\n\n                        if (!contentVisual) {\n                            this._createContentVisual(contentOptions);\n                        } else {\n                            this._updateContentVisual(contentOptions);\n                        }\n                    }\n\n                    return this.options.content.text;\n                },\n\n                _createContentVisual: function(options) {\n                    if (options.text) {\n                        this._contentVisual = new TextBlock(options);\n                        this._contentVisual._includeInBBox = false;\n                        this.visual.append(this._contentVisual);\n                    }\n                },\n\n                _updateContentVisual: function(options) {\n                    this._contentVisual.redraw(options);\n                },\n\n                _hitTest: function(point) {\n                    var bounds = this.bounds();\n                    return this.visible() && bounds.contains(point) && this.options.enable;\n                },\n\n                _template: function() {\n                    var that = this;\n                    if (that.options.content.template) {\n                        var data = that.dataItem || {},\n                            elementTemplate = kendo.template(that.options.content.template, {\n                                paramName: \"dataItem\"\n                            });\n\n                        that.options.content.text = elementTemplate(data);\n                    }\n                },\n\n                _canSelect: function() {\n                    return this.options.selectable !== false;\n                },\n\n                toJSON: function() {\n                    return {\n                        id: this.options.id\n                    };\n                }\n            });\n\n            var Connector = Class.extend({\n                init: function(shape, options) {\n                    this.options = deepExtend({}, this.options, options);\n                    this.connections = [];\n                    this.shape = shape;\n                },\n                options: {\n                    width: 7,\n                    height: 7,\n                    fill: {\n                        color: DEFAULT_CONNECTION_BACKGROUND\n                    },\n                    hover: {}\n                },\n                position: function() {\n                    if (this.options.position) {\n                        return this.options.position(this.shape);\n                    } else {\n                        return this.shape.getPosition(this.options.name);\n                    }\n                },\n                toJSON: function() {\n                    return {\n                        shapeId: this.shape.toString(),\n                        connector: this.options.name\n                    };\n                }\n            });\n\n            Connector.parse = function(diagram, str) {\n                var tempStr = str.split(\":\"),\n                    id = tempStr[0],\n                    name = tempStr[1] || AUTO;\n\n                for (var i = 0; i < diagram.shapes.length; i++) {\n                    var shape = diagram.shapes[i];\n                    if (shape.options.id == id) {\n                        return shape.getConnector(name.trim());\n                    }\n                }\n            };\n\n            var Shape = DiagramElement.extend({\n                init: function(options, diagram) {\n                    var that = this;\n                    DiagramElement.fn.init.call(that, options);\n                    this.diagram = diagram;\n                    this.updateOptionsFromModel();\n                    options = that.options;\n                    that.connectors = [];\n                    that.type = options.type;\n                    that.createShapeVisual();\n                    that.updateBounds();\n                    that.content(that.content());\n\n                    that._createConnectors();\n                },\n\n                options: diagram.shapeDefaults(),\n\n                _setOptionsFromModel: function(model) {\n                    var modelOptions = filterShapeDataItem(model || this.dataItem);\n                    this.options = deepExtend({}, this.options, modelOptions);\n\n                    this.redrawVisual();\n                },\n\n                updateOptionsFromModel: function(model, field) {\n                    if (this.diagram && this.diagram._isEditable) {\n                        var modelOptions = filterShapeDataItem(model || this.dataItem);\n\n                        if (model && field) {\n                            if (!dataviz.inArray(field, [\"x\", \"y\", \"width\", \"height\"])) {\n                                if (this.options.visual) {\n                                    this._redrawVisual();\n                                } else if (modelOptions.type) {\n                                    this.options = deepExtend({}, this.options, modelOptions);\n                                    this._redrawVisual();\n                                }\n\n                                if (this.options.content) {\n                                    this._template();\n                                    this.content(this.options.content);\n                                }\n                            } else {\n                                var bounds = this.bounds();\n                                bounds[field] = model[field];\n                                this.bounds(bounds);\n                            }\n                        } else {\n                            this.options = deepExtend({}, this.options, modelOptions);\n                        }\n                    }\n                },\n\n                _redrawVisual: function() {\n                    this.visual.clear();\n                    this._contentVisual = null;\n                    this.options.dataItem = this.dataItem;\n                    this.createShapeVisual();\n                    this.updateBounds();\n                },\n\n                redrawVisual: function() {\n                    this._redrawVisual();\n                    if (this.options.content) {\n                        this._template();\n                        this.content(this.options.content);\n                    }\n                },\n\n                updateModel: function(syncChanges) {\n                    var diagram = this.diagram;\n                    if (diagram && diagram._isEditable) {\n                        var bounds = this._bounds;\n                        var model = this.dataItem;\n\n                        if (model) {\n                            diagram._suspendModelRefresh();\n                            if (defined(model.x) && bounds.x !== model.x) {\n                                model.set(\"x\", bounds.x);\n                            }\n\n                            if (defined(model.y) && bounds.y !== model.y) {\n                                model.set(\"y\", bounds.y);\n                            }\n\n                            if (defined(model.width) && bounds.width !== model.width) {\n                                model.set(\"width\", bounds.width);\n                            }\n\n                            if (defined(model.height) && bounds.height !== model.height) {\n                                model.set(\"height\", bounds.height);\n                            }\n\n                            this.dataItem = model;\n                            diagram._resumeModelRefresh();\n\n                            if (syncChanges) {\n                                diagram._syncShapeChanges();\n                            }\n                        }\n                    }\n                },\n\n                updateBounds: function() {\n                    var bounds = this.visual._measure(true);\n                    var options = this.options;\n                    this.bounds(new Rect(options.x, options.y, bounds.width, bounds.height));\n                    this._rotate();\n                    this._alignContent();\n                },\n\n                content: function(content) {\n                    var result = this._content(content);\n\n                    this._alignContent();\n\n                    return result;\n                },\n\n                _alignContent: function() {\n                    var contentOptions = this.options.content || {};\n                    var contentVisual = this._contentVisual;\n                    if (contentVisual && contentOptions.align) {\n                        var containerRect = this.visual._measure();\n                        var aligner = new diagram.RectAlign(containerRect);\n                        var contentBounds = contentVisual.drawingElement.bbox(null);\n\n                        var contentRect = new Rect(0, 0, contentBounds.width(), contentBounds.height());\n                        var alignedBounds = aligner.align(contentRect, contentOptions.align);\n\n                        contentVisual.position(alignedBounds.topLeft());\n                    }\n                },\n\n                _createConnectors: function() {\n                    var options = this.options,\n                        length = options.connectors.length,\n                        connectorDefaults = options.connectorDefaults,\n                        connector, i;\n\n                    for (i = 0; i < length; i++) {\n                        connector = new Connector(\n                            this, deepExtend({},\n                                connectorDefaults,\n                                options.connectors[i]\n                            )\n                        );\n                        this.connectors.push(connector);\n                    }\n                },\n\n                bounds: function(value) {\n                    var bounds;\n\n                    if (value) {\n                        if (isString(value)) {\n                            switch (value) {\n                                case TRANSFORMED :\n                                    bounds = this._transformedBounds();\n                                    break;\n                                case ABSOLUTE :\n                                    bounds = this._transformedBounds();\n                                    var pan = this.diagram._pan;\n                                    bounds.x += pan.x;\n                                    bounds.y += pan.y;\n                                    break;\n                                case ROTATED :\n                                    bounds = this._rotatedBounds();\n                                    break;\n                                default:\n                                    bounds = this._bounds;\n                            }\n                        } else {\n                            this._setBounds(value);\n                            this._triggerBoundsChange();\n                            if (!(this.diagram && this.diagram._layouting)) {\n                                this.refreshConnections();\n                            }\n                        }\n                    } else {\n                        bounds = this._bounds;\n                    }\n\n                    return bounds;\n                },\n\n                _setBounds: function(rect) {\n                    var options = this.options;\n                    var topLeft = rect.topLeft();\n                    var x = options.x = topLeft.x;\n                    var y = options.y = topLeft.y;\n                    var width = options.width = math.max(rect.width, options.minWidth);\n                    var height = options.height = math.max(rect.height, options.minHeight);\n\n                    this._bounds = new Rect(x, y, width, height);\n\n                    this.visual.redraw({\n                        x: x,\n                        y: y,\n                        width: width,\n                        height: height\n                    });\n                },\n\n                position: function(point) {\n                    if (point) {\n                        this.bounds(new Rect(point.x, point.y, this._bounds.width, this._bounds.height));\n                    } else {\n                        return this._bounds.topLeft();\n                    }\n                },\n                /**\n                 * Returns a clone of this shape.\n                 * @returns {Shape}\n                 */\n                clone: function() {\n                    var json = this.serialize();\n\n                    json.options.id = diagram.randomId();\n\n                    if (this.diagram && this.diagram._isEditable && defined(this.dataItem)) {\n                        json.options.dataItem = cloneDataItem(this.dataItem);\n                    }\n\n                    return new Shape(json.options);\n                },\n\n                select: function(value) {\n                    var diagram = this.diagram, selected, deselected;\n                    if (isUndefined(value)) {\n                        value = true;\n                    }\n\n                    if (this._canSelect()) {\n                        if (this.isSelected != value) {\n                            selected = [];\n                            deselected = [];\n                            this.isSelected = value;\n                            if (this.isSelected) {\n                                diagram._selectedItems.push(this);\n                                selected.push(this);\n                            } else {\n                                Utils.remove(diagram._selectedItems, this);\n                                deselected.push(this);\n                            }\n\n                            if (!diagram._internalSelection) {\n                                diagram._selectionChanged(selected, deselected);\n                            }\n\n                            return true;\n                        }\n                    }\n                },\n\n                rotate: function(angle, center, undoable) { // we assume the center is always the center of the shape.\n                    var rotate = this.visual.rotate();\n                    if (angle !== undefined$1) {\n                        if (undoable !== false && this.diagram && this.diagram.undoRedoService && angle !== rotate.angle) {\n                            this.diagram.undoRedoService.add(\n                                new diagram.RotateUnit(this.diagram._resizingAdorner, [this], [rotate.angle]), false);\n                        }\n\n                        var b = this.bounds(),\n                            sc = new Point(b.width / 2, b.height / 2),\n                            deltaAngle,\n                            newPosition;\n\n                        if (center) {\n                            deltaAngle = angle - rotate.angle;\n                            newPosition = b.center().rotate(deltaAngle, center).minus(sc);\n                            this._rotationOffset = this._rotationOffset.plus(newPosition.minus(b.topLeft()));\n                            this.position(newPosition);\n                        }\n\n                        this.visual.rotate(angle, sc);\n                        this.options.rotation.angle = angle;\n\n                        if (this.diagram && this.diagram._connectorsAdorner) {\n                            this.diagram._connectorsAdorner.refresh();\n                        }\n\n                        this.refreshConnections();\n\n                        if (this.diagram) {\n                            this.diagram.trigger(ITEMROTATE, { item: this });\n                        }\n                    }\n\n                    return rotate;\n                },\n\n                connections: function(type) { // in, out, undefined = both\n                    var result = [], i, j, con, cons, ctr;\n\n                    for (i = 0; i < this.connectors.length; i++) {\n                        ctr = this.connectors[i];\n                        cons = ctr.connections;\n                        for (j = 0, cons; j < cons.length; j++) {\n                            con = cons[j];\n                            if (type == \"out\") {\n                                var source = con.source();\n                                if (source.shape && source.shape == this) {\n                                    result.push(con);\n                                }\n                            } else if (type == \"in\") {\n                                var target = con.target();\n                                if (target.shape && target.shape == this) {\n                                    result.push(con);\n                                }\n                            } else {\n                                result.push(con);\n                            }\n                        }\n                    }\n\n                    return result;\n                },\n\n                refreshConnections: function() {\n                    $.each(this.connections(), function() {\n                        this.refresh();\n                    });\n                },\n                /**\n                 * Gets a connector of this shape either by the connector's supposed name or\n                 * via a Point in which case the closest connector will be returned.\n                 * @param nameOrPoint The name of a Connector or a Point.\n                 * @returns {Connector}\n                 */\n                getConnector: function(nameOrPoint) {\n                    var i, ctr;\n                    if (isString(nameOrPoint)) {\n                        nameOrPoint = nameOrPoint.toLocaleLowerCase();\n                        for (i = 0; i < this.connectors.length; i++) {\n                            ctr = this.connectors[i];\n                            if (ctr.options.name.toLocaleLowerCase() == nameOrPoint) {\n                                return ctr;\n                            }\n                        }\n                    } else if (nameOrPoint instanceof Point) {\n                        return closestConnector(nameOrPoint, this.connectors);\n                    } else {\n                        return this.connectors.length ? this.connectors[0] : null;\n                    }\n                },\n\n                getPosition: function(side) {\n                    var b = this.bounds(),\n                        fnName = side.charAt(0).toLowerCase() + side.slice(1);\n\n                    if (isFunction(b[fnName])) {\n                        return this._transformPoint(b[fnName]());\n                    }\n\n                    return b.center();\n                },\n\n                redraw: function(options) {\n                    if (options) {\n                        var shapeOptions = this.options;\n                        var boundsChange;\n\n                        this.shapeVisual.redraw(this._visualOptions(options));\n\n                        if (this._diffNumericOptions(options, [WIDTH, HEIGHT, X, Y])) {\n                            this.bounds(new Rect(shapeOptions.x, shapeOptions.y, shapeOptions.width, shapeOptions.height));\n                            boundsChange = true;\n                        }\n\n                        if (options.connectors) {\n                            shapeOptions.connectors = options.connectors;\n                            this._updateConnectors();\n                        }\n\n                        shapeOptions = deepExtend(shapeOptions, options);\n\n                        if (options.rotation || boundsChange) {\n                            this._rotate();\n                        }\n\n                        if (shapeOptions.content) {\n                            this.content(shapeOptions.content);\n                        }\n                    }\n                },\n\n                _updateConnectors: function() {\n                    var connections = this.connections();\n                    this.connectors = [];\n                    this._createConnectors();\n                    var connection;\n                    var source;\n                    var target;\n\n                    for (var idx = 0; idx < connections.length; idx++) {\n                        connection = connections[idx];\n                        source = connection.source();\n                        target = connection.target();\n                        if (source.shape && source.shape === this) {\n                            connection.source(this.getConnector(source.options.name) || null);\n                        } else if (target.shape && target.shape === this) {\n                            connection.target(this.getConnector(target.options.name) || null);\n                        }\n                        connection.updateModel();\n                    }\n                },\n\n                _diffNumericOptions: diagram.diffNumericOptions,\n\n                _visualOptions: function(options) {\n                    return {\n                        data: options.path,\n                        source: options.source,\n                        hover: options.hover,\n                        fill: options.fill,\n                        stroke: options.stroke\n                    };\n                },\n\n                _triggerBoundsChange: function() {\n                    if (this.diagram) {\n                        this.diagram.trigger(ITEMBOUNDSCHANGE, { item: this, bounds: this._bounds.clone() }); // the trigger modifies the arguments internally.\n                    }\n                },\n\n                _transformPoint: function(point) {\n                    var rotate = this.rotate(),\n                        bounds = this.bounds(),\n                        tl = bounds.topLeft();\n\n                    if (rotate.angle) {\n                        point.rotate(rotate.angle, rotate.center().plus(tl));\n                    }\n\n                    return point;\n                },\n\n                _transformedBounds: function() {\n                    var bounds = this.bounds(),\n                        tl = bounds.topLeft(),\n                        br = bounds.bottomRight();\n\n                    return Rect.fromPoints(this.diagram.modelToView(tl), this.diagram.modelToView(br));\n                },\n\n                _rotatedBounds: function() {\n                    var bounds = this.bounds().rotatedBounds(this.rotate().angle),\n                        tl = bounds.topLeft(),\n                        br = bounds.bottomRight();\n\n                    return Rect.fromPoints(tl, br);\n                },\n\n                _rotate: function() {\n                    var rotation = this.options.rotation;\n\n                    if (rotation && rotation.angle) {\n                        this.rotate(rotation.angle);\n                    }\n\n                    this._rotationOffset = new Point();\n                },\n\n                _hover: function(value) {\n                    var options = this.options,\n                        hover = options.hover,\n                        stroke = options.stroke,\n                        fill = options.fill;\n\n                    if (value && isDefined(hover.stroke)) {\n                        stroke = deepExtend({}, stroke, hover.stroke);\n                    }\n\n                    if (value && isDefined(hover.fill)) {\n                        fill = hover.fill;\n                    }\n\n                    this.shapeVisual.redraw({\n                        stroke: stroke,\n                        fill: fill\n                    });\n\n                    if (options.editable && options.editable.connect) {\n                        this.diagram._showConnectors(this, value);\n                    }\n                },\n\n                _hitTest: function(value) {\n                    if (this.visible()) {\n                        var bounds = this.bounds(), rotatedPoint,\n                            angle = this.rotate().angle;\n\n                        if (value.isEmpty && !value.isEmpty()) { // rect selection\n                            return Intersect.rects(value, bounds, angle ? angle : 0);\n                        } else { // point\n                            rotatedPoint = value.clone().rotate(angle, bounds.center()); // cloning is important because rotate modifies the point inline.\n                            if (bounds.contains(rotatedPoint)) {\n                                return this;\n                            }\n                        }\n                    }\n                },\n\n                toJSON: function() {\n                    return {\n                        shapeId: this.options.id\n                    };\n                },\n\n                createShapeVisual: function() {\n                    var options = this.options;\n                    var visualOptions = this._visualOptions(options);\n                    var visualTemplate = options.visual;\n                    var type = (options.type + \"\").toLocaleLowerCase();\n                    var shapeVisual;\n\n                    visualOptions.width = options.width;\n                    visualOptions.height = options.height;\n\n                    if (isFunction(visualTemplate)) { // custom template\n                        shapeVisual = visualTemplate.call(this, options);\n                    } else if (visualOptions.data) {\n                        shapeVisual = new Path(visualOptions);\n                        translateToOrigin(shapeVisual);\n                    } else if (type == \"rectangle\") {\n                        shapeVisual = new Rectangle(visualOptions);\n                    } else if (type == \"circle\") {\n                        shapeVisual = new Circle(visualOptions);\n                    } else if (type == \"text\") {\n                        shapeVisual = new TextBlock(visualOptions);\n                    } else if (type == \"image\") {\n                        shapeVisual = new Image(visualOptions);\n                    } else {\n                        shapeVisual = new Path(visualOptions);\n                    }\n\n                    this.shapeVisual = shapeVisual;\n                    this.visual.append(this.shapeVisual);\n                }\n            });\n\n            /**\n             * The visual link between two Shapes through the intermediate of Connectors.\n             */\n            var Connection = DiagramElement.extend({\n                init: function(from, to, options) {\n                    var that = this;\n                    DiagramElement.fn.init.call(that, options);\n                    this.updateOptionsFromModel();\n                    this._initRouter();\n                    that.path = new diagram.Polyline(that.options);\n                    that.path.fill(TRANSPARENT);\n                    that.visual.append(that.path);\n                    that._sourcePoint = that._targetPoint = new Point();\n                    that._setSource(from);\n                    that._setTarget(to);\n                    that.content(that.options.content);\n                    that.definers = [];\n                    if (defined(options) && options.points) {\n                        that.points(options.points);\n                    }\n                },\n\n                options: {\n                    hover: {\n                        stroke: {}\n                    },\n                    startCap: NONE,\n                    endCap: NONE,\n                    points: [],\n                    selectable: true,\n                    fromConnector: AUTO,\n                    toConnector: AUTO\n                },\n\n                _setOptionsFromModel: function(model) {\n                    this.updateOptionsFromModel(model || this.dataItem);\n                },\n\n                updateOptionsFromModel: function(model) {\n                    if (this.diagram && this.diagram._isEditable) {\n                        var dataMap = this.diagram._dataMap;\n                        var options = filterConnectionDataItem(model || this.dataItem);\n\n                        if (model) {\n                            if (defined(options.from)) {\n                                var from = dataMap[options.from];\n                                if (from && defined(options.fromConnector)) {\n                                   from = from.getConnector(options.fromConnector);\n                                }\n                                this.source(from);\n                            } else if (defined(options.fromX) && defined(options.fromY)) {\n                                this.source(new Point(options.fromX, options.fromY));\n                            }\n\n                            if (defined(options.to)) {\n                                var to = dataMap[options.to];\n                                if (to && defined(options.toConnector)) {\n                                    to = to.getConnector(options.toConnector);\n                                }\n                                this.target(to);\n                            } else if (defined(options.toX) && defined(options.toY)) {\n                                this.target(new Point(options.toX, options.toY));\n                            }\n\n                            if (defined(options.type) && this.type() !== options.type) {\n                                this.points([]);\n                                this.type(options.type);\n                            }\n\n                            this.dataItem = model;\n\n                            this._template();\n                            this.redraw(this.options);\n                        } else {\n                            this.options = deepExtend({}, options, this.options);\n                        }\n                    }\n                },\n\n                updateModel: function(syncChanges) {\n                    if (this.diagram && this.diagram._isEditable) {\n                        if (this.diagram.connectionsDataSource) {\n                            var model = this.diagram.connectionsDataSource.getByUid(this.dataItem.uid);\n\n                            if (model) {\n                                this.diagram._suspendModelRefresh();\n                                if (defined(this.options.fromX) && this.options.fromX !== null) {\n                                    clearField(\"from\", model);\n                                    clearField(\"fromConnector\", model);\n                                    model.set(\"fromX\", this.options.fromX);\n                                    model.set(\"fromY\", this.options.fromY);\n                                } else {\n                                    model.set(\"from\", this.options.from);\n                                    if (defined(model.fromConnector)) {\n                                        model.set(\"fromConnector\", this.sourceConnector ? this.sourceConnector.options.name : null);\n                                    }\n                                    clearField(\"fromX\", model);\n                                    clearField(\"fromY\", model);\n                                }\n\n                                if (defined(this.options.toX) && this.options.toX !== null) {\n                                    clearField(\"to\", model);\n                                    clearField(\"toConnector\", model);\n                                    model.set(\"toX\", this.options.toX);\n                                    model.set(\"toY\", this.options.toY);\n                                } else {\n                                    model.set(\"to\", this.options.to);\n                                    if (defined(model.toConnector)) {\n                                        model.set(\"toConnector\", this.targetConnector ? this.targetConnector.options.name : null);\n                                    }\n                                    clearField(\"toX\", model);\n                                    clearField(\"toY\", model);\n                                }\n\n                                if (defined(this.options.type) && defined(model.type)) {\n                                    model.set(\"type\", this.options.type);\n                                }\n\n                                this.dataItem = model;\n                                this.diagram._resumeModelRefresh();\n\n                                if (syncChanges) {\n                                    this.diagram._syncConnectionChanges();\n                                }\n                            }\n                        }\n                    }\n                },\n\n                /**\n                 * Gets the Point where the source of the connection resides.\n                 * If the endpoint in Auto-connector the location of the resolved connector will be returned.\n                 * If the endpoint is floating the location of the endpoint is returned.\n                 */\n                sourcePoint: function() {\n                    return this._resolvedSourceConnector ? this._resolvedSourceConnector.position() : this._sourcePoint;\n                },\n\n                _setSource: function(source) {\n                    var shapeSource = source instanceof Shape;\n                    var defaultConnector = this.options.fromConnector || AUTO;\n                    var dataItem;\n                    if (shapeSource && !source.getConnector(defaultConnector)) {\n                        return;\n                    }\n\n                    if (source !== undefined$1) {\n                        this.from = source;\n                    }\n\n                    this._removeFromSourceConnector();\n\n                    if (source === null) { // detach\n                        if (this.sourceConnector) {\n                            this._sourcePoint = (this._resolvedSourceConnector || this.sourceConnector).position();\n                            this._clearSourceConnector();\n                            this._setFromOptions(null, this._sourcePoint);\n                        }\n                    } else if (source instanceof Connector) {\n                        dataItem = source.shape.dataItem;\n                        if (dataItem) {\n                            this._setFromOptions(dataItem.id);\n                        }\n                        this.sourceConnector = source;\n                        this.sourceConnector.connections.push(this);\n                    } else if (source instanceof Point) {\n                        this._setFromOptions(null, source);\n                        this._sourcePoint = source;\n                        if (this.sourceConnector) {\n                            this._clearSourceConnector();\n                        }\n\n                    } else if (shapeSource) {\n                        dataItem = source.dataItem;\n                        if (dataItem) {\n                            this._setFromOptions(dataItem.id);\n                        }\n\n                        this.sourceConnector = source.getConnector(defaultConnector);\n                        this.sourceConnector.connections.push(this);\n                    }\n                },\n\n                source: function(source, undoable) {\n                    if (isDefined(source)) {\n                        if (undoable && this.diagram) {\n                            this.diagram.undoRedoService.addCompositeItem(new diagram.ConnectionEditUnit(this, source));\n                        }\n                        this._setSource(source);\n                        this.refresh();\n                    }\n                    return this.sourceConnector ? this.sourceConnector : this._sourcePoint;\n                },\n\n                _setFromOptions: function(from, fromPoint) {\n                    this.options.from = from;\n                    if (fromPoint) {\n                        this.options.fromX = fromPoint.x;\n                        this.options.fromY = fromPoint.y;\n                    } else {\n                        this.options.fromX = null;\n                        this.options.fromY = null;\n                    }\n                },\n\n                /**\n                 * Gets or sets the PathDefiner of the sourcePoint.\n                 * The left part of this definer is always null since it defines the source tangent.\n                 * @param value\n                 * @returns {*}\n                 */\n                sourceDefiner: function(value) {\n                    if (value) {\n                        if (value instanceof diagram.PathDefiner) {\n                            value.left = null;\n                            this._sourceDefiner = value;\n                            this.source(value.point); // refresh implicit here\n                        } else {\n                            throw \"The sourceDefiner needs to be a PathDefiner.\";\n                        }\n                    } else {\n                        if (!this._sourceDefiner) {\n                            this._sourceDefiner = new diagram.PathDefiner(this.sourcePoint(), null, null);\n                        }\n                        return this._sourceDefiner;\n                    }\n                },\n\n                /**\n                 * Gets  the Point where the target of the connection resides.\n                 */\n                targetPoint: function() {\n                    return this._resolvedTargetConnector ? this._resolvedTargetConnector.position() : this._targetPoint;\n                },\n\n                _setTarget: function(target) {\n                    var shapeTarget = target instanceof Shape;\n                    var defaultConnector = this.options.toConnector || AUTO;\n                    var dataItem;\n\n                    if (shapeTarget && !target.getConnector(defaultConnector)) {\n                        return;\n                    }\n\n                    if (target !== undefined$1) {\n                        this.to = target;\n                    }\n\n                    this._removeFromTargetConnector();\n\n                    if (target === null) { // detach\n                        if (this.targetConnector) {\n                            this._targetPoint = (this._resolvedTargetConnector || this.targetConnector).position();\n                            this._clearTargetConnector();\n                            this._setToOptions(null, this._targetPoint);\n                        }\n                    } else if (target instanceof Connector) {\n                        dataItem = target.shape.dataItem;\n                        if (dataItem) {\n                            this._setToOptions(dataItem.id);\n                        }\n                        this.targetConnector = target;\n                        this.targetConnector.connections.push(this);\n                    } else if (target instanceof Point) {\n                        this._setToOptions(null, target);\n                        this._targetPoint = target;\n                        if (this.targetConnector) {\n                            this._clearTargetConnector();\n                        }\n                    } else if (shapeTarget) {\n                        dataItem = target.dataItem;\n                        if (dataItem) {\n                            this._setToOptions(dataItem.id);\n                        }\n                        this.targetConnector = target.getConnector(defaultConnector);\n                        this.targetConnector.connections.push(this);\n                    }\n                },\n\n                target: function(target, undoable) {\n                    if (isDefined(target)) {\n                        if (undoable && this.diagram) {\n                            this.diagram.undoRedoService.addCompositeItem(new diagram.ConnectionEditUnit(this, undefined$1, target));\n                        }\n                        this._setTarget(target);\n\n                        this.refresh();\n                    }\n                    return this.targetConnector ? this.targetConnector : this._targetPoint;\n                },\n\n                _setToOptions: function(to, toPoint) {\n                    this.options.to = to;\n                    if (toPoint) {\n                        this.options.toX = toPoint.x;\n                        this.options.toY = toPoint.y;\n                    } else {\n                        this.options.toX = null;\n                        this.options.toY = null;\n                    }\n                },\n\n                /**\n                 * Gets or sets the PathDefiner of the targetPoint.\n                 * The right part of this definer is always null since it defines the target tangent.\n                 * @param value\n                 * @returns {*}\n                 */\n                targetDefiner: function(value) {\n                    if (value) {\n                        if (value instanceof diagram.PathDefiner) {\n                            value.right = null;\n                            this._targetDefiner = value;\n                            this.target(value.point); // refresh implicit here\n                        } else {\n                            throw \"The sourceDefiner needs to be a PathDefiner.\";\n                        }\n                    } else {\n                        if (!this._targetDefiner) {\n                            this._targetDefiner = new diagram.PathDefiner(this.targetPoint(), null, null);\n                        }\n                        return this._targetDefiner;\n                    }\n                },\n\n                _updateConnectors: function() {\n                    this._updateConnector(this.source(), \"source\");\n                    this._updateConnector(this.target(), \"target\");\n                },\n\n                _updateConnector: function(instance, name) {\n                    var that = this;\n                    var diagram = that.diagram;\n                    if (instance instanceof Connector && !diagram.getShapeById(instance.shape.id)) {\n                        var dataItem = instance.shape.dataItem;\n                        var connectorName = instance.options.name;\n                        var setNewTarget = function() {\n                            var shape = diagram._dataMap[dataItem.id];\n                            instance = shape.getConnector(connectorName);\n                            that[name](instance, false);\n                            that.updateModel();\n                        };\n                        if (diagram._dataMap[dataItem.id]) {\n                           setNewTarget();\n                        } else {\n                            var inactiveItem = diagram._inactiveShapeItems.getByUid(dataItem.uid);\n                            if (inactiveItem) {\n                                diagram._deferredConnectionUpdates.push(inactiveItem.onActivate(setNewTarget));\n                            }\n                        }\n                    } else {\n                        that[name](instance, false);\n                    }\n                },\n\n                content: function(content) {\n                    var result = this._content(content);\n                    if (defined(content)) {\n                        this._alignContent();\n                    }\n                    return result;\n                },\n\n                _createContentVisual: function(options) {\n                    var visual;\n                    if (isFunction(options.visual)) {\n                        visual = options.visual.call(this, options);\n                    } else if (options.text) {\n                        visual = new TextBlock(options);\n                    }\n\n                    if (visual) {\n                        this._contentVisual = visual;\n                        visual._includeInBBox = false;\n                        this.visual.append(visual);\n                    }\n\n                    return visual;\n                },\n\n                _updateContentVisual: function(options) {\n                    if (isFunction(options.visual)) {\n                        this.visual.remove(this._contentVisual);\n                        this._createContentVisual(options);\n                    } else {\n                        this._contentVisual.redraw(options);\n                    }\n                },\n\n                _alignContent: function() {\n                    if (this._contentVisual) {\n                        var offset = CONNECTION_CONTENT_OFFSET;\n                        var points = this.allPoints();\n                        var endIdx = math.floor(points.length / 2);\n                        var startIdx = endIdx - 1;\n\n                        while (startIdx > 0 && points[startIdx].equals(points[endIdx])) {\n                            startIdx--;\n                            endIdx++;\n                        }\n\n                        var endPoint = points[endIdx];\n                        var startPoint = points[startIdx];\n\n                        var boundingBox = this._contentVisual._measure();\n                        var width = boundingBox.width;\n                        var height = boundingBox.height;\n                        var alignToPath = points.length % 2 === 0;\n                        var distance = startPoint.distanceTo(endPoint);\n\n                        if (alignToPath && points.length > 2 && distance > 0 &&\n                            ((startPoint.y === endPoint.y && distance < width) || (startPoint.x === endPoint.x && distance < height))) {\n                            alignToPath = false;\n                            offset = 0;\n                        }\n\n                        var point;\n\n                        if (alignToPath) {\n                            var angle = draw.util.deg(math.atan2(endPoint.y - startPoint.y, endPoint.x - startPoint.x));\n                            point = new Point((endPoint.x - startPoint.x) / 2 + startPoint.x, (endPoint.y - startPoint.y) / 2 + startPoint.y);\n\n                            if (math.abs(angle) === 90) {\n                                point.x += offset;\n                                point.y -= height / 2;\n                            } else if (angle % 180 === 0) {\n                                point.x -= width / 2;\n                                point.y -= height + offset;\n                            } else if (angle < -90 || (0 < angle && angle < 90)) {\n                                point.y -= height;\n                            } else if (angle < 0 || angle > 90) {\n                                point.x -= width;\n                                point.y -= height;\n                            }\n                        } else {\n                            var midIdx = math.floor(points.length / 2);\n                            point = points[midIdx].clone();\n                            startPoint = points[midIdx - 1];\n                            endPoint = points[midIdx + 1];\n\n                            var offsetX = startPoint.x <= point.x && endPoint.x <= point.x ? offset : -boundingBox.width - offset;\n                            var offsetY = startPoint.y <= point.y && endPoint.y <= point.y ? offset : -boundingBox.height - offset;\n\n                            point.x += offsetX;\n                            point.y += offsetY;\n                        }\n\n                        this._contentVisual.position(point);\n                    }\n                },\n\n                /**\n                 * Selects or unselects this connections.\n                 * @param value True to select, false to unselect.\n                 */\n                select: function(value) {\n                    var diagram = this.diagram, selected, deselected;\n                    if (this._canSelect()) {\n                        if (this.isSelected !== value) {\n                            this.isSelected = value;\n                            selected = [];\n                            deselected = [];\n                            if (this.isSelected) {\n                                this.adorner = new ConnectionEditAdorner(this, this.options.selection);\n                                diagram._adorn(this.adorner, true);\n                                diagram._selectedItems.push(this);\n                                selected.push(this);\n                            } else {\n                                if (this.adorner) {\n                                    diagram._adorn(this.adorner, false);\n                                    Utils.remove(diagram._selectedItems, this);\n                                    this.adorner = undefined$1;\n                                    deselected.push(this);\n                                }\n                            }\n\n                            if (this.adorner) {\n                                this.adorner.refresh();\n                            }\n\n                            if (!diagram._internalSelection) {\n                                diagram._selectionChanged(selected, deselected);\n                            }\n                            return true;\n                        }\n                    }\n                },\n                /**\n                 * Gets or sets the bounds of this connection.\n                 * @param value A Rect object.\n                 * @remark This is automatically set in the refresh().\n                 * @returns {Rect}\n                 */\n                bounds: function(value) {\n                    if (value && !isString(value)) {\n                        this._bounds = value;\n                    } else {\n                        return this._bounds;\n                    }\n                },\n                /**\n                 * Gets or sets the connection type (see ConnectionType enumeration).\n                 * @param value A ConnectionType value.\n                 * @returns {ConnectionType}\n                 */\n                type: function(value) {\n                    var options = this.options;\n                    if (value) {\n                        if (value !== options.type) {\n                            options.type = value;\n                            this._initRouter();\n                            this.refresh();\n                        }\n                    } else {\n                        return options.type;\n                    }\n                },\n\n                _initRouter: function() {\n                    var type = (this.options.type || \"\").toLowerCase();\n                    if (type == CASCADING) {\n                        this._router = new CascadingRouter(this);\n                    } else {\n                        this._router = new PolylineRouter(this);\n                    }\n                },\n                /**\n                 * Gets or sets the collection of *intermediate* points.\n                 * The 'allPoints()' property will return all the points.\n                 * The 'definers' property returns the definers of the intermediate points.\n                 * The 'sourceDefiner' and 'targetDefiner' return the definers of the endpoints.\n                 * @param value\n                 */\n                points: function(value) {\n                    if (value) {\n                        this.definers = [];\n                        for (var i = 0; i < value.length; i++) {\n                            var definition = value[i];\n                            if (definition instanceof diagram.Point) {\n                                this.definers.push(new diagram.PathDefiner(definition));\n                            } else if (definition.hasOwnProperty(\"x\") && definition.hasOwnProperty(\"y\")) { // e.g. Clipboard does not preserve the Point definition and tunred into an Object\n                                this.definers.push(new diagram.PathDefiner(new Point(definition.x, definition.y)));\n                            } else {\n                                throw \"A Connection point needs to be a Point or an object with x and y properties.\";\n                            }\n                        }\n\n                    } else {\n                        var pts = [];\n                        if (isDefined(this.definers)) {\n                            for (var k = 0; k < this.definers.length; k++) {\n                                pts.push(this.definers[k].point);\n                            }\n                        }\n                        return pts;\n                    }\n                },\n                /**\n                 * Gets all the points of this connection. This is the combination of the sourcePoint, the points and the targetPoint.\n                 * @returns {Array}\n                 */\n                allPoints: function() {\n                    var pts = [this.sourcePoint()];\n                    if (this.definers) {\n                        for (var k = 0; k < this.definers.length; k++) {\n                            pts.push(this.definers[k].point);\n                        }\n                    }\n                    pts.push(this.targetPoint());\n                    return pts;\n                },\n\n                refresh: function() {\n                    this._resolveConnectors();\n                    this._refreshPath();\n                    this._alignContent();\n\n                    if (this.adorner) {\n                        this.adorner.refresh();\n                    }\n                },\n\n                _resolveConnectors: function() {\n                    var connection = this,\n                        sourcePoint, targetPoint,\n                        sourceConnectors, targetConnectors,\n                        source = connection.source(),\n                        target = connection.target();\n\n                    if (source instanceof Point) {\n                        sourcePoint = source;\n                    } else if (source instanceof Connector) {\n                        if (isAutoConnector(source)) {\n                            sourceConnectors = source.shape.connectors;\n                        } else {\n                            sourceConnectors = [source];\n                        }\n                    }\n\n                    if (target instanceof Point) {\n                        targetPoint = target;\n                    } else if (target instanceof Connector) {\n                        if (isAutoConnector(target)) {\n                            targetConnectors = target.shape.connectors;\n                        } else {\n                            targetConnectors = [target];\n                        }\n                    }\n\n                    if (sourcePoint) {\n                        if (targetConnectors) {\n                            connection._resolvedTargetConnector = closestConnector(sourcePoint, targetConnectors);\n                        }\n                    } else if (sourceConnectors) {\n                        if (targetPoint) {\n                            connection._resolvedSourceConnector = closestConnector(targetPoint, sourceConnectors);\n                        } else if (targetConnectors) {\n                            this._resolveAutoConnectors(sourceConnectors, targetConnectors);\n                        }\n                    }\n                },\n\n                _resolveAutoConnectors: function(sourceConnectors, targetConnectors) {\n                    var minNonConflict = MAXINT;\n                    var minDist = MAXINT;\n                    var minNonConflictSource, minNonConflictTarget;\n                    var sourcePoint, targetPoint;\n                    var minSource, minTarget;\n                    var sourceConnector, targetConnector;\n                    var sourceIdx, targetIdx;\n                    var dist;\n\n                    for (sourceIdx = 0; sourceIdx < sourceConnectors.length; sourceIdx++) {\n                        sourceConnector = sourceConnectors[sourceIdx];\n                        if (!isAutoConnector(sourceConnector)) {\n                            sourcePoint = sourceConnector.position();\n\n                            for (targetIdx = 0; targetIdx < targetConnectors.length; targetIdx++) {\n                                targetConnector = targetConnectors[targetIdx];\n                                if (!isAutoConnector(targetConnector)) {\n                                    targetPoint = targetConnector.position();\n                                    dist = math.round(sourcePoint.distanceTo(targetPoint));\n\n                                    if (dist < minNonConflict && this.diagram && this._testRoutePoints(sourcePoint, targetPoint, sourceConnector, targetConnector)) {\n                                        minNonConflict = dist;\n                                        minNonConflictSource = sourceConnector;\n                                        minNonConflictTarget = targetConnector;\n                                    }\n\n                                    if (dist < minDist) {\n                                        minSource = sourceConnector;\n                                        minTarget = targetConnector;\n                                        minDist = dist;\n                                    }\n                                }\n                            }\n                        }\n                    }\n\n                    if (minNonConflictSource) {\n                        minSource = minNonConflictSource;\n                        minTarget = minNonConflictTarget;\n                    }\n\n                    this._resolvedSourceConnector = minSource;\n                    this._resolvedTargetConnector = minTarget;\n                },\n\n                _testRoutePoints: function(sourcePoint, targetPoint, sourceConnector, targetConnector) {\n                    var router = this._router;\n                    var passRoute = true;\n                    if (router instanceof CascadingRouter) {\n                        var points = router.routePoints(sourcePoint, targetPoint, sourceConnector, targetConnector),\n                            start, end,\n                             rect, exclude;\n\n                        exclude = this._getRouteExclude(sourcePoint, targetPoint, sourceConnector.shape, targetConnector.shape);\n                        points.unshift(sourcePoint);\n                        points.push(targetPoint);\n\n\n                        for (var idx = 1; idx < points.length; idx++) {\n                            start = points[idx - 1];\n                            end = points[idx];\n                            rect = new Rect(math.min(start.x, end.x), math.min(start.y, end.y),\n                                            math.abs(start.x - end.x), math.abs(start.y - end.y));\n                            if (rect.width > 0) {\n                                rect.x++;\n                                rect.width -= 2;\n                            }\n                            if (rect.height > 0) {\n                                rect.y++;\n                                rect.height -= 2;\n                            }\n\n                            if (!rect.isEmpty() && this.diagram._shapesQuadTree.hitTestRect(rect, exclude)) {\n                                passRoute = false;\n                                break;\n                            }\n                        }\n                    }\n                    return passRoute;\n                },\n\n                _getRouteExclude: function(sourcePoint, targetPoint, sourceShape, targetShape) {\n                    var exclude = [];\n                    if (this._isPointInsideShape(sourcePoint, sourceShape)) {\n                        exclude.push(sourceShape);\n                    }\n                    if (this._isPointInsideShape(targetPoint, targetShape)) {\n                        exclude.push(targetShape);\n                    }\n                    return exclude;\n                },\n\n                _isPointInsideShape: function(point, shape) {\n                    var bounds = shape.bounds(), rotatedPoint,\n                        angle = shape.rotate().angle,\n                        pointX, pointY,\n                        boundsX = bounds.x,\n                        boundsY = bounds.y;\n\n                    rotatedPoint = point.clone().rotate(angle, bounds.center());\n                    pointX = rotatedPoint.x;\n                    pointY = rotatedPoint.y;\n                    return pointX > boundsX && pointX < (boundsX + bounds.width) && pointY > boundsY && pointY < (boundsY + bounds.height);\n                },\n\n                redraw: function(options) {\n                    if (options) {\n                        this.options = deepExtend({}, this.options, options);\n\n                        var points = this.options.points;\n\n                        if (defined(points) && points.length > 0) {\n                            this.points(points);\n                            this._refreshPath();\n                        }\n\n                        if ((options && options.content) || options.text) {\n                            this.content(options.content);\n                        }\n\n                        this.path.redraw({\n                            fill: options.fill,\n                            stroke: options.stroke,\n                            startCap: options.startCap,\n                            endCap: options.endCap\n                        });\n                    }\n                },\n                /**\n                 * Returns a clone of this connection.\n                 * @returns {Connection}\n                 */\n                clone: function() {\n                    var json = this.serialize();\n\n                    if (this.diagram && this.diagram._isEditable && defined(this.dataItem)) {\n                        json.options.dataItem = cloneDataItem(this.dataItem);\n                    }\n\n                    return new Connection(this.from, this.to, json.options);\n                },\n                /**\n                 * Returns a serialized connection in json format. Consist of the options and the dataItem.\n                 * @returns {Connection}\n                 */\n                serialize: function() {\n                    var from = this.from.toJSON ? this.from.toJSON : this.from.toString(),\n                        to = this.to.toJSON ? this.to.toJSON : this.to.toString();\n\n                    var json = deepExtend({}, {\n                        options: this.options,\n                        from: from,\n                        to: to\n                    });\n\n                    if (defined(this.dataItem)) {\n                        json.dataItem = this.dataItem.toString();\n                    }\n\n                    json.options.points = this.points();\n                    return json;\n                },\n\n                /**\n                 * Returns whether the given Point or Rect hits this connection.\n                 * @param value\n                 * @returns {Connection}\n                 * @private\n                 */\n                _hitTest: function(value) {\n                    if (this.visible()) {\n                        var p = new Point(value.x, value.y), from = this.sourcePoint(), to = this.targetPoint();\n                        if (value.isEmpty && !value.isEmpty() && value.contains(from) && value.contains(to)) {\n                            return this;\n                        }\n                        if (this._router.hitTest(p)) {\n                            return this;\n                        }\n                    }\n                },\n\n                _hover: function(value) {\n                    var color = (this.options.stroke || {}).color;\n\n                    if (value && isDefined(this.options.hover.stroke.color)) {\n                        color = this.options.hover.stroke.color;\n                    }\n\n                    this.path.redraw({\n                        stroke: {\n                            color: color\n                        }\n                    });\n                },\n\n                _refreshPath: function() {\n                    if (!defined(this.path)) {\n                        return;\n                    }\n                    this._drawPath();\n                    this.bounds(this._router.getBounds());\n                },\n\n                _drawPath: function() {\n                    if (this._router) {\n                        this._router.route(); // sets the intermediate points\n                    }\n                    var source = this.sourcePoint();\n                    var target = this.targetPoint();\n                    var points = this.points();\n\n                    this.path.redraw({\n                        points: [source].concat(points, [target])\n                    });\n                },\n\n                _clearSourceConnector: function() {\n                    this.sourceConnector = undefined$1;\n                    this._resolvedSourceConnector = undefined$1;\n                },\n\n                _clearTargetConnector: function() {\n                    this.targetConnector = undefined$1;\n                    this._resolvedTargetConnector = undefined$1;\n                },\n\n                _removeFromSourceConnector: function() {\n                    if (this.sourceConnector) {\n                        Utils.remove(this.sourceConnector.connections, this);\n                    }\n                },\n\n                _removeFromTargetConnector: function() {\n                    if (this.targetConnector) {\n                        Utils.remove(this.targetConnector.connections, this);\n                    }\n                },\n\n                toJSON: function() {\n                    var connection = this;\n                    var from, to, point;\n                    if (connection.from && connection.from.toJSON) {\n                        from = connection.from.toJSON();\n                    } else {\n                        point = connection._sourcePoint;\n                        from = {\n                            x: point.x,\n                            y: point.y\n                        };\n                    }\n\n                    if (connection.to && connection.to.toJSON) {\n                        to = connection.to.toJSON();\n                    } else {\n                        point = connection._targetPoint;\n                        to = {\n                            x: point.x,\n                            y: point.y\n                        };\n                    }\n\n                    return {\n                        from: from,\n                        to: to\n                    };\n                }\n            });\n\n            var Diagram = Widget.extend({\n                init: function(element, userOptions) {\n                    var that = this;\n\n                    kendo.destroy(element);\n                    Widget.fn.init.call(that, element, userOptions);\n\n                    that._initElements();\n                    that._initTheme();\n\n                    that._extendLayoutOptions(that.options);\n                    that._initDefaults(userOptions);\n                    that._interactionDefaults();\n\n                    that._initCanvas();\n\n                    that.mainLayer = new Group({\n                        id: \"main-layer\"\n                    });\n                    that.canvas.append(that.mainLayer);\n\n                    that._shapesQuadTree = new ShapesQuadTree(that);\n\n                    that._pan = new Point();\n                    that._adorners = [];\n                    that.adornerLayer = new Group({\n                        id: \"adorner-layer\"\n                    });\n                    that.canvas.append(that.adornerLayer);\n\n                    that._createHandlers();\n\n                    that._initialize();\n\n                    that._resizingAdorner = new ResizingAdorner(that, { editable: that.options.editable });\n                    that._connectorsAdorner = new ConnectorsAdorner(that);\n\n                    that._adorn(that._resizingAdorner, true);\n                    that._adorn(that._connectorsAdorner, true);\n\n                    that.selector = new Selector(that);\n                    // TODO: We may consider using real Clipboard API once is supported by the standard.\n                    that._clipboard = [];\n\n                    that.pauseMouseHandlers = false;\n\n                    that._fetchFreshData();\n\n                    that._createGlobalToolBar();\n\n                    that._createOptionElements();\n\n                    that.zoom(that.options.zoom);\n\n                    that.canvas.draw();\n                },\n\n                options: {\n                    name: \"Diagram\",\n                    theme: \"sass\",\n                    layout: \"\",\n                    zoomRate: 0.1,\n                    zoom: 1,\n                    zoomMin: 0,\n                    zoomMax: 2,\n                    dataSource: {},\n                    draggable: true,\n                    template: \"\",\n                    autoBind: true,\n                    editable: {\n                        rotate: {},\n                        resize: {},\n                        text: true,\n                        tools: [],\n                        drag: {\n                            snap: {\n                                size: 10,\n                                angle: 10\n                            }\n                        },\n                        remove: true\n                    },\n                    pannable: {},\n                    selectable: {\n                        key: \"none\"\n                    },\n                    tooltip: { enabled: true, format: \"{0}\" },\n                    copy: {\n                        enabled: true,\n                        offsetX: 20,\n                        offsetY: 20\n                    },\n                    shapeDefaults: diagram.shapeDefaults({ undoable: true }),\n                    connectionDefaults: {\n                        editable: {\n                            tools: []\n                        },\n                        type: CASCADING\n                    },\n                    shapes: [],\n                    connections: []\n                },\n\n                events: [\n                    ZOOM_END,\n                    ZOOM_START,\n                    PAN, SELECT,\n                    ITEMROTATE,\n                    ITEMBOUNDSCHANGE,\n                    CHANGE,\n                    CLICK,\n                    MOUSE_ENTER,\n                    MOUSE_LEAVE,\n                    \"toolBarClick\",\n                    \"save\",\n                    \"cancel\",\n                    \"edit\",\n                    \"remove\",\n                    \"add\",\n                    \"dataBound\",\n                    DRAG_START,\n                    DRAG,\n                    DRAG_END\n                ],\n\n                items: function() {\n                    return $();\n                },\n\n                _createGlobalToolBar: function() {\n                    var editable = this.options.editable;\n                    if (editable) {\n                        var tools = editable.tools;\n                        if (this._isEditable && tools !== false && (!tools || tools.length === 0)) {\n                            tools = [\"createShape\", \"undo\", \"redo\", \"rotateClockwise\", \"rotateAnticlockwise\"];\n                        }\n\n                        if (tools && tools.length) {\n                            this.toolBar = new DiagramToolBar(this, {\n                                tools: tools || {},\n                                click: this._toolBarClick.bind(this),\n                                modal: false\n                            });\n\n                            this.toolBar.element.css({\n                                textAlign: \"left\"\n                            });\n\n                            this.element.prepend(this.toolBar.element);\n                            this._resize();\n                        }\n                    }\n                },\n\n                createShape: function() {\n                    if ((this.editor && this.editor.end()) || !this.editor) {\n                        var dataSource = this.dataSource;\n                        var view = dataSource.view() || [];\n                        var index = view.length;\n                        var model = createModel(dataSource, {});\n                        var shape = this._createShape(model, {});\n\n                        if (!this.trigger(\"add\", { shape: shape })) {\n                            dataSource.insert(index, model);\n                            var inactiveItem = this._inactiveShapeItems.getByUid(model.uid);\n                            inactiveItem.element = shape;\n                            this.edit(shape);\n                        }\n                    }\n                },\n\n                _createShape: function(dataItem, options) {\n                    options = deepExtend({}, this.options.shapeDefaults, options);\n                    options.dataItem = dataItem;\n                    var shape = new Shape(options, this);\n                    return shape;\n                },\n\n                createConnection: function() {\n                    if (((this.editor && this.editor.end()) || !this.editor)) {\n                        var connectionsDataSource = this.connectionsDataSource;\n                        var view = connectionsDataSource.view() || [];\n                        var index = view.length;\n                        var model = createModel(connectionsDataSource, {});\n                        var connection = this._createConnection(model);\n                        if (!this.trigger(\"add\", { connection: connection })) {\n                            this._connectionsDataMap[model.uid] = connection;\n                            connectionsDataSource.insert(index, model);\n                            this.addConnection(connection, false);\n                            this.edit(connection);\n                        }\n                    }\n                },\n\n                _createConnection: function(dataItem, source, target) {\n                    var options = deepExtend({}, this.options.connectionDefaults);\n                    options.dataItem = dataItem;\n\n                    var connection = new Connection(source || new Point(), target || new Point(), options);\n\n                    return connection;\n                },\n\n                editModel: function(dataItem, editorType) {\n                    this.cancelEdit();\n                    var editors, template;\n                    var editable = this.options.editable;\n\n                    if (editorType == \"shape\") {\n                        editors = editable.shapeEditors;\n                        template = editable.shapeTemplate;\n                    } else if (editorType == \"connection\") {\n                        var connectionSelectorHandler = connectionSelector.bind(this);\n                        editors = deepExtend({}, { from: connectionSelectorHandler, to: connectionSelectorHandler }, editable.connectionEditors);\n                        template = editable.connectionTemplate;\n                    } else {\n                        return;\n                    }\n\n                    this.editor = new PopupEditor(this.element, {\n                        update: this._update.bind(this),\n                        cancel: this._cancel.bind(this),\n                        model: dataItem,\n                        type: editorType,\n                        target: this,\n                        editors: editors,\n                        template: template\n                    });\n\n                    this.trigger(\"edit\", this._editArgs());\n                },\n\n                edit: function(item) {\n                    if (item.dataItem) {\n                        var editorType = item instanceof Shape ? \"shape\" : \"connection\";\n                        this.editModel(item.dataItem, editorType);\n                    }\n                },\n\n                cancelEdit: function() {\n                    if (this.editor) {\n                        this._getEditDataSource().cancelChanges(this.editor.model);\n\n                        this._destroyEditor();\n                    }\n                },\n\n                saveEdit: function() {\n                    if (this.editor && this.editor.end() &&\n                        !this.trigger(\"save\", this._editArgs())) {\n                        this._getEditDataSource().sync();\n                    }\n                },\n\n                _update: function() {\n                    if (this.editor && this.editor.end() &&\n                        !this.trigger(\"save\", this._editArgs())) {\n                        this._getEditDataSource().sync();\n                        this._destroyEditor();\n                    }\n                },\n\n                _cancel: function() {\n                    if (this.editor && !this.trigger(\"cancel\", this._editArgs())) {\n                        var model = this.editor.model;\n                        this._getEditDataSource().cancelChanges(model);\n                        var element = this._connectionsDataMap[model.uid] || this._dataMap[model.id];\n                        if (element) {\n                            element._setOptionsFromModel(model);\n                        }\n                        this._destroyEditor();\n                    }\n                },\n\n                _getEditDataSource: function() {\n                    return this.editor.options.type === \"shape\" ? this.dataSource : this.connectionsDataSource;\n                },\n\n                _editArgs: function() {\n                    var result = { container: this.editor.wrapper };\n                    result[this.editor.options.type] = this.editor.model;\n                    return result;\n                },\n\n                _destroyEditor: function() {\n                    if (this.editor) {\n                        this.editor.close();\n                        this.editor = null;\n                    }\n                },\n\n                _initElements: function() {\n                    this.wrapper = this.element.empty()\n                        .css(\"position\", \"relative\")\n                        .attr(\"tabindex\", 0)\n                        .addClass(\"k-widget k-diagram\");\n\n                    this.scrollable = $(\"<div />\").appendTo(this.element);\n                },\n\n                _initDefaults: function(userOptions) {\n                    var options = this.options;\n                    var editable = options.editable;\n                    var shapeDefaults = options.shapeDefaults;\n                    var connectionDefaults = options.connectionDefaults;\n                    var userShapeDefaults = (userOptions || {}).shapeDefaults;\n                    if (editable === false) {\n                        shapeDefaults.editable = false;\n                        connectionDefaults.editable = false;\n                    } else {\n                        copyDefaultOptions(editable, shapeDefaults.editable, [\"drag\", \"remove\", \"connect\"]);\n                        copyDefaultOptions(editable, connectionDefaults.editable, [\"drag\", \"remove\"]);\n                    }\n\n                    if (userShapeDefaults && userShapeDefaults.connectors) {\n                        options.shapeDefaults.connectors = userShapeDefaults.connectors;\n                    }\n                },\n\n                _interactionDefaults: function() {\n                    var options = this.options;\n                    var selectable = options.selectable;\n                    var pannable = options.pannable;\n                    var mobile = kendo.support.mobileOS;\n\n                    if (selectable && !defined(selectable.multiple)) {\n                        options.selectable = deepExtend({\n                            multiple: mobile ? false : true\n                        }, options.selectable);\n                    }\n\n                    if (pannable && !defined(pannable.key)) {\n                        options.pannable = deepExtend({\n                            key: mobile ? \"none\" : \"ctrl\"\n                        }, options.pannable);\n                    }\n                },\n\n                _initCanvas: function() {\n                    var canvasContainer = $(\"<div class='k-layer'></div>\").appendTo(this.scrollable)[0];\n                    var viewPort = this.viewport();\n                    this.canvas = new Canvas(canvasContainer, {\n                        width: viewPort.width || DEFAULT_CANVAS_WIDTH,\n                        height: viewPort.height || DEFAULT_CANVAS_HEIGHT\n                    });\n                },\n\n                _createHandlers: function() {\n                    var that = this;\n                    var element = that.element;\n\n                    element.on(MOUSEWHEEL_NS, that._wheel.bind(that))\n                    .on(\"keydown\" + NS, that._keydown.bind(that));\n\n                    that._userEvents = new kendo.UserEvents(this.scrollable, {\n                        multiTouch: true,\n                        fastTap: true,\n                        tap: that._tap.bind(that),\n                        start: that._dragStart.bind(that),\n                        move: that._drag.bind(that),\n                        end: that._dragEnd.bind(that),\n                        gesturestart: that._gestureStart.bind(that),\n                        gesturechange: that._gestureChange.bind(that),\n                        gestureend: that._gestureEnd.bind(that),\n                        doubleTap: that._doubleTap.bind(that),\n                        supportDoubleTap: true\n                    });\n\n                    that.toolService = new ToolService(that);\n\n                    this.scrollable\n                        .on(\"mouseover\" + NS, that._mouseover.bind(that))\n                        .on(\"mouseout\" + NS, that._mouseout.bind(that))\n                        .on(\"mousemove\" + NS, that._mouseMove.bind(that))\n                        .on(\"mousedown\" + NS, that._mouseDown.bind(that))\n                        .on(\"mouseup\" + NS, that._mouseUp.bind(that));\n\n                    this._syncHandler = that._syncChanges.bind(that);\n\n                    that._resizeHandler = that.resize.bind(that, false);\n                    kendo.onResize(that._resizeHandler);\n\n                    this.bind(ZOOM_START, that._destroyToolBar.bind(that));\n                    this.bind(PAN, that._destroyToolBar.bind(that));\n                },\n\n                _dragStart: function(e) {\n                    this._pauseMouseHandlers = true;\n                    var point = this._eventPositions(e, true);\n\n                    var event = e.event;\n                    if (this.toolService.start(point, this._meta(event))) {\n                        this._destroyToolBar();\n                        event.preventDefault();\n                    }\n                },\n\n                _drag: function(e) {\n                    var p = this._eventPositions(e);\n                    var event = e.event;\n                    if (this.toolService.move(p, this._meta(event))) {\n                        event.preventDefault();\n                    }\n                },\n\n                _dragEnd: function(e) {\n                    this._pauseMouseHandlers = false;\n                    var p = this._eventPositions(e);\n                    var event = e.event;\n                    if (this.toolService.end(p, this._meta(event))) {\n                        this._createToolBar();\n                        event.preventDefault();\n                    }\n                },\n\n                _mouseMove: function(e) {\n                    if (!this._pauseMouseHandlers) {\n                        var p = this._eventPositions(e);\n                        this.toolService._updateHoveredItem(p);\n                        this.toolService._updateCursor(p);\n                    }\n                },\n\n                _mouseDown: function() {\n                    this._pauseMouseHandlers = true;\n                },\n\n                _mouseUp: function() {\n                    this._pauseMouseHandlers = false;\n                },\n\n                _tap: function(e) {\n                    var toolService = this.toolService;\n                    var selectable = this.options.selectable;\n                    var point = this._eventPositions(e);\n                    var focused = this.focus();\n\n                    toolService._updateHoveredItem(point);\n\n                    if (toolService.hoveredItem) {\n                        var item = toolService.hoveredItem;\n\n                        this.trigger(\"click\", {\n                            item: item,\n                            point: point,\n                            meta: this._meta(e.event)\n                        });\n\n                        if (selectable && item.options.selectable !== false) {\n                            var multiple = selectable.multiple !== false;\n                            var ctrlPressed = kendo.support.mobileOS || this._meta(e.event).ctrlKey;\n\n                            if (item.isSelected) {\n                                if (ctrlPressed) {\n                                    this._destroyToolBar();\n                                    item.select(false);\n                                } else {\n                                    this._createToolBar(focused);\n                                }\n                            } else {\n                                this._destroyToolBar();\n                                this.select(item, {\n                                    addToSelection: multiple && ctrlPressed\n                                });\n                                this._createToolBar(focused);\n                            }\n                        }\n                    } else if (selectable) {\n                        this._destroyToolBar();\n                        this.deselect();\n                    }\n                },\n\n                _keydown: function(e) {\n                    if (this.toolService.keyDown(e.keyCode, this._meta(e))) {\n                        e.preventDefault();\n                    }\n                },\n\n                _wheel: function(e) {\n                    var delta = mwDelta(e),\n                        p = this._eventPositions(e),\n                        meta = deepExtend(this._meta(e), { delta: delta });\n\n                    if (this.toolService.wheel(p, meta)) {\n                        e.preventDefault();\n                    }\n                },\n\n                _meta: function(e) {\n                    return { ctrlKey: e.ctrlKey, metaKey: e.metaKey, altKey: e.altKey, shiftKey: e.shiftKey, type: e.type };\n                },\n\n                _eventPositions: function(e, start) {\n                    var point;\n                    if (e.touch) {\n                        var field = start ? \"startLocation\" : \"location\";\n                        point = new Point(e.x[field], e.y[field]);\n                    } else {\n                        var event = e.originalEvent;\n                        point = new Point(event.pageX, event.pageY);\n                    }\n\n                    return this.documentToModel(point);\n                },\n\n                _gestureStart: function(e) {\n                    this._destroyToolBar();\n                    this.scroller.disable();\n                    var initialCenter = this.documentToModel(new Point(e.center.x, e.center.y));\n                    var eventArgs = {\n                        point: initialCenter,\n                        zoom: this.zoom()\n                    };\n\n                    if (this.trigger(ZOOM_START, eventArgs)) {\n                        return;\n                    }\n\n                    this._gesture = e;\n                    this._initialCenter = initialCenter;\n                },\n\n                _gestureChange: function(e) {\n                    var previousGesture = this._gesture;\n                    var initialCenter = this._initialCenter;\n                    var center = this.documentToView(new Point(e.center.x, e.center.y));\n                    var scaleDelta = e.distance / previousGesture.distance;\n                    var zoom = this._zoom;\n                    var updateZoom = false;\n\n                    if (math.abs(scaleDelta - 1) >= MOBILE_ZOOM_RATE) {\n                        this._zoom = zoom = this._getValidZoom(zoom * scaleDelta);\n                        this.options.zoom = zoom;\n                        this._gesture = e;\n                        updateZoom = true;\n                    }\n\n                    var zoomedPoint = initialCenter.times(zoom);\n                    var pan = center.minus(zoomedPoint);\n                    if (updateZoom || this._pan.distanceTo(pan) >= MOBILE_PAN_DISTANCE) {\n                        this._panTransform(pan);\n                        this._updateAdorners();\n                    }\n\n                    e.preventDefault();\n                },\n\n                _doubleTap: function(e) {\n                    var diagram = this;\n                    var pointPosition = this._eventPositions(e);\n                    var options = diagram.options;\n                    var zoomRate = options.zoomRate;\n                    var zoom = diagram.zoom() + zoomRate;\n                    var meta = this._meta(e);\n                    var zoomOptions = { point: pointPosition, meta: meta, zoom: zoom };\n\n\n                    if (diagram.trigger(ZOOM_START, zoomOptions)) {\n                        return;\n                    }\n\n                    zoom = kendo.drawing.util.round(Math.max(options.zoomMin, Math.min(options.zoomMax, zoom)), 2);\n                    zoomOptions.zoom = zoom;\n\n                    diagram.zoom(zoom, zoomOptions);\n                    diagram.trigger(ZOOM_END, zoomOptions);\n                },\n\n                _gestureEnd: function() {\n                    if (this.options.pannable !== false) {\n                        this.scroller.enable();\n                    }\n                    this.trigger(ZOOM_END, {\n                        point: this._initialCenter,\n                        zoom: this.zoom()\n                    });\n                },\n\n                _resize: function() {\n                    var viewport = this.viewport();\n                    if (this.canvas) {\n                        this.canvas.size(viewport);\n                    }\n\n                    if (this.scrollable && this.toolBar) {\n                        this.scrollable.height(viewport.height);\n                    }\n                },\n\n                _mouseover: function(e) {\n                    var node = e.target._kendoNode;\n                    if (node && node.srcElement._hover) {\n                        node.srcElement._hover(true, node.srcElement);\n                    }\n                },\n\n                _mouseout: function(e) {\n                    var node = e.target._kendoNode;\n                    if (node && node.srcElement._hover) {\n                        node.srcElement._hover(false, node.srcElement);\n                    }\n                },\n\n                _initTheme: function() {\n                    var that = this;\n                    var themeName = ((that.options || {}).theme || \"\").toLowerCase();\n                    var themes = dataviz.ui.themes || {};\n                    var themeOptions;\n\n                    if (dataviz.SASS_THEMES.indexOf(themeName) != -1) {\n                        themeOptions = dataviz.diagramTheme(that.element[0]);\n                    }\n                    else {\n                        themeOptions = (themes[themeName] || {}).diagram;\n                    }\n\n                    that.options = deepExtend({}, themeOptions, that.options);\n                    if (that.options.editable === true) {\n                        deepExtend(that.options, {\n                            editable: (themeOptions || {}).editable\n                        });\n                    }\n                },\n\n                _createOptionElements: function() {\n                    var options = this.options;\n                    var shapesLength = options.shapes.length;\n\n                    if (shapesLength) {\n                        this._createShapes();\n                    }\n\n                    if (options.connections.length) {\n                        this._createConnections();\n                    }\n\n                    if (shapesLength && options.layout) {\n                        this.layout(options.layout);\n                    }\n                },\n\n                _createShapes: function() {\n                    var that = this,\n                        options = that.options,\n                        shapes = options.shapes,\n                        shape, i;\n\n                    for (i = 0; i < shapes.length; i++) {\n                        shape = shapes[i];\n                        that.addShape(shape);\n                    }\n                },\n\n                _createConnections: function() {\n                    var diagram = this,\n                        options = diagram.options,\n                        defaults = options.connectionDefaults,\n                        connections = options.connections,\n                        conn, source, target, i;\n\n                    for (i = 0; i < connections.length; i++) {\n                        conn = connections[i];\n                        source = diagram._findConnectionTarget(conn.from);\n                        target = diagram._findConnectionTarget(conn.to);\n\n                        diagram.connect(source, target, deepExtend({}, defaults, conn));\n                    }\n                },\n\n                _findConnectionTarget: function(options) {\n                    options = options || {};\n                    var diagram = this;\n                    var shapeId = isString(options) ? options : options.shapeId || options.id;\n                    var target;\n                    if (shapeId) {\n                        target = diagram.getShapeById(shapeId);\n                        if (options.connector) {\n                            target = target.getConnector(options.connector);\n                        }\n                    } else {\n                        target = new Point(options.x || 0, options.y || 0);\n                    }\n\n                    return target;\n                },\n\n                destroy: function() {\n                    var that = this;\n                    Widget.fn.destroy.call(that);\n\n                    if (this._userEvents) {\n                        this._userEvents.destroy();\n                    }\n\n                    kendo.unbindResize(that._resizeHandler);\n\n                    that.clear();\n                    that.element.off(NS);\n                    that.scroller.wrapper.off(NS);\n                    that.canvas.destroy(true);\n                    that.canvas = undefined$1;\n\n                    that._destroyEditor();\n                    that.destroyScroller();\n                    that._destroyGlobalToolBar();\n                    that._destroyToolBar();\n                },\n\n                destroyScroller: function() {\n                    var scroller = this.scroller;\n\n                    if (!scroller) {\n                        return;\n                    }\n\n                    scroller.destroy();\n                    scroller.element.remove();\n                    this.scroller = null;\n                },\n\n                save: function() {\n                    var json = {\n                        shapes: [],\n                        connections: []\n                    };\n                    var i, connection, shape;\n\n                    for (i = 0; i < this.shapes.length; i++) {\n                        shape = this.shapes[i];\n                        if (shape.options.serializable) {\n                            json.shapes.push(shape.options);\n                        }\n                    }\n\n                    for (i = 0; i < this.connections.length; i++) {\n                        connection = this.connections[i];\n\n                        json.connections.push(deepExtend({}, connection.options, connection.toJSON()));\n                    }\n\n                    return json;\n                },\n\n                focus: function() {\n                    if (!this.element.is(kendo._activeElement())) {\n                        var element = this.element,\n                            scrollContainer = element[0],\n                            containers = [],\n                            offsets = [],\n                            documentElement = document.documentElement,\n                            i;\n\n                        do {\n                            scrollContainer = scrollContainer.parentNode;\n\n                            if (scrollContainer.scrollHeight > scrollContainer.clientHeight) {\n                                containers.push(scrollContainer);\n                                offsets.push(scrollContainer.scrollTop);\n                            }\n                        } while (scrollContainer != documentElement);\n\n                        element.trigger(\"focus\");\n\n                        for (i = 0; i < containers.length; i++) {\n                            containers[i].scrollTop = offsets[i];\n                        }\n                        return true;\n                    }\n                },\n\n                load: function(options) {\n                    this.clear();\n\n                    this.setOptions(options);\n                    this._createShapes();\n                    this._createConnections();\n                },\n\n                setOptions: function(options) {\n                    deepExtend(this.options, options);\n                },\n\n                clear: function() {\n                    var that = this;\n\n                    that.select(false);\n                    that.mainLayer.clear();\n                    that._shapesQuadTree.clear();\n                    that._initialize();\n                },\n                /**\n                 * Connects two items.\n                 * @param source Shape, Connector, Point.\n                 * @param target Shape, Connector, Point.\n                 * @param options Connection options that will be passed to the newly created connection.\n                 * @returns The newly created connection.\n                 */\n                connect: function(source, target, options) {\n                    var connection;\n                    if (this.connectionsDataSource && this._isEditable) {\n                        var dataItem = this.connectionsDataSource.add({});\n                        connection = this._connectionsDataMap[dataItem.uid];\n                        connection.source(source);\n                        connection.target(target);\n                        connection.redraw(options);\n                        connection.updateModel();\n                    } else {\n                        connection = new Connection(source, target,\n                            deepExtend({ }, this.options.connectionDefaults, options));\n\n                        this.addConnection(connection);\n                    }\n\n                    return connection;\n                },\n                /**\n                 * Determines whether the the two items are connected.\n                 * @param source Shape, Connector, Point.\n                 * @param target Shape, Connector, Point.\n                 * @returns true if the two items are connected.\n                 */\n                connected: function(source, target) {\n                    for (var i = 0; i < this.connections.length; i++) {\n                        var c = this.connections[i];\n                        if (c.from == source && c.to == target) {\n                            return true;\n                        }\n                    }\n\n                    return false;\n                },\n                /**\n                 * Adds connection to the diagram.\n                 * @param connection Connection.\n                 * @param undoable Boolean.\n                 * @returns The newly created connection.\n                 */\n                addConnection: function(connection, undoable) {\n                    if (undoable !== false) {\n                        this.undoRedoService.add(\n                            new diagram.AddConnectionUnit(connection, this), false);\n                    }\n\n                    connection.diagram = this;\n                    connection._setOptionsFromModel();\n                    connection.refresh();\n                    this.mainLayer.append(connection.visual);\n                    this.connections.push(connection);\n\n                    this.trigger(CHANGE, {\n                        added: [connection],\n                        removed: []\n                    });\n\n                    return connection;\n                },\n\n                _addConnection: function(connection, undoable) {\n                    var connectionsDataSource = this.connectionsDataSource;\n                    var dataItem;\n                    if (connectionsDataSource && this._isEditable) {\n                        dataItem = createModel(connectionsDataSource, cloneDataItem(connection.dataItem));\n                        connection.dataItem = dataItem;\n                        connection.updateModel();\n\n                        if (!this.trigger(\"add\", { connection: connection })) {\n                            this._connectionsDataMap[dataItem.uid] = connection;\n\n                            connectionsDataSource.add(dataItem);\n                            this.addConnection(connection, undoable);\n                            connection._updateConnectors();\n\n                            return connection;\n                        }\n                    } else if (!this.trigger(\"add\", { connection: connection })) {\n                        this.addConnection(connection, undoable);\n                        connection._updateConnectors();\n                        return connection;\n                    }\n                },\n\n                /**\n                 * Adds shape to the diagram.\n                 * @param item Shape, Point. If point is passed it will be created new Shape and positioned at that point.\n                 * @param options. The options to be passed to the newly created Shape.\n                 * @returns The newly created shape.\n                 */\n                addShape: function(item, undoable) {\n                    var shape,\n                        shapeDefaults = this.options.shapeDefaults;\n\n                    if (item instanceof Shape) {\n                        shape = item;\n                        this._parseBounds(shape.bounds());\n                    } else if (!(item instanceof kendo.Class)) {\n                        shapeDefaults = deepExtend({}, shapeDefaults, item || {});\n                        shape = new Shape(shapeDefaults, this);\n                        this._parseBounds(shape.bounds());\n                    } else {\n                        return;\n                    }\n\n                    if (undoable !== false) {\n                        this.undoRedoService.add(new diagram.AddShapeUnit(shape, this), false);\n                    }\n\n                    this.shapes.push(shape);\n                    if (shape.diagram !== this) {\n                        this._shapesQuadTree.insert(shape);\n                        shape.diagram = this;\n                    }\n                    this.mainLayer.append(shape.visual);\n\n                    this.trigger(CHANGE, {\n                        added: [shape],\n                        removed: []\n                    });\n\n                    return shape;\n                },\n\n                _addShape: function(shape, undoable) {\n                    var that = this;\n                    var dataSource = that.dataSource;\n                    var dataItem;\n                    if (dataSource && this._isEditable) {\n                        dataItem = createModel(dataSource, cloneDataItem(shape.dataItem));\n                        shape.dataItem = dataItem;\n                        shape.updateModel();\n\n                        if (!this.trigger(\"add\", { shape: shape })) {\n                            this.dataSource.add(dataItem);\n                            var inactiveItem = this._inactiveShapeItems.getByUid(dataItem.uid);\n                            inactiveItem.element = shape;\n                            inactiveItem.undoable = undoable;\n                            return shape;\n                        }\n                    } else if (!this.trigger(\"add\", { shape: shape })) {\n                        return this.addShape(shape, undoable);\n                    }\n                },\n\n                _parseBounds: function(bounds) {\n                    bounds.x = typeof(bounds.x) == \"string\" ? parseFloat(bounds.x) : bounds.x;\n                    bounds.y = typeof(bounds.y) == \"string\" ? parseFloat(bounds.y) : bounds.y;\n                },\n                /**\n                 * Removes items (or single item) from the diagram.\n                 * @param items DiagramElement, Array of Items.\n                 * @param undoable.\n                 */\n\n               remove: function(items, undoable) {\n                    items = isArray(items) ? items.slice(0) : [items];\n                    var elements = splitDiagramElements(items);\n                    var shapes = elements.shapes;\n                    var connections = elements.connections;\n                    var i;\n\n                    if (!defined(undoable)) {\n                        undoable = true;\n                    }\n\n                    if (undoable) {\n                        this.undoRedoService.begin();\n                    }\n\n                    this._suspendModelRefresh();\n                    for (i = shapes.length - 1; i >= 0; i--) {\n                       this._removeItem(shapes[i], undoable, connections);\n                    }\n\n                    for (i = connections.length - 1; i >= 0; i--) {\n                        this._removeItem(connections[i], undoable);\n                    }\n\n                    this._resumeModelRefresh();\n\n                    if (undoable) {\n                        this.undoRedoService.commit(false);\n                    }\n\n                    this.trigger(CHANGE, {\n                        added: [],\n                        removed: items\n                    });\n                },\n\n                _removeShapeDataItem: function(item) {\n                    if (this._isEditable) {\n                        this.dataSource.remove(item.dataItem);\n                        delete this._dataMap[item.dataItem.id];\n                    }\n                },\n\n                _removeConnectionDataItem: function(item) {\n                    if (this._isEditable) {\n                        this.connectionsDataSource.remove(item.dataItem);\n                        delete this._connectionsDataMap[item.dataItem.uid];\n                    }\n                },\n\n                _triggerRemove: function(items) {\n                    var toRemove = [];\n                    var item, args, editable;\n\n                    for (var idx = 0; idx < items.length; idx++) {\n                        item = items[idx];\n                        editable = item.options.editable;\n                        if (item instanceof Shape) {\n                            args = { shape: item };\n                        } else {\n                            args = { connection: item };\n                        }\n                        if (editable && editable.remove !== false && !this.trigger(\"remove\", args)) {\n                            toRemove.push(item);\n                        }\n                    }\n                    return toRemove;\n                },\n\n                /**\n                 * Executes the next undoable action on top of the undo stack if any.\n                 */\n                undo: function() {\n                    this.undoRedoService.undo();\n                },\n                /**\n                 * Executes the previous undoable action on top of the redo stack if any.\n                 */\n                redo: function() {\n                    this.undoRedoService.redo();\n                },\n                /**\n                 * Selects items on the basis of the given input or returns the current selection if none.\n                 * @param itemsOrRect DiagramElement, Array of elements, \"All\", false or Rect. A value 'false' will deselect everything.\n                 * @param options\n                 * @returns {Array}\n                 */\n                select: function(item, options) {\n                    if (isDefined(item)) {\n                        options = deepExtend({ addToSelection: false }, options);\n\n                        var addToSelection = options.addToSelection,\n                            items = [],\n                            selected = [],\n                            i, element;\n\n                        if (!addToSelection) {\n                            this.deselect();\n                        }\n\n                        this._internalSelection = true;\n\n                        if (item instanceof Array) {\n                            items = item;\n                        } else if (item instanceof DiagramElement) {\n                            items = [ item ];\n                        }\n\n                        for (i = 0; i < items.length; i++) {\n                            element = items[i];\n                            if (element.select(true)) {\n                                selected.push(element);\n                            }\n                        }\n\n                        this._selectionChanged(selected, []);\n\n                        this._internalSelection = false;\n                    } else {\n                        return this._selectedItems;\n                    }\n                },\n\n                selectAll: function() {\n                    this.select(this.shapes.concat(this.connections));\n                },\n\n                selectArea: function(rect) {\n                    var i, items, item;\n                    this._internalSelection = true;\n                    var selected = [];\n                    if (rect instanceof Rect) {\n                        items = this.shapes.concat(this.connections);\n                        for (i = 0; i < items.length; i++) {\n                            item = items[i];\n                            if ((!rect || item._hitTest(rect)) && item.options.enable) {\n                                if (item.select(true)) {\n                                    selected.push(item);\n                                }\n                            }\n                        }\n                    }\n\n                    this._selectionChanged(selected, []);\n                    this._internalSelection = false;\n                },\n\n                deselect: function(item) {\n                    this._internalSelection = true;\n                    var deselected = [],\n                        items = [],\n                        element, i;\n\n                    if (item instanceof Array) {\n                        items = item;\n                    } else if (item instanceof DiagramElement) {\n                        items.push(item);\n                    } else if (!isDefined(item)) {\n                        items = this._selectedItems.slice(0);\n                    }\n\n                    for (i = 0; i < items.length; i++) {\n                        element = items[i];\n                        if (element.select(false)) {\n                            deselected.push(element);\n                        }\n                    }\n\n                    this._selectionChanged([], deselected);\n                    this._internalSelection = false;\n                },\n                /**\n                 * Brings to front the passed items.\n                 * @param items DiagramElement, Array of Items.\n                 * @param undoable. By default the action is undoable.\n                 */\n                toFront: function(items, undoable) {\n                    if (!items) {\n                        items = this._selectedItems.slice();\n                    }\n\n                    var result = this._getDiagramItems(items), indices;\n                    if (!defined(undoable) || undoable) {\n                        indices = indicesOfItems(this.mainLayer, result.visuals);\n                        var unit = new ToFrontUnit(this, items, indices);\n                        this.undoRedoService.add(unit);\n                    } else {\n                        this.mainLayer.toFront(result.visuals);\n                        this._fixOrdering(result, true);\n                    }\n                },\n                /**\n                 * Sends to back the passed items.\n                 * @param items DiagramElement, Array of Items.\n                 * @param undoable. By default the action is undoable.\n                 */\n                toBack: function(items, undoable) {\n                    if (!items) {\n                        items = this._selectedItems.slice();\n                    }\n\n                    var result = this._getDiagramItems(items), indices;\n                    if (!defined(undoable) || undoable) {\n                        indices = indicesOfItems(this.mainLayer, result.visuals);\n                        var unit = new ToBackUnit(this, items, indices);\n                        this.undoRedoService.add(unit);\n                    } else {\n                        this.mainLayer.toBack(result.visuals);\n                        this._fixOrdering(result, false);\n                    }\n                },\n                /**\n                 * Bring into view the passed item(s) or rectangle.\n                 * @param items DiagramElement, Array of Items, Rect.\n                 * @param options. align - controls the position of the calculated rectangle relative to the viewport.\n                 * \"Center middle\" will position the items in the center. animate - controls if the pan should be animated.\n                 */\n                bringIntoView: function(item, options) { // jQuery|Item|Array|Rect\n                    var viewport = this.viewport();\n                    var aligner = new diagram.RectAlign(viewport);\n                    var current, rect, original, newPan;\n\n                    if (viewport.width === 0 || viewport.height === 0) {\n                        return;\n                    }\n\n                    options = deepExtend({ animate: false, align: \"center middle\" }, options);\n                    if (options.align == \"none\") {\n                        options.align = \"center middle\";\n                    }\n\n                    if (item instanceof DiagramElement) {\n                        rect = item.bounds(TRANSFORMED);\n                    } else if (isArray(item)) {\n                        rect = this.boundingBox(item);\n                    } else if (item instanceof Rect) {\n                        rect = item.clone();\n                    }\n\n                    original = rect.clone();\n\n                    rect.zoom(this._zoom);\n\n                    if (rect.width > viewport.width || rect.height > viewport.height) {\n                        this._zoom = this._getValidZoom(math.min(viewport.width / original.width, viewport.height / original.height));\n                        rect = original.clone().zoom(this._zoom);\n                    }\n\n                    this._zoomMainLayer();\n\n                    current = rect.clone();\n                    aligner.align(rect, options.align);\n\n                    newPan = rect.topLeft().minus(current.topLeft());\n                    this.pan(newPan.times(-1), options.animate);\n                },\n\n                alignShapes: function(direction) {\n                    if (isUndefined(direction)) {\n                        direction = \"Left\";\n                    }\n                    var items = this.select(),\n                        val,\n                        item,\n                        i;\n\n                    if (items.length === 0) {\n                        return;\n                    }\n\n                    switch (direction.toLowerCase()) {\n                        case \"left\":\n                        case \"top\":\n                            val = MAX_VALUE;\n                            break;\n                        case \"right\":\n                        case \"bottom\":\n                            val = MIN_VALUE;\n                            break;\n                    }\n\n                    for (i = 0; i < items.length; i++) {\n                        item = items[i];\n                        if (item instanceof Shape) {\n                            switch (direction.toLowerCase()) {\n                                case \"left\":\n                                    val = math.min(val, item.options.x);\n                                    break;\n                                case \"top\":\n                                    val = math.min(val, item.options.y);\n                                    break;\n                                case \"right\":\n                                    val = math.max(val, item.options.x);\n                                    break;\n                                case \"bottom\":\n                                    val = math.max(val, item.options.y);\n                                    break;\n                            }\n                        }\n                    }\n                    var undoStates = [];\n                    var shapes = [];\n                    for (i = 0; i < items.length; i++) {\n                        item = items[i];\n                        if (item instanceof Shape) {\n                            shapes.push(item);\n                            undoStates.push(item.bounds());\n                            switch (direction.toLowerCase()) {\n                                case \"left\":\n                                case \"right\":\n                                    item.position(new Point(val, item.options.y));\n                                    break;\n                                case \"top\":\n                                case \"bottom\":\n                                    item.position(new Point(item.options.x, val));\n                                    break;\n                            }\n                        }\n                    }\n                    var unit = new diagram.TransformUnit(shapes, undoStates);\n                    this.undoRedoService.add(unit, false);\n                },\n\n                zoom: function(zoom, options) {\n                    if (zoom) {\n                        var staticPoint = options ? options.point : new diagram.Point(0, 0);\n                        // var meta = options ? options.meta : 0;\n                        zoom = this._zoom = this._getValidZoom(zoom);\n\n                        if (!isUndefined(staticPoint)) {//Viewpoint vector is constant\n                            staticPoint = new diagram.Point(math.round(staticPoint.x), math.round(staticPoint.y));\n                            var zoomedPoint = staticPoint.times(zoom);\n                            var viewportVector = this.modelToView(staticPoint);\n                            var raw = viewportVector.minus(zoomedPoint);//pan + zoomed point = viewpoint vector\n                            this._storePan(new diagram.Point(math.round(raw.x), math.round(raw.y)));\n                        }\n\n                        if (options) {\n                            options.zoom = zoom;\n                        }\n\n                        this._panTransform();\n\n                        this.canvas.surface.hideTooltip();\n\n                        this._updateAdorners();\n                    }\n\n                    return this._zoom;\n                },\n\n                _getPan: function(pan) {\n                    var canvas = this.canvas;\n                    if (!canvas.translate) {\n                        pan = pan.plus(this._pan);\n                    }\n                    return pan;\n                },\n\n                pan: function(pan, animate) {\n                    if (pan instanceof Point) {\n                        var that = this;\n                        var scroller = that.scroller;\n                        pan = that._getPan(pan);\n                        pan = pan.times(-1);\n\n                        if (animate) {\n                            scroller.animatedScrollTo(pan.x, pan.y, function() {\n                                that._updateAdorners();\n                            });\n                        } else {\n                            scroller.scrollTo(pan.x, pan.y);\n                            that._updateAdorners();\n                        }\n                    } else {\n                        return this._pan.times(-1);\n                    }\n                },\n\n                viewport: function() {\n                    var element = this.element;\n                    var width = element.width();\n                    var height = element.height();\n\n                    if (this.toolBar) {\n                        height -= outerHeight(this.toolBar.element);\n                    }\n\n                    return new Rect(0, 0, width, height);\n                },\n                copy: function() {\n                    if (this.options.copy.enabled) {\n                        this._clipboard = [];\n                        this._copyOffset = 1;\n                        for (var i = 0; i < this._selectedItems.length; i++) {\n                            var item = this._selectedItems[i];\n                            this._clipboard.push(item);\n                        }\n                    }\n                },\n                cut: function() {\n                    if (this.options.copy.enabled) {\n                        this._clipboard = [];\n                        this._copyOffset = 0;\n                        for (var i = 0; i < this._selectedItems.length; i++) {\n                            var item = this._selectedItems[i];\n                            this._clipboard.push(item);\n                        }\n                        this.remove(this._clipboard, true);\n                    }\n                },\n\n                paste: function() {\n                    if (this._clipboard.length > 0) {\n                        var item, copied, i;\n                        var mapping = {};\n                        var elements = splitDiagramElements(this._clipboard);\n                        var connections = elements.connections;\n                        var shapes = elements.shapes;\n                        var offset = {\n                            x: this._copyOffset * this.options.copy.offsetX,\n                            y: this._copyOffset * this.options.copy.offsetY\n                        };\n                        this.deselect();\n                        // first the shapes\n                        for (i = 0; i < shapes.length; i++) {\n                            item = shapes[i];\n                            copied = item.clone();\n                            mapping[item.id] = copied;\n                            copied.position(new Point(item.options.x + offset.x, item.options.y + offset.y));\n                            copied.diagram = this;\n                            copied = this._addShape(copied);\n                            if (copied) {\n                                copied.select();\n                            }\n                        }\n                        // then the connections\n                        for (i = 0; i < connections.length; i++) {\n                            item = connections[i];\n                            copied = this._addConnection(item.clone());\n                            if (copied) {\n                                this._updateCopiedConnection(copied, item, \"source\", mapping, offset);\n                                this._updateCopiedConnection(copied, item, \"target\", mapping, offset);\n\n                                copied.select(true);\n                                copied.updateModel();\n                            }\n                        }\n\n                        this._syncChanges();\n\n                        this._copyOffset += 1;\n                    }\n                },\n\n                _updateCopiedConnection: function(connection, sourceConnection, connectorName, mapping, offset) {\n                    var onActivate, inactiveItem, targetShape;\n                    var target = sourceConnection[connectorName]();\n                    var diagram = this;\n                    if (target instanceof Connector && mapping[target.shape.id]) {\n                        targetShape = mapping[target.shape.id];\n                        if (diagram.getShapeById(targetShape.id)) {\n                            connection[connectorName](targetShape.getConnector(target.options.name));\n                        } else {\n                            inactiveItem = diagram._inactiveShapeItems.getByUid(targetShape.dataItem.uid);\n                            if (inactiveItem) {\n                                onActivate = function(item) {\n                                    targetShape = diagram._dataMap[item.id];\n                                    connection[connectorName](targetShape.getConnector(target.options.name));\n                                    connection.updateModel();\n                                };\n                                diagram._deferredConnectionUpdates.push(inactiveItem.onActivate(onActivate));\n                            }\n                        }\n                    } else {\n                        connection[connectorName](new Point(sourceConnection[connectorName + \"Point\"]().x + offset.x, sourceConnection[connectorName + \"Point\"]().y + offset.y));\n                    }\n                },\n                /**\n                 * Gets the bounding rectangle of the given items.\n                 * @param items DiagramElement, Array of elements.\n                 * @param origin Boolean. Pass 'true' if you need to get the bounding box of the shapes without their rotation offset.\n                 * @returns {Rect}\n                 */\n                boundingBox: function(items, origin) {\n                    var rect = Rect.empty(), temp,\n                        di = isDefined(items) ? this._getDiagramItems(items) : { shapes: this.shapes };\n                    if (di.shapes.length > 0) {\n                        var item = di.shapes[0];\n                        rect = item.bounds(ROTATED);\n                        for (var i = 1; i < di.shapes.length; i++) {\n                            item = di.shapes[i];\n                            temp = item.bounds(ROTATED);\n                            if (origin === true) {\n                                temp.x -= item._rotationOffset.x;\n                                temp.y -= item._rotationOffset.y;\n                            }\n                            rect = rect.union(temp);\n                        }\n                    }\n                    return rect;\n                },\n\n                _containerOffset: function() {\n                    var containerOffset = this.element.offset();\n                    if (this.toolBar) {\n                        containerOffset.top += outerHeight(this.toolBar.element);\n                    }\n                    return containerOffset;\n                },\n\n                documentToView: function(point) {\n                    var containerOffset = this._containerOffset();\n\n                    return new Point(point.x - containerOffset.left, point.y - containerOffset.top);\n                },\n                viewToDocument: function(point) {\n                    var containerOffset = this._containerOffset();\n\n                    return new Point(point.x + containerOffset.left, point.y + containerOffset.top);\n                },\n                viewToModel: function(point) {\n                    return this._transformWithMatrix(point, this._matrixInvert);\n                },\n                modelToView: function(point) {\n                    return this._transformWithMatrix(point, this._matrix);\n                },\n                modelToLayer: function(point) {\n                    return this._transformWithMatrix(point, this._layerMatrix);\n                },\n                layerToModel: function(point) {\n                    return this._transformWithMatrix(point, this._layerMatrixInvert);\n                },\n                documentToModel: function(point) {\n                    var viewPoint = this.documentToView(point);\n                    if (!this.canvas.translate) {\n                        viewPoint.x = viewPoint.x + this.scroller.scrollLeft;\n                        viewPoint.y = viewPoint.y + this.scroller.scrollTop;\n                    }\n                    return this.viewToModel(viewPoint);\n                },\n                modelToDocument: function(point) {\n                    return this.viewToDocument(this.modelToView(point));\n                },\n                _transformWithMatrix: function(point, matrix) {\n                    var result = point;\n                    if (point instanceof Point) {\n                        if (matrix) {\n                            result = matrix.apply(point);\n                        }\n                    }\n                    else {\n                        var tl = this._transformWithMatrix(point.topLeft(), matrix),\n                            br = this._transformWithMatrix(point.bottomRight(), matrix);\n                        result = Rect.fromPoints(tl, br);\n                    }\n                    return result;\n                },\n\n                setDataSource: function(dataSource) {\n                    this.options.dataSource = dataSource;\n                    this._dataSource();\n                    if (this.options.autoBind) {\n                        this.dataSource.fetch();\n                    }\n                },\n\n                setConnectionsDataSource: function(dataSource) {\n                    this.options.connectionsDataSource = dataSource;\n                    this._connectionDataSource();\n                    if (this.options.autoBind) {\n                        this.connectionsDataSource.fetch();\n                    }\n                },\n\n                /**\n                 * Performs a diagram layout of the given type.\n                 * @param layoutType The layout algorithm to be applied (TreeLayout, LayeredLayout, SpringLayout).\n                 * @param options Layout-specific options.\n                 */\n                layout: function(options) {\n                    this._layouting = true;\n                    // TODO: raise layout event?\n                    var type;\n                    if (isUndefined(options)) {\n                        options = this.options.layout;\n                    }\n                    if (isUndefined(options) || isUndefined(options.type)) {\n                        type = \"Tree\";\n                    }\n                    else {\n                        type = options.type;\n                    }\n                    var l;\n                    switch (type.toLowerCase()) {\n                        case \"tree\":\n                            l = new diagram.TreeLayout(this);\n                            break;\n\n                        case \"layered\":\n                            l = new diagram.LayeredLayout(this);\n                            break;\n\n                        case \"forcedirected\":\n                        case \"force\":\n                        case \"spring\":\n                        case \"springembedder\":\n                            l = new diagram.SpringLayout(this);\n                            break;\n                        default:\n                            throw \"Layout algorithm '\" + type + \"' is not supported.\";\n                    }\n                    var initialState = new diagram.LayoutState(this);\n                    var finalState = l.layout(options);\n                    if (finalState) {\n                        var unit = new diagram.LayoutUndoUnit(initialState, finalState, options ? options.animate : null);\n                        this.undoRedoService.add(unit);\n                    }\n                    this._layouting = false;\n                    this._redrawConnections();\n                },\n                /**\n                 * Gets a shape on the basis of its identifier.\n                 * @param id (string) the identifier of a shape.\n                 * @returns {Shape}\n                 */\n                getShapeById: function(id) {\n                    var found;\n                    found = Utils.first(this.shapes, function(s) {\n                        return s.visual.id === id;\n                    });\n                    if (found) {\n                        return found;\n                    }\n                    found = Utils.first(this.connections, function(c) {\n                        return c.visual.id === id;\n                    });\n                    return found;\n                },\n\n                getShapeByModelId: function(id) {\n                    var shape;\n                    if (this._isEditable) {\n                        shape = this._dataMap[id];\n                    } else {\n                        shape = Utils.first(this.shapes, function(shape) {\n                            return (shape.dataItem || {}).id === id;\n                        });\n                    }\n                    return shape;\n                },\n\n                getShapeByModelUid: function(uid) {\n                    var shape;\n                    if (this._isEditable) {\n                        shape = Utils.first(this.shapes, function(shape) {\n                            return (shape.dataItem || {}).uid === uid;\n                        });\n                    } else {\n                        shape = this._dataMap[uid];\n                    }\n                    return shape;\n                },\n\n                getConnectionByModelId: function(id) {\n                    var connection;\n                    if (this.connectionsDataSource) {\n                        connection = Utils.first(this.connections, function(connection) {\n                            return (connection.dataItem || {}).id === id;\n                        });\n                    }\n                    return connection;\n                },\n\n                getConnectionByModelUid: function(uid) {\n                    var connection;\n                    if (this.connectionsDataSource) {\n                        connection = this._connectionsDataMap[uid];\n                    }\n                    return connection;\n                },\n\n                _extendLayoutOptions: function(options) {\n                    if (options.layout) {\n                        options.layout = deepExtend({}, diagram.LayoutBase.fn.defaultOptions || {}, options.layout);\n                    }\n                },\n\n                _selectionChanged: function(selected, deselected) {\n                    if (selected.length || deselected.length) {\n                        this.trigger(SELECT, { selected: selected, deselected: deselected });\n                    }\n                },\n                _getValidZoom: function(zoom) {\n                    return math.min(math.max(zoom, this.options.zoomMin), this.options.zoomMax);\n                },\n                _panTransform: function(pos) {\n                    var diagram = this,\n                        pan = pos || diagram._pan;\n\n                    if (diagram.canvas.translate) {\n                        diagram.scroller.scrollTo(pan.x, pan.y);\n                        diagram._zoomMainLayer();\n                    } else {\n                        diagram._storePan(pan);\n                        diagram._transformMainLayer();\n                    }\n                },\n\n                _finishPan: function() {\n                    this.trigger(PAN, { total: this._pan, delta: Number.NaN });\n                },\n                _storePan: function(pan) {\n                    this._pan = pan;\n                    this._storeViewMatrix();\n                },\n                _zoomMainLayer: function() {\n                    var zoom = this._zoom;\n\n                    var transform = new CompositeTransform(0, 0, zoom, zoom);\n                    transform.render(this.mainLayer);\n                    this._storeLayerMatrix(transform);\n                    this._storeViewMatrix();\n                },\n                _transformMainLayer: function() {\n                    var pan = this._pan,\n                        zoom = this._zoom;\n\n                    var transform = new CompositeTransform(pan.x, pan.y, zoom, zoom);\n                    transform.render(this.mainLayer);\n                    this._storeLayerMatrix(transform);\n                    this._storeViewMatrix();\n                },\n                _storeLayerMatrix: function(canvasTransform) {\n                    this._layerMatrix = canvasTransform.toMatrix();\n                    this._layerMatrixInvert = canvasTransform.invert().toMatrix();\n                },\n                _storeViewMatrix: function() {\n                    var pan = this._pan,\n                        zoom = this._zoom;\n\n                    var transform = new CompositeTransform(pan.x, pan.y, zoom, zoom);\n                    this._matrix = transform.toMatrix();\n                    this._matrixInvert = transform.invert().toMatrix();\n                },\n                _toIndex: function(items, indices) {\n                    var result = this._getDiagramItems(items);\n                    this.mainLayer.toIndex(result.visuals, indices);\n                    this._fixOrdering(result, false);\n                },\n                _fixOrdering: function(result, toFront) {\n                    var shapePos = toFront ? this.shapes.length - 1 : 0,\n                        conPos = toFront ? this.connections.length - 1 : 0,\n                        i, item;\n                    for (i = 0; i < result.shapes.length; i++) {\n                        item = result.shapes[i];\n                        Utils.remove(this.shapes, item);\n                        Utils.insert(this.shapes, item, shapePos);\n                    }\n                    for (i = 0; i < result.cons.length; i++) {\n                        item = result.cons[i];\n                        Utils.remove(this.connections, item);\n                        Utils.insert(this.connections, item, conPos);\n                    }\n                },\n                _getDiagramItems: function(items) {\n                    var i, result = {}, args = items;\n                    result.visuals = [];\n                    result.shapes = [];\n                    result.cons = [];\n\n                    if (!items) {\n                        args = this._selectedItems.slice();\n                    } else if (!isArray(items)) {\n                        args = [items];\n                    }\n\n                    for (i = 0; i < args.length; i++) {\n                        var item = args[i];\n                        if (item instanceof Shape) {\n                            result.shapes.push(item);\n                            result.visuals.push(item.visual);\n                        } else if (item instanceof Connection) {\n                            result.cons.push(item);\n                            result.visuals.push(item.visual);\n                        }\n                    }\n\n                    return result;\n                },\n\n                _removeItem: function(item, undoable, removedConnections) {\n                    item.select(false);\n                    if (item instanceof Shape) {\n                        this._removeShapeDataItem(item);\n                        this._removeShape(item, undoable, removedConnections);\n                    } else if (item instanceof Connection) {\n                        this._removeConnectionDataItem(item);\n                        this._removeConnection(item, undoable);\n                    }\n\n                    this.mainLayer.remove(item.visual);\n                },\n\n                _removeShape: function(shape, undoable, removedConnections) {\n                    var i, connection, connector,\n                        sources = [], targets = [];\n                    this.toolService._removeHover();\n\n                    if (undoable) {\n                        this.undoRedoService.addCompositeItem(new DeleteShapeUnit(shape));\n                    }\n                    Utils.remove(this.shapes, shape);\n                    this._shapesQuadTree.remove(shape);\n\n                    for (i = 0; i < shape.connectors.length; i++) {\n                        connector = shape.connectors[i];\n                        for (var j = 0; j < connector.connections.length; j++) {\n                            connection = connector.connections[j];\n                            if (!removedConnections || !dataviz.inArray(connection, removedConnections)) {\n                                if (connection.sourceConnector == connector) {\n                                    sources.push(connection);\n                                } else if (connection.targetConnector == connector) {\n                                    targets.push(connection);\n                                }\n                            }\n                        }\n                    }\n\n                    for (i = 0; i < sources.length; i++) {\n                        sources[i].source(null, undoable);\n                        sources[i].updateModel();\n                    }\n                    for (i = 0; i < targets.length; i++) {\n                        targets[i].target(null, undoable);\n                        targets[i].updateModel();\n                    }\n                },\n\n                _removeConnection: function(connection, undoable) {\n                    if (connection.sourceConnector) {\n                        Utils.remove(connection.sourceConnector.connections, connection);\n                    }\n                    if (connection.targetConnector) {\n                        Utils.remove(connection.targetConnector.connections, connection);\n                    }\n                    if (undoable) {\n                        this.undoRedoService.addCompositeItem(new DeleteConnectionUnit(connection));\n                    }\n\n                    Utils.remove(this.connections, connection);\n                },\n\n                _removeDataItems: function(items, recursive) {\n                    var item, children, shape, idx;\n                    items = isArray(items) ? items : [items];\n\n                    while (items.length) {\n                        item = items.shift();\n                        shape = this._dataMap[item.uid];\n                        if (shape) {\n                            this._removeShapeConnections(shape);\n                            this._removeItem(shape, false);\n                            delete this._dataMap[item.uid];\n                            if (recursive && item.hasChildren && item.loaded()) {\n                                children = item.children.data();\n                                for (idx = 0; idx < children.length; idx++) {\n                                    items.push(children[idx]);\n                                }\n                            }\n                        }\n                    }\n                },\n\n                _removeShapeConnections: function(shape) {\n                    var connections = shape.connections();\n                    var idx;\n\n                    if (connections) {\n                        for (idx = 0; idx < connections.length; idx++) {\n                            this._removeItem(connections[idx], false);\n                        }\n                    }\n                },\n\n                _addDataItem: function(dataItem, undoable) {\n                    if (!defined(dataItem)) {\n                        return;\n                    }\n\n                    var shape = this._dataMap[dataItem.id];\n                    if (shape) {\n                        return shape;\n                    }\n\n                    var options = deepExtend({}, this.options.shapeDefaults);\n                    options.dataItem = dataItem;\n                    shape = new Shape(options, this);\n                    this.addShape(shape, undoable !== false);\n                    this._dataMap[dataItem.id] = shape;\n                    return shape;\n                },\n\n                _addDataItemByUid: function(dataItem) {\n                    if (!defined(dataItem)) {\n                        return;\n                    }\n\n                    var shape = this._dataMap[dataItem.uid];\n                    if (shape) {\n                        return shape;\n                    }\n\n                    var options = deepExtend({}, this.options.shapeDefaults);\n                    options.dataItem = dataItem;\n                    shape = new Shape(options, this);\n                    this.addShape(shape);\n                    this._dataMap[dataItem.uid] = shape;\n                    return shape;\n                },\n\n                _addDataItems: function(items, parent) {\n                    var item, idx, shape, parentShape, connection;\n                    for (idx = 0; idx < items.length; idx++) {\n                        item = items[idx];\n                        shape = this._addDataItemByUid(item);\n                        parentShape = this._addDataItemByUid(parent);\n                        if (parentShape && !this.connected(parentShape, shape)) { // check if connected to not duplicate connections.\n                            connection = this.connect(parentShape, shape);\n                        }\n                    }\n                },\n\n                _refreshSource: function(e) {\n                    var that = this,\n                        node = e.node,\n                        action = e.action,\n                        items = e.items,\n                        options = that.options,\n                        idx,\n                        dataBound;\n\n                    if (e.field) {\n                        for (idx = 0; idx < items.length; idx++) {\n                            if (this._dataMap[items[idx].uid]) {\n                                this._dataMap[items[idx].uid].redrawVisual();\n                            }\n                        }\n                        return;\n                    }\n\n                    if (action == \"remove\") {\n                        this._removeDataItems(e.items, true);\n                    } else {\n\n                        if ((!action || action === \"itemloaded\") && !this._bindingRoots) {\n                            this._bindingRoots = true;\n                            dataBound = true;\n                        }\n\n                        if (!action && !node) {\n                            that.clear();\n                        }\n\n                        this._addDataItems(items, node);\n\n                        for (idx = 0; idx < items.length; idx++) {\n                            items[idx].load();\n                        }\n                    }\n\n                    if (options.layout && (dataBound || action == \"remove\" || action == \"add\")) {\n                        that.layout(options.layout);\n                    }\n\n                    if (dataBound) {\n                        this.trigger(\"dataBound\");\n                        this._bindingRoots = false;\n                    }\n                },\n\n                _addItem: function(item) {\n                    if (item instanceof Shape) {\n                        this.addShape(item);\n                    } else if (item instanceof Connection) {\n                        this.addConnection(item);\n                    }\n                },\n\n                _createToolBar: function(preventClosing) {\n                    var diagram = this.toolService.diagram;\n\n                    if (!this.singleToolBar && diagram.select().length === 1) {\n                        var element = diagram.select()[0];\n                        if (element && element.options.editable !== false) {\n                            var editable = element.options.editable;\n                            var tools = editable.tools;\n                            if (this._isEditable && tools.length === 0) {\n                                if (element instanceof Shape) {\n                                    tools = [\"edit\", \"rotateClockwise\", \"rotateAnticlockwise\"];\n                                } else if (element instanceof Connection) {\n                                    tools = [\"edit\"];\n                                }\n\n                                if (editable && editable.remove !== false) {\n                                    tools.push(\"delete\");\n                                }\n                            }\n\n                            if (tools && tools.length) {\n                                var padding = 20;\n                                var point;\n                                this.singleToolBar = new DiagramToolBar(diagram, {\n                                    tools: tools,\n                                    click: this._toolBarClick.bind(this),\n                                    modal: true,\n                                    popupZIndex: parseInt(diagram.element.closest(\".k-window\").css(\"zIndex\"), 10) + 10\n                                });\n                                var popupWidth = outerWidth(this.singleToolBar._popup.element);\n                                var popupHeight = outerHeight(this.singleToolBar._popup.element);\n                                if (element instanceof Shape) {\n                                    var shapeBounds = this.modelToView(element.bounds(ROTATED));\n                                    point = new Point(shapeBounds.x, shapeBounds.y).minus(new Point(\n                                        (popupWidth - shapeBounds.width) / 2,\n                                        popupHeight + padding));\n                                } else if (element instanceof Connection) {\n                                    var connectionBounds = this.modelToView(element.bounds());\n\n                                    point = new Point(connectionBounds.x, connectionBounds.y)\n                                        .minus(new Point(\n                                            (popupWidth - connectionBounds.width - 20) / 2,\n                                            popupHeight + padding\n                                        ));\n                                }\n\n                                if (point) {\n                                    if (!this.canvas.translate) {\n                                        point = point.minus(new Point(this.scroller.scrollLeft, this.scroller.scrollTop));\n                                    }\n                                    point = this.viewToDocument(point);\n                                    point = new Point(math.max(point.x, 0), math.max(point.y, 0));\n                                    this.singleToolBar.showAt(point);\n                                    if (preventClosing) {\n                                        this.singleToolBar._popup.one(\"close\", preventDefault);\n                                    }\n                                } else {\n                                    this._destroyToolBar();\n                                }\n                            }\n                        }\n                    }\n                },\n\n                _toolBarClick: function(e) {\n                    this.trigger(\"toolBarClick\", e);\n                    this._destroyToolBar();\n                },\n\n                _normalizePointZoom: function(point) {\n                    return point.times(1 / this.zoom());\n                },\n\n                _initialize: function() {\n                    this.shapes = [];\n                    this._selectedItems = [];\n                    this.connections = [];\n                    this._dataMap = {};\n                    this._connectionsDataMap = {};\n                    this._inactiveShapeItems = new InactiveItemsCollection();\n                    this._deferredConnectionUpdates = [];\n                    this.undoRedoService = new UndoRedoService({\n                        undone: this._syncHandler,\n                        redone: this._syncHandler\n                    });\n                    this.id = diagram.randomId();\n                },\n\n                _fetchFreshData: function() {\n                    var that = this;\n                    that._dataSource();\n\n                    if (that._isEditable) {\n                        that._connectionDataSource();\n                    }\n\n                    if (that.options.autoBind) {\n                        if (that._isEditable) {\n                            this._loadingShapes = true;\n                            this._loadingConnections = true;\n                            that.dataSource.fetch();\n                            that.connectionsDataSource.fetch();\n                        } else {\n                            that.dataSource.fetch();\n                        }\n                    }\n                },\n\n                _dataSource: function() {\n                    if (defined(this.options.connectionsDataSource)) {\n                        this._isEditable = true;\n                        var dsOptions = this.options.dataSource || {};\n                        var ds = isArray(dsOptions) ? { data: dsOptions } : dsOptions;\n\n                        if (this.dataSource && this._shapesRefreshHandler) {\n                            this.dataSource\n                                .unbind(\"change\", this._shapesRefreshHandler)\n                                .unbind(\"requestStart\", this._shapesRequestStartHandler)\n                                .unbind(\"error\", this._shapesErrorHandler);\n                        } else {\n                            this._shapesRefreshHandler = this._refreshShapes.bind(this);\n                            this._shapesRequestStartHandler = this._shapesRequestStart.bind(this);\n                            this._shapesErrorHandler = this._error.bind(this);\n                        }\n\n                        this.dataSource = kendo.data.DataSource.create(ds)\n                            .bind(\"change\", this._shapesRefreshHandler)\n                            .bind(\"requestStart\", this._shapesRequestStartHandler)\n                            .bind(\"error\", this._shapesErrorHandler);\n                    } else {\n                        this._treeDataSource();\n                        this._isEditable = false;\n                    }\n                },\n\n                _connectionDataSource: function() {\n                    var dsOptions = this.options.connectionsDataSource;\n                    if (dsOptions) {\n                        var ds = isArray(dsOptions) ? { data: dsOptions } : dsOptions;\n\n                        if (this.connectionsDataSource && this._connectionsRefreshHandler) {\n                            this.connectionsDataSource\n                                .unbind(\"change\", this._connectionsRefreshHandler)\n                                .unbind(\"requestStart\", this._connectionsRequestStartHandler)\n                                .unbind(\"error\", this._connectionsErrorHandler);\n                        } else {\n                            this._connectionsRefreshHandler = this._refreshConnections.bind(this);\n                            this._connectionsRequestStartHandler = this._connectionsRequestStart.bind(this);\n                            this._connectionsErrorHandler = this._connectionsError.bind(this);\n                        }\n\n                        this.connectionsDataSource = kendo.data.DataSource.create(ds)\n                            .bind(\"change\", this._connectionsRefreshHandler)\n                            .bind(\"requestStart\", this._connectionsRequestStartHandler)\n                            .bind(\"error\", this._connectionsErrorHandler);\n                    }\n                },\n\n                _shapesRequestStart: function(e) {\n                    if (e.type == \"read\") {\n                        this._loadingShapes = true;\n                    }\n                },\n\n                _connectionsRequestStart: function(e) {\n                    if (e.type == \"read\") {\n                        this._loadingConnections = true;\n                    }\n                },\n\n                _error: function() {\n                    this._loadingShapes = false;\n                },\n\n                _connectionsError: function() {\n                    this._loadingConnections = false;\n                },\n\n                _refreshShapes: function(e) {\n                    if (e.action === \"remove\") {\n                        if (this._shouldRefresh()) {\n                            this._removeShapes(e.items);\n                        }\n                    } else if (e.action === \"itemchange\") {\n                        if (this._shouldRefresh()) {\n                            this._updateShapes(e.items, e.field);\n                        }\n                    } else if (e.action === \"add\") {\n                        this._inactiveShapeItems.add(e.items);\n                    } else if (e.action === \"sync\") {\n                        this._syncShapes(e.items);\n                    } else {\n                        this.refresh();\n                    }\n                },\n\n                _shouldRefresh: function() {\n                    return !this._suspended;\n                },\n\n                _suspendModelRefresh: function() {\n                    this._suspended = (this._suspended || 0) + 1;\n                },\n\n                _resumeModelRefresh: function() {\n                    this._suspended = math.max((this._suspended || 0) - 1, 0);\n                },\n\n                refresh: function() {\n                    this._loadingShapes = false;\n                    if (!this._loadingConnections) {\n                        this._rebindShapesAndConnections();\n                    }\n                },\n\n                _rebindShapesAndConnections: function() {\n                    this.clear();\n                    this._addShapes(this.dataSource.view());\n                    if (this.connectionsDataSource) {\n                        this._addConnections(this.connectionsDataSource.view(), false);\n                    }\n\n                    if (this.options.layout) {\n                        this.layout(this.options.layout);\n                    } else {\n                        this._redrawConnections();\n                    }\n                    this.trigger(\"dataBound\");\n                },\n\n                refreshConnections: function() {\n                    this._loadingConnections = false;\n                    if (!this._loadingShapes) {\n                        this._rebindShapesAndConnections();\n                    }\n                },\n\n                _redrawConnections: function() {\n                    var connections = this.connections;\n                    for (var idx = 0; idx < connections.length; idx++) {\n                        connections[idx].refresh();\n                    }\n                },\n\n                _removeShapes: function(items) {\n                    var dataMap = this._dataMap;\n                    var item, i;\n                    for (i = 0; i < items.length; i++) {\n                        item = items[i];\n                        if (dataMap[item.id]) {\n                            this.remove(dataMap[item.id], false);\n                            dataMap[item.id] = null;\n                        }\n                    }\n                },\n\n                _syncShapes: function() {\n                    var diagram = this;\n                    var inactiveItems = diagram._inactiveShapeItems;\n                    inactiveItems.forEach(function(inactiveItem) {\n                        var dataItem = inactiveItem.dataItem;\n                        var shape = inactiveItem.element;\n                        if (!dataItem.isNew()) {\n                            if (shape) {\n                                shape._setOptionsFromModel();\n                                diagram.addShape(shape, inactiveItem.undoable);\n                                diagram._dataMap[dataItem.id] = shape;\n                            } else {\n                                diagram._addDataItem(dataItem);\n                            }\n                            inactiveItem.activate();\n                            inactiveItems.remove(dataItem);\n                        }\n                    });\n                },\n\n                _updateShapes: function(items, field) {\n                    for (var i = 0; i < items.length; i++) {\n                        var dataItem = items[i];\n\n                        var shape = this._dataMap[dataItem.id];\n                        if (shape) {\n                            shape.updateOptionsFromModel(dataItem, field);\n                        }\n                    }\n                },\n\n                _addShapes: function(dataItems) {\n                    for (var i = 0; i < dataItems.length; i++) {\n                        this._addDataItem(dataItems[i], false);\n                    }\n                },\n\n                _refreshConnections: function(e) {\n                    if (e.action === \"remove\") {\n                        if (this._shouldRefresh()) {\n                            this._removeConnections(e.items);\n                        }\n                    } else if (e.action === \"add\") {\n                        this._addConnections(e.items);\n                    } else if (e.action === \"sync\") {\n                        //TO DO: include logic to update the connections with different values returned from the server.\n                    } else if (e.action === \"itemchange\") {\n                        if (this._shouldRefresh()) {\n                            this._updateConnections(e.items);\n                        }\n                    } else {\n                        this.refreshConnections();\n                    }\n                },\n\n                _removeConnections: function(items) {\n                    for (var i = 0; i < items.length; i++) {\n                        this.remove(this._connectionsDataMap[items[i].uid], false);\n                        this._connectionsDataMap[items[i].uid] = null;\n                    }\n                },\n\n                _updateConnections: function(items) {\n                    for (var i = 0; i < items.length; i++) {\n                        var dataItem = items[i];\n\n                        var connection = this._connectionsDataMap[dataItem.uid];\n                        connection.updateOptionsFromModel(dataItem);\n                    }\n                },\n\n                _addConnections: function(connections, undoable) {\n                    var length = connections.length;\n\n                    for (var i = 0; i < length; i++) {\n                        var dataItem = connections[i];\n                        this._addConnectionDataItem(dataItem, undoable);\n                    }\n                },\n\n                _addConnectionDataItem: function(dataItem, undoable) {\n                    if (!this._connectionsDataMap[dataItem.uid]) {\n                        var from = this._validateConnector(dataItem.from);\n                        if (!defined(from) || from === null) {\n                            from = new Point(dataItem.fromX, dataItem.fromY);\n                        }\n\n                        var to = this._validateConnector(dataItem.to);\n                        if (!defined(to) || to === null) {\n                            to = new Point(dataItem.toX, dataItem.toY);\n                        }\n\n                        if (defined(from) && defined(to)) {\n                            var options = deepExtend({}, this.options.connectionDefaults);\n                            options.dataItem = dataItem;\n                            var connection = new Connection(from, to, options);\n\n                            this._connectionsDataMap[dataItem.uid] = connection;\n                            this.addConnection(connection, undoable);\n                        }\n                    }\n                },\n\n                _validateConnector: function(value) {\n                    var connector;\n\n                    if (defined(value) && value !== null) {\n                        connector = this._dataMap[value];\n                    }\n\n                    return connector;\n                },\n\n                _treeDataSource: function() {\n                    var that = this,\n                        options = that.options,\n                        dataSource = options.dataSource;\n\n                    dataSource = isArray(dataSource) ? { data: dataSource } : dataSource;\n\n                    if (dataSource instanceof kendo.data.DataSource && !(dataSource instanceof kendo.data.HierarchicalDataSource)) {\n                        throw new Error(\"Incorrect DataSource type. If a single dataSource instance is set to the diagram then it should be a HierarchicalDataSource. You should set only the options instead of an instance or a HierarchicalDataSource instance or supply connectionsDataSource as well.\");\n                    }\n\n                    if (!dataSource.fields) {\n                        dataSource.fields = [\n                            { field: \"text\" },\n                            { field: \"url\" },\n                            { field: \"spriteCssClass\" },\n                            { field: \"imageUrl\" }\n                        ];\n                    }\n                    if (that.dataSource && that._refreshHandler) {\n                        that._unbindDataSource();\n                    }\n\n                    that._refreshHandler = that._refreshSource.bind(that);\n                    that._errorHandler = that._error.bind(that);\n\n                    that.dataSource = HierarchicalDataSource.create(dataSource)\n                        .bind(CHANGE, that._refreshHandler)\n                        .bind(ERROR, that._errorHandler);\n                },\n\n                _unbindDataSource: function() {\n                    var that = this;\n\n                    that.dataSource.unbind(CHANGE, that._refreshHandler).unbind(ERROR, that._errorHandler);\n                },\n\n                _adorn: function(adorner, isActive) {\n                    if (isActive !== undefined$1 && adorner) {\n                        if (isActive) {\n                            this._adorners.push(adorner);\n                            this.adornerLayer.append(adorner.visual);\n                        }\n                        else {\n                            Utils.remove(this._adorners, adorner);\n                            this.adornerLayer.remove(adorner.visual);\n                        }\n                    }\n                },\n\n                _showConnectors: function(shape, value) {\n                    if (value) {\n                        this._connectorsAdorner.show(shape);\n                    } else {\n                        this._connectorsAdorner.destroy();\n                    }\n                },\n\n                _updateAdorners: function() {\n                    var adorners = this._adorners;\n\n                    for (var i = 0; i < adorners.length; i++) {\n                        var adorner = adorners[i];\n\n                        if (adorner.refreshBounds) {\n                            adorner.refreshBounds();\n                        }\n                        adorner.refresh();\n                    }\n                },\n\n                _refresh: function() {\n                    for (var i = 0; i < this.connections.length; i++) {\n                        this.connections[i].refresh();\n                    }\n                },\n\n                _destroyToolBar: function() {\n                    if (this.singleToolBar) {\n                        this.singleToolBar.hide();\n                        this.singleToolBar.destroy();\n                        this.singleToolBar = null;\n                    }\n                },\n\n                _destroyGlobalToolBar: function() {\n                    if (this.toolBar) {\n                        this.toolBar.hide();\n                        this.toolBar.destroy();\n                        this.toolBar = null;\n                    }\n                },\n\n                exportDOMVisual: function() {\n                    var viewBox = this.canvas._viewBox;\n                    var scrollOffset = geom.transform()\n                                           .translate(-viewBox.x, -viewBox.y);\n\n                    var viewRect = new geom.Rect([0, 0], [viewBox.width, viewBox.height]);\n                    var clipPath = draw.Path.fromRect(viewRect);\n                    var wrap = new draw.Group({ transform: scrollOffset });\n                    var clipWrap = new draw.Group({ clip: clipPath });\n                    var root = this.canvas.drawingElement.children[0];\n\n                    clipWrap.append(wrap);\n\n                    // Don't reparent the root\n                    wrap.children.push(root);\n\n                    return clipWrap;\n                },\n\n                exportVisual: function() {\n                    var scale = geom.transform().scale(1 / this._zoom);\n                    var wrap = new draw.Group({\n                        transform: scale\n                    });\n\n                    var root = this.mainLayer.drawingElement;\n                    wrap.children.push(root);\n\n                    return wrap;\n                },\n\n                _syncChanges: function() {\n                    this._syncShapeChanges();\n                    this._syncConnectionChanges();\n                },\n\n                _syncShapeChanges: function() {\n                    if (this.dataSource && this._isEditable) {\n                        this.dataSource.sync();\n                    }\n                },\n\n                _syncConnectionChanges: function() {\n                    var that = this;\n                    if (that.connectionsDataSource && that._isEditable) {\n                        $.when.apply($, that._deferredConnectionUpdates).then(function() {\n                            that.connectionsDataSource.sync();\n                        });\n                        that.deferredConnectionUpdates = [];\n                    }\n                }\n            });\n\n            dataviz.ExportMixin.extend(Diagram.fn, true);\n\n            if (kendo.PDFMixin) {\n                kendo.PDFMixin.extend(Diagram.fn);\n            }\n\n            function filterShapeDataItem(dataItem) {\n                var result = {};\n\n                dataItem = dataItem || {};\n\n                if (defined(dataItem.text) && dataItem.text !== null) {\n                    result.text = dataItem.text;\n                }\n\n                if (defined(dataItem.x) && dataItem.x !== null) {\n                    result.x = dataItem.x;\n                }\n\n                if (defined(dataItem.y) && dataItem.y !== null) {\n                    result.y = dataItem.y;\n                }\n\n                if (defined(dataItem.width) && dataItem.width !== null) {\n                    result.width = dataItem.width;\n                }\n\n                if (defined(dataItem.height) && dataItem.height !== null) {\n                    result.height = dataItem.height;\n                }\n\n                if (defined(dataItem.type) && dataItem.type !== null) {\n                    result.type = dataItem.type;\n                }\n\n                return result;\n            }\n\n            function filterConnectionDataItem(dataItem) {\n                var result = {};\n\n                dataItem = dataItem || {};\n\n                if (defined(dataItem.text) && dataItem.text !== null) {\n                    result.content = dataItem.text;\n                }\n\n                if (defined(dataItem.type) && dataItem.type !== null) {\n                    result.type = dataItem.type;\n                }\n\n                if (defined(dataItem.from) && dataItem.from !== null) {\n                    result.from = dataItem.from;\n                }\n\n                if (defined(dataItem.fromConnector) && dataItem.fromConnector !== null) {\n                    result.fromConnector = dataItem.fromConnector;\n                }\n\n                if (defined(dataItem.fromX) && dataItem.fromX !== null) {\n                    result.fromX = dataItem.fromX;\n                }\n\n                if (defined(dataItem.fromY) && dataItem.fromY !== null) {\n                    result.fromY = dataItem.fromY;\n                }\n\n                if (defined(dataItem.to) && dataItem.to !== null) {\n                    result.to = dataItem.to;\n                }\n\n                if (defined(dataItem.toConnector) && dataItem.toConnector !== null) {\n                    result.toConnector = dataItem.toConnector;\n                }\n\n                if (defined(dataItem.toX) && dataItem.toX !== null) {\n                    result.toX = dataItem.toX;\n                }\n\n                if (defined(dataItem.toY) && dataItem.toY !== null) {\n                    result.toY = dataItem.toY;\n                }\n\n                return result;\n            }\n\n\n            var DiagramToolBar = kendo.Observable.extend({\n                init: function(diagram, options) {\n                    kendo.Observable.fn.init.call(this);\n                    this.diagram = diagram;\n                    this.options = deepExtend({}, this.options, options);\n                    this._tools = [];\n                    this.createToolBar();\n                    this.createTools();\n                    this.appendTools();\n\n                    if (this.options.modal) {\n                        this.createPopup();\n                    }\n\n                    this.bind(this.events, options);\n                },\n\n                events: [\"click\"],\n\n                createPopup: function() {\n                    this.container = $(\"<div/>\").append(this.element);\n                    this._popup = this.container.kendoPopup({}).getKendoPopup();\n                },\n\n                appendTools: function() {\n                    for (var i = 0; i < this._tools.length; i++) {\n                        var tool = this._tools[i];\n                        if (tool.buttons && tool.buttons.length || !defined(tool.buttons)) {\n                            this._toolBar.add(tool);\n                        }\n                    }\n                },\n\n                createToolBar: function() {\n                    this.element = $(\"<div/>\");\n                    this._toolBar = this.element\n                        .kendoToolBar({\n                            click: this.click.bind(this),\n                            resizable: false\n                        }).getKendoToolBar();\n\n                    this.element.css(\"border\", \"none\");\n                },\n\n                createTools: function() {\n                    for (var i = 0; i < this.options.tools.length; i++) {\n                        this.createTool(this.options.tools[i]);\n                    }\n                },\n\n                createTool: function(tool) {\n                    if (!isPlainObject(tool)) {\n                        tool = {\n                            name: tool\n                        };\n                    }\n                    var toolName = tool.name + \"Tool\";\n                    if (this[toolName]) {\n                        this[toolName](tool);\n                    } else {\n                        this._tools.push(deepExtend({}, tool, {\n                            attributes: this._setAttributes({ action: tool.name })\n                        }));\n                    }\n                },\n\n                showAt: function(point) {\n                    var popupZIndex = parseInt(this.options.popupZIndex, 10);\n\n                    if (this._popup) {\n                        this._popup.open(point.x, point.y);\n\n                        if (popupZIndex) {\n                            this._popup.wrapper.css(\"zIndex\", popupZIndex);\n                        }\n                    }\n                },\n\n                hide: function() {\n                    if (this._popup) {\n                        this._popup.close();\n                    }\n                },\n\n                newGroup: function() {\n                    return {\n                        type: \"buttonGroup\",\n                        buttons: []\n                    };\n                },\n\n                editTool: function() {\n                    this._tools.push({\n                        icon: \"pencil\",\n                        showText: \"overflow\",\n                        type: \"button\",\n                        text: \"Edit\",\n                        attributes: this._setAttributes({ action: \"edit\" })\n                    });\n                },\n\n                deleteTool: function() {\n                    this._tools.push({\n                        icon: \"x\",\n                        showText: \"overflow\",\n                        type: \"button\",\n                        text: \"Delete\",\n                        attributes: this._setAttributes({ action: \"delete\" })\n                    });\n                },\n\n                rotateAnticlockwiseTool: function(options) {\n                    this._appendGroup(\"rotate\");\n                    this._rotateGroup.buttons.push({\n                        icon: \"rotate-left\",\n                        showText: \"overflow\",\n                        text: \"RotateAnticlockwise\",\n                        group: \"rotate\",\n                        attributes: this._setAttributes({ action: \"rotateAnticlockwise\", step: options.step })\n                    });\n                },\n\n                rotateClockwiseTool: function(options) {\n                    this._appendGroup(\"rotate\");\n                    this._rotateGroup.buttons.push({\n                        icon: \"rotate-right\",\n                        attributes: this._setAttributes({ action: \"rotateClockwise\", step: options.step }),\n                        showText: \"overflow\",\n                        text: \"RotateClockwise\",\n                        group: \"rotate\"\n                    });\n                },\n\n                createShapeTool: function() {\n                    this._appendGroup(\"create\");\n                    this._createGroup.buttons.push({\n                        icon: \"shapes\",\n                        showText: \"overflow\",\n                        text: \"CreateShape\",\n                        group: \"create\",\n                        attributes: this._setAttributes({ action: \"createShape\" })\n                    });\n                },\n\n                createConnectionTool: function() {\n                    this._appendGroup(\"create\");\n                    this._createGroup.buttons.push({\n                        icon: \"connector\",\n                        showText: \"overflow\",\n                        text: \"CreateConnection\",\n                        group: \"create\",\n                        attributes: this._setAttributes({ action: \"createConnection\" })\n                    });\n                },\n\n                undoTool: function() {\n                    this._appendGroup(\"history\");\n                    this._historyGroup.buttons.push({\n                        icon: \"undo\",\n                        showText: \"overflow\",\n                        text: \"Undo\",\n                        group: \"history\",\n                        attributes: this._setAttributes({ action: \"undo\" })\n                    });\n                },\n\n                redoTool: function() {\n                    this._appendGroup(\"history\");\n                    this._historyGroup.buttons.push({\n                        icon: \"redo\",\n                        showText: \"overflow\",\n                        text: \"Redo\",\n                        group: \"history\",\n                        attributes: this._setAttributes({ action: \"redo\" })\n                    });\n                },\n\n                _appendGroup: function(name) {\n                    var prop = \"_\" + name + \"Group\";\n                    if (!this[prop]) {\n                        this[prop] = this.newGroup();\n                        this._tools.push(this[prop]);\n                    }\n                },\n\n                _setAttributes: function(attributes) {\n                    var attr = {};\n\n                    if (attributes.action) {\n                        attr[kendo.attr(\"action\")] = attributes.action;\n                    }\n\n                    if (attributes.step) {\n                        attr[kendo.attr(\"step\")] = attributes.step;\n                    }\n\n                    return attr;\n                },\n\n                _getAttributes: function(element) {\n                    var attr = {};\n\n                    var action = element.attr(kendo.attr(\"action\"));\n                    if (action) {\n                        attr.action = action;\n                    }\n\n                    var step = element.attr(kendo.attr(\"step\"));\n                    if (step) {\n                        attr.step = step;\n                    }\n\n                    return attr;\n                },\n\n                click: function(e) {\n                    var attributes = this._getAttributes($(e.target));\n                    var action = attributes.action;\n\n                    if (action && this[action]) {\n                        this[action](attributes);\n                    }\n\n                    this.trigger(\"click\", this.eventData(action, e.target));\n                },\n\n                eventData: function(action, target) {\n                    var elements = this.selectedElements(),\n                        length = elements.length,\n                        shapes = [], connections = [], element;\n\n                    for (var idx = 0; idx < length; idx++) {\n                        element = elements[idx];\n                        if (element instanceof Shape) {\n                            shapes.push(element);\n                        } else {\n                            connections.push(element);\n                        }\n                    }\n\n                    return {\n                        shapes: shapes,\n                        connections: connections,\n                        action: action,\n                        target: target\n                    };\n                },\n\n                \"delete\": function() {\n                    var diagram = this.diagram;\n                    var toRemove = diagram._triggerRemove(this.selectedElements());\n                    if (toRemove.length) {\n                        this.diagram.remove(toRemove, true);\n                        this.diagram._syncChanges();\n                    }\n                },\n\n                edit: function() {\n                    var selectedElemens = this.selectedElements();\n                    if (selectedElemens.length === 1) {\n                        this.diagram.edit(selectedElemens[0]);\n                    }\n                },\n\n                rotateClockwise: function(options) {\n                    var angle = parseFloat(options.step || 90);\n                    this._rotate(angle);\n                },\n\n                rotateAnticlockwise: function(options) {\n                    var angle = parseFloat(options.step || 90);\n                    this._rotate(-angle);\n                },\n\n                _rotate: function(angle) {\n                    var adorner = this.diagram._resizingAdorner;\n                    adorner.angle(adorner.angle() + angle);\n                    adorner.rotate();\n                },\n\n                selectedElements: function() {\n                    return this.diagram.select();\n                },\n\n                createShape: function() {\n                    this.diagram.createShape();\n                },\n\n                createConnection: function() {\n                    this.diagram.createConnection();\n                },\n\n                undo: function() {\n                    this.diagram.undo();\n                },\n\n                redo: function() {\n                    this.diagram.redo();\n                },\n\n                destroy: function() {\n                    this.diagram = null;\n                    this.element = null;\n                    this.options = null;\n\n                    if (this._toolBar) {\n                        this._toolBar.destroy();\n                    }\n\n                    if (this._popup) {\n                        this._popup.destroy();\n                    }\n                }\n            });\n\n            var Editor = kendo.Observable.extend({\n                init: function(element, options) {\n                    kendo.Observable.fn.init.call(this);\n\n                    this.options = extend(true, {}, this.options, options);\n                    this.element = element;\n                    this.model = this.options.model;\n                    this.fields = this._getFields();\n                    this._initContainer();\n                    this.createEditable();\n                },\n\n                options: {\n                    editors: {}\n                },\n\n                _initContainer: function() {\n                    this.wrapper = this.element;\n                },\n\n                createEditable: function() {\n                    var options = this.options;\n\n                    this.editable = new kendo.ui.Editable(this.wrapper, {\n                        fields: this.fields,\n                        target: options.target,\n                        clearContainer: false,\n                        model: this.model\n                    });\n                },\n\n                _isEditable: function(field) {\n                    return this.model.editable && this.model.editable(field);\n                },\n\n                _getFields: function() {\n                    var fields = [];\n                    var modelFields = this.model.fields;\n\n                    for (var field in modelFields) {\n                        var result = {};\n                        if (this._isEditable(field)) {\n                            var editor = this.options.editors[field];\n                            if (editor) {\n                                result.editor = editor;\n                            }\n                            result.field = field;\n                            fields.push(result);\n                        }\n                    }\n\n                    return fields;\n                },\n\n                end: function() {\n                    return this.editable.end();\n                },\n\n                destroy: function() {\n                    this.editable.destroy();\n                    this.editable.element.find(\"[\" + kendo.attr(\"container-for\") + \"]\").empty();\n                    this.model = this.wrapper = this.element = this.columns = this.editable = null;\n                }\n            });\n\n            var PopupEditor = Editor.extend({\n                init: function(element, options) {\n                    Editor.fn.init.call(this, element, options);\n                    this.bind(this.events, this.options);\n\n                    this.open();\n                },\n\n                events: [ \"update\", \"cancel\" ],\n\n                options: {\n                    window: {\n                        modal: true,\n                        resizable: false,\n                        draggable: true,\n                        title: \"Edit\",\n                        visible: false\n                    }\n                },\n\n                _initContainer: function() {\n                    var that = this;\n                    this.wrapper = $('<div class=\"k-popup-edit-form\"/>')\n                        .attr(kendo.attr(\"uid\"), this.model.uid);\n\n                    var formContent = \"\";\n\n                    if (this.options.template) {\n                        formContent += this._renderTemplate();\n                        this.fields = [];\n                    } else {\n                        formContent += this._renderFields();\n                    }\n\n                    formContent += this._renderButtons();\n\n                    this.wrapper.append(\n                        $('<div class=\"k-edit-form-container\"/>').append(formContent));\n\n                    this.window = new kendo.ui.Window(this.wrapper.appendTo(this.element), this.options.window);\n                    this.window.bind(\"close\", function(e) {\n                        //The bellow line is required due to: draggable window in IE, change event will be triggered while the window is closing\n                        if (e.userTriggered) {\n                            e.sender.element.trigger(\"focus\");\n                            that._cancelClick(e);\n                        }\n                    });\n\n                    this._attachButtonEvents();\n                },\n\n                _renderTemplate: function() {\n                    var template = this.options.template;\n\n                    if (typeof template === \"string\") {\n                        template = kendo.unescape(template);\n                    }\n\n                    template = kendo.template(template)(this.model);\n\n                    return template;\n                },\n\n                _renderFields: function() {\n                    var form = \"\";\n                    for (var i = 0; i < this.fields.length; i++) {\n                        var field = this.fields[i];\n\n                        form += '<div class=\"k-edit-label\"><label for=\"' + field.field + '\">' + (field.field || \"\") + '</label></div>';\n\n                        if (this._isEditable(field.field)) {\n                            form += '<div ' + kendo.attr(\"container-for\") + '=\"' + field.field +\n                            '\" class=\"k-edit-field\"></div>';\n                        }\n                    }\n\n                    return form;\n                },\n\n                _renderButtons: function() {\n                    var form = '<div class=\"k-edit-buttons\">';\n                    form += this._createButton(\"update\");\n                    form += this._createButton(\"cancel\");\n                    form += '</div>';\n                    return form;\n                },\n\n                _createButton: function(name) {\n                    return kendo.template(BUTTON_TEMPLATE)(defaultButtons[name]);\n                },\n\n                _attachButtonEvents: function() {\n                    this._cancelClickHandler = this._cancelClick.bind(this);\n                    this.window.element.on(CLICK + NS, \"button.k-diagram-cancel\", this._cancelClickHandler);\n\n                    this._updateClickHandler = this._updateClick.bind(this);\n                    this.window.element.on(CLICK + NS, \"button.k-diagram-update\", this._updateClickHandler);\n                },\n\n                _updateClick: function(e) {\n                    e.preventDefault();\n                    this.trigger(\"update\");\n                },\n\n                _cancelClick: function(e) {\n                    e.preventDefault();\n                    this.trigger(\"cancel\");\n                },\n\n                open: function() {\n                    this.window.center().open();\n                },\n\n                close: function() {\n                    this.window.bind(\"deactivate\", this.destroy.bind(this)).close();\n                },\n\n                destroy: function() {\n                    this.window.close().destroy();\n                    this.window.element.off(CLICK + NS, \"a.k-diagram-cancel\", this._cancelClickHandler);\n                    this.window.element.off(CLICK + NS, \"a.k-diagram-update\", this._updateClickHandler);\n                    this._cancelClickHandler = null;\n                    this._editUpdateClickHandler = null;\n                    this.window = null;\n                    Editor.fn.destroy.call(this);\n                }\n            });\n\n            function connectionSelector(container, options) {\n                var model = this.dataSource.reader.model;\n                if (model) {\n                    var textField = model.fn.fields.text ? \"text\" : model.idField;\n                    $(\"<input name='\" + options.field + \"' />\")\n                        .appendTo(container).kendoDropDownList({\n                            dataValueField: model.idField,\n                            dataTextField: textField,\n                            dataSource: this.dataSource.data().toJSON(),\n                            optionLabel: \" \",\n                            valuePrimitive: true\n                        });\n                }\n            }\n\n            function InactiveItem(dataItem) {\n                this.dataItem = dataItem;\n                this.callbacks = [];\n            }\n\n            InactiveItem.fn = InactiveItem.prototype = {\n                onActivate: function(callback) {\n                    var deffered = $.Deferred();\n                    this.callbacks.push({\n                        callback: callback,\n                        deferred: deffered\n                    });\n                    return deffered;\n                },\n\n                activate: function() {\n                    var callbacks = this.callbacks;\n                    var item;\n                    for (var idx = 0; idx < callbacks.length; idx++) {\n                        item = this.callbacks[idx];\n                        item.callback(this.dataItem);\n                        item.deferred.resolve();\n                    }\n                    this.callbacks = [];\n                }\n            };\n\n            function InactiveItemsCollection() {\n                this.items = {};\n            }\n\n            InactiveItemsCollection.fn = InactiveItemsCollection.prototype = {\n                add: function(items) {\n                    for (var idx = 0; idx < items.length; idx++) {\n                        this.items[items[idx].uid] = new InactiveItem(items[idx]);\n                    }\n                },\n\n                forEach: function(callback) {\n                    for (var uid in this.items) {\n                        callback(this.items[uid]);\n                    }\n                },\n\n                getByUid: function(uid) {\n                    return this.items[uid];\n                },\n\n                remove: function(item) {\n                    delete this.items[item.uid];\n                }\n            };\n\n            var QuadRoot = Class.extend({\n                init: function() {\n                    this.shapes = [];\n                },\n\n                _add: function(shape, bounds) {\n                    this.shapes.push({\n                        bounds: bounds,\n                        shape: shape\n                    });\n                    shape._quadNode = this;\n                },\n\n                insert: function(shape, bounds) {\n                    this._add(shape, bounds);\n                },\n\n                remove: function(shape) {\n                    var shapes = this.shapes;\n                    var length = shapes.length;\n\n                    for (var idx = 0; idx < length; idx++) {\n                        if (shapes[idx].shape === shape) {\n                            shapes.splice(idx, 1);\n                            break;\n                        }\n                    }\n                },\n\n                hitTestRect: function(rect, exclude) {\n                    var shapes = this.shapes;\n                    var length = shapes.length;\n\n                    for (var i = 0; i < length; i++) {\n                        if (this._testRect(shapes[i].shape, rect) && !dataviz.inArray(shapes[i].shape, exclude)) {\n                            return true;\n                        }\n                    }\n                },\n\n                _testRect: function(shape, rect) {\n                    var angle = shape.rotate().angle;\n                    var bounds = shape.bounds();\n                    var hit;\n                    if (!angle) {\n                        hit = bounds.overlaps(rect);\n                    } else {\n                        hit = Intersect.rects(rect, bounds, -angle);\n                    }\n                    return hit;\n                }\n            });\n\n            var QuadNode = QuadRoot.extend({\n                init: function(rect) {\n                    QuadRoot.fn.init.call(this);\n                    this.children = [];\n                    this.rect = rect;\n                },\n\n                inBounds: function(rect) {\n                    var nodeRect = this.rect;\n                    var nodeBottomRight = nodeRect.bottomRight();\n                    var bottomRight = rect.bottomRight();\n                    var inBounds = nodeRect.x <= rect.x && nodeRect.y <= rect.y && bottomRight.x <= nodeBottomRight.x &&\n                        bottomRight.y <= nodeBottomRight.y;\n                    return inBounds;\n                },\n\n                overlapsBounds: function(rect) {\n                    return this.rect.overlaps(rect);\n                },\n\n                insert: function(shape, bounds) {\n                    var inserted = false;\n                    var children = this.children;\n                    var length = children.length;\n                    if (this.inBounds(bounds)) {\n                        if (!length && this.shapes.length < 4) {\n                            this._add(shape, bounds);\n                        } else {\n                            if (!length) {\n                                this._initChildren();\n                            }\n\n                            for (var idx = 0; idx < children.length; idx++) {\n                                if (children[idx].insert(shape, bounds)) {\n                                    inserted = true;\n                                    break;\n                                }\n                            }\n\n                            if (!inserted) {\n                                this._add(shape, bounds);\n                            }\n                        }\n                        inserted = true;\n                    }\n\n                    return inserted;\n                },\n\n                _initChildren: function() {\n                    var rect = this.rect,\n                        children = this.children,\n                        shapes = this.shapes,\n                        center = rect.center(),\n                        halfWidth = rect.width / 2,\n                        halfHeight = rect.height / 2,\n                        childIdx, shapeIdx;\n\n                    children.push(\n                        new QuadNode(new Rect(rect.x, rect.y, halfWidth, halfHeight)),\n                        new QuadNode(new Rect(center.x, rect.y, halfWidth, halfHeight)),\n                        new QuadNode(new Rect(rect.x, center.y, halfWidth, halfHeight)),\n                        new QuadNode(new Rect(center.x, center.y, halfWidth, halfHeight))\n                    );\n                    for (shapeIdx = shapes.length - 1; shapeIdx >= 0; shapeIdx--) {\n                        for (childIdx = 0; childIdx < children.length; childIdx++) {\n                            if (children[childIdx].insert(shapes[shapeIdx].shape, shapes[shapeIdx].bounds)) {\n                                shapes.splice(shapeIdx, 1);\n                                break;\n                            }\n                        }\n                    }\n                },\n\n                hitTestRect: function(rect, exclude) {\n                    var idx;\n                    var children = this.children;\n                    var length = children.length;\n                    var hit = false;\n\n                    if (this.overlapsBounds(rect)) {\n                        if (QuadRoot.fn.hitTestRect.call(this, rect, exclude)) {\n                            hit = true;\n                        } else {\n                             for (idx = 0; idx < length; idx++) {\n                                if (children[idx].hitTestRect(rect, exclude)) {\n                                   hit = true;\n                                   break;\n                                }\n                            }\n                        }\n                    }\n\n                    return hit;\n                }\n            });\n\n            var ShapesQuadTree = Class.extend({\n                ROOT_SIZE: 1000,\n\n                init: function(diagram) {\n                    var boundsChangeHandler = this._boundsChange.bind(this);\n                    diagram.bind(ITEMBOUNDSCHANGE, boundsChangeHandler);\n                    diagram.bind(ITEMROTATE, boundsChangeHandler);\n                    this.initRoots();\n                },\n\n                initRoots: function() {\n                    this.rootMap = {};\n                    this.root = new QuadRoot();\n                },\n\n                clear: function() {\n                    this.initRoots();\n                },\n\n                _boundsChange: function(e) {\n                    if (e.item._quadNode) {\n                        e.item._quadNode.remove(e.item);\n                    }\n                    this.insert(e.item);\n                },\n\n                insert: function(shape) {\n                    var bounds = shape.bounds(ROTATED);\n                    var rootSize = this.ROOT_SIZE;\n                    var sectors = this.getSectors(bounds);\n                    var x = sectors[0][0];\n                    var y = sectors[1][0];\n\n                    if (this.inRoot(sectors)) {\n                        this.root.insert(shape, bounds);\n                    } else {\n                        if (!this.rootMap[x]) {\n                            this.rootMap[x] = {};\n                        }\n\n                        if (!this.rootMap[x][y]) {\n                            this.rootMap[x][y] = new QuadNode(\n                                new Rect(x * rootSize, y * rootSize, rootSize, rootSize)\n                            );\n                        }\n\n                        this.rootMap[x][y].insert(shape, bounds);\n                    }\n                },\n\n                remove: function(shape) {\n                    if (shape._quadNode) {\n                        shape._quadNode.remove(shape);\n                    }\n                },\n\n                inRoot: function(sectors) {\n                    return sectors[0].length > 1 || sectors[1].length > 1;\n                },\n\n                getSectors: function(rect) {\n                    var rootSize = this.ROOT_SIZE;\n                    var bottomRight = rect.bottomRight();\n                    var bottomX = math.floor(bottomRight.x / rootSize);\n                    var bottomY = math.floor(bottomRight.y / rootSize);\n                    var sectors = [[],[]];\n                    for (var x = math.floor(rect.x / rootSize); x <= bottomX; x++) {\n                        sectors[0].push(x);\n                    }\n                    for (var y = math.floor(rect.y / rootSize); y <= bottomY; y++) {\n                        sectors[1].push(y);\n                    }\n                    return sectors;\n                },\n\n                hitTestRect: function(rect, exclude) {\n                    var sectors = this.getSectors(rect);\n                    var xIdx, yIdx, x, y;\n                    var root;\n\n                    if (this.root.hitTestRect(rect, exclude)) {\n                        return true;\n                    }\n\n                    for (xIdx = 0; xIdx < sectors[0].length; xIdx++) {\n                        x = sectors[0][xIdx];\n                        for (yIdx = 0; yIdx < sectors[1].length; yIdx++) {\n                            y = sectors[1][yIdx];\n                            root = (this.rootMap[x] || {})[y];\n                            if (root && root.hitTestRect(rect, exclude)) {\n                                return true;\n                            }\n                        }\n                    }\n\n                    return false;\n                }\n            });\n\n            function cloneDataItem(dataItem) {\n                var result = dataItem;\n                if (dataItem instanceof kendo.data.Model) {\n                    result = dataItem.toJSON();\n                    result[dataItem.idField] = dataItem._defaultId;\n                }\n                return result;\n            }\n\n            function splitDiagramElements(elements) {\n                var connections = [];\n                var shapes = [];\n                var element, idx;\n                for (idx = 0; idx < elements.length; idx++) {\n                    element = elements[idx];\n                    if (element instanceof Shape) {\n                        shapes.push(element);\n                    } else {\n                        connections.push(element);\n                    }\n                }\n                return {\n                    shapes: shapes,\n                    connections: connections\n                };\n            }\n\n            function createModel(dataSource, model) {\n                if (dataSource.reader.model) {\n                    return new dataSource.reader.model(model);\n                }\n\n                return new kendo.data.ObservableObject(model);\n            }\n\n            function clearField(field, model) {\n                if (defined(model[field])) {\n                    model.set(field, null);\n                }\n            }\n\n            function copyDefaultOptions(mainOptions, elementOptions, fields) {\n                var field;\n                for (var idx = 0; idx < fields.length; idx++) {\n                    field = fields[idx];\n                    if (elementOptions && !defined(elementOptions[field])) {\n                        elementOptions[field] = mainOptions[field];\n                    }\n                }\n            }\n\n            function translateToOrigin(visual) {\n                var bbox = visual.drawingContainer().clippedBBox(null);\n                if (bbox.origin.x !== 0 || bbox.origin.y !== 0) {\n                    visual.position(-bbox.origin.x, -bbox.origin.y);\n                }\n            }\n\n            function preventDefault(e) {\n                e.preventDefault();\n            }\n\n            dataviz.ui.plugin(Diagram);\n\n            deepExtend(diagram, {\n                Shape: Shape,\n                Connection: Connection,\n                Connector: Connector,\n                DiagramToolBar: DiagramToolBar,\n                QuadNode: QuadNode,\n                QuadRoot: QuadRoot,\n                ShapesQuadTree: ShapesQuadTree,\n                PopupEditor: PopupEditor\n            });\n    })(window.kendo.jQuery);\n\n    const __meta__ = {\n            id: \"dataviz.diagram\",\n            name: \"Diagram\",\n            category: \"dataviz\",\n            description: \"The Kendo DataViz Diagram \",\n            depends: [ \"data\", \"userevents\", \"mobile.scroller\", \"draganddrop\", \"drawing\", \"dataviz.core\", \"dataviz.themes\", \"toolbar\" ],\n            features: [{\n                id: \"dataviz.diagram-pdf-export\",\n                name: \"PDF export\",\n                description: \"Export Diagram as PDF\",\n                depends: [ \"pdf\" ]\n            },{\n                id: \"dataviz.diagram-editing\",\n                name: \"Editing\",\n                description: \"Support for model editing\",\n                depends: [ \"editable\", \"window\", \"dropdownlist\" ]\n            }]\n        };\n        var kendo$1 = kendo;\n\n    exports.__meta__ = __meta__;\n    exports.default = kendo$1;\n\n    Object.defineProperty(exports, '__esModule', { value: true });\n\n}));\n"]}